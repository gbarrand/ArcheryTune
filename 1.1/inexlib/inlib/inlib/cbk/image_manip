// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_cbk_image_manip
#define inlib_cbk_image_manip

#include "../sg/ecbk"
#include "../sg/event_dispatcher"
#include "../sg/tex_rect"
#include "../sg/alert"
#include "../sg/group"
#include "../sg/search"
#include "../geom3"
#include "../num2s"

namespace inlib {
namespace cbk {

class image_manip : public sg::ecbk {
public:
  virtual return_action action() {

    if(sg::move_event* mevt = safe_cast<sg::event,sg::move_event>(*m_event)){

      //m_event_action->set_node(this);
  
      const sg::state& state = m_event_action->state();
  
      typedef vec3f vec3f;

      line<float> line;

      if(state.m_camera_ortho) {
        float x,y,z,w;
        state.screen2ndc(mevt->x(),mevt->y(),x,y,z,w);
        if(w==0.0F) {
          m_alert.out_stream() << "inlib::cbk::image_manip::action :"
                     << " null w."
                     << std::endl;
          return return_none;     
        }

        mat4f mtx = state.m_proj;
        mtx.mul_mtx(state.m_model);
        mat4f inv;
        if(!mtx.invert(inv)) {
          m_alert.out_stream() << "inlib::cbk::image_manip::action :"
                     << " can't convert screen to world coordinates."
                     << std::endl;
          return return_none;     
        }

        float x2 = x;
        float y2 = y;
        float z2 = z+1;

        inv.mul_4f(x,y,z,w);
        x /= w;
        y /= w;
        z /= w;

        inv.mul_4f(x2,y2,z2,w);
        x2 /= w;
        y2 /= w;
        z2 /= w;

        line.set_value(x,y,z,x2,y2,z2);
      } else {
        float x,y,z;
        state.screen2wc(mevt->x(),mevt->y(),x,y,z);
        // NOTE : how to get cam pos in image wc from final proj ?
        // NOTE : the below is ok as long as camera is not under a matrix node.
        mat4f inv;
        if(!state.m_model.invert(inv)) return return_none;
        vec3f pos = state.m_camera_position;
        inv.mul_3f(pos[0],pos[1],pos[2]); //in image wc.
        line.set_value(pos[0],pos[1],pos[2],x,y,z);
      }

      // image plane from three image points :
    //const img_byte& rimg = m_image.rendered_img();
      const img_byte& rimg = m_image.img.value();
      if(rimg.is_empty()) return return_none;

      float imw = (float)rimg.width();
      float imh = (float)rimg.height();
      float h2 = m_image.height*0.5f;
      float w2 = (imw/imh)*h2;
  
      plane<float> plane(vec3f(w2,-h2,0),vec3f(w2,h2,0),vec3f(-w2,h2,0));
      vec3f p;
      if(!plane.intersect(line,p)) return return_none;

      //image coordinates :
      int ix = int((imw*p.x()/w2+imw)*0.5f);
      int iy = int((imh*p.y()/h2+imh)*0.5f);

      //::printf("debug : %d %d : wc %g %g\n",mevt->x(),mevt->y(),x,y);
      //::printf("debug : img : sz : %d %d : %g %g : %d %d\n",
      //    rimg.width(),rimg.height(),p.x(),p.y(),ix,iy);
  
      //rgb of pixel :
      std::vector<unsigned char> pixel;            
      if((ix<0)||(iy<0)||!rimg.pixel(ix,iy,pixel)) {
        //m_alert.out_stream() << "inlib::cbk::image_manip::action :"
        //           << " not in image."
        //           << std::endl;
  
        m_alert.show_console("not in image");
  
        //m_image.show_border = false;

      } else {
        std::string s;
        for(unsigned int ipix=0;ipix<pixel.size();ipix++) {
          if(ipix) s += " ";
          if(!numas<float>(float(pixel[ipix])/255.0f,s)){}
        }
        //m_alert.out_stream() << s << std::endl;
  
        m_alert.show_console(s);

        //m_image.show_border = true;
      }

      m_event_action->set_done(true);
      return return_none;     

    } //move_event

    return return_none;     
  }
  virtual sg::bcbk* copy() const {return new image_manip(*this);}
public:
  image_manip(sg::alert& a_alert,sg::tex_rect& a_image)
  :sg::ecbk()
  ,m_alert(a_alert)
  ,m_image(a_image)
  {}
  virtual ~image_manip(){}
public:
  image_manip(const image_manip& a_from)
  :sg::ecbk(a_from)
  ,m_alert(a_from.m_alert)
  ,m_image(a_from.m_image)
  {}
  image_manip& operator=(const image_manip& a_from){
    sg::ecbk::operator=(a_from);
    return *this;
  }
public:
  static bool set_manip(sg::alert& a_gv,sg::node& a_sg,sg::node* a_node,bool a_verbose){

    sg::tex_rect* img = safe_cast<sg::node,sg::tex_rect>(*a_node);
    if(!img) {
      a_gv.out_stream() << "inlib::cbk::image_manip::set_manip :"
                 << " node of class " << a_node->s_cls() << " is not a tex_rect."
                 << std::endl;
      return false;
    }

    typedef sg::search_action::path_t path_t;

    sg::search_action sa(a_gv.out_stream());
    const path_t& path = sg::find_path(sa,a_sg,a_node,a_verbose);      
      
    sg::group* grp;
    sg::event_dispatcher* dpt;
    int gidx; //index in path of the group.
    if(!sg::rfind<sg::event_dispatcher,
                  sg::group>(path,a_node,grp,dpt,gidx)) {
      a_gv.warn("no event_dispatcher found");
      return false;
    }

    if(a_verbose) {
      a_gv.out_stream() << "inlib::cbk::image_manip::set_manip :"
                 << " action_set_manip : found event_dispatcher."
                 << std::endl;
    }

    if(dpt->cbks().is_empty()) {
      dpt->add_callback(new image_manip(a_gv,*img));
      img->show_border = true;
    } else {
      dpt->clear_cbks();
      img->show_border = false;
    }

    return true;
  }
protected:
  sg::alert& m_alert;
  sg::tex_rect& m_image;
};

}}

#endif
