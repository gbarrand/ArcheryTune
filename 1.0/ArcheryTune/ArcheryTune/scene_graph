// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file ArcheryTune.license for terms.

#ifndef ArcheryTune_ArcheryTune_scene_graph
#define ArcheryTune_ArcheryTune_scene_graph

#include "archery"
#include "dac"

#include <inlib/sg/head_light>
#include <inlib/sg/circle>
#include <inlib/sg/ring>
#include <inlib/sg/axis>
#include <inlib/sg/event_dispatcher>
#include <inlib/sg/render_mem>
#include <exlib/jpeg>

namespace ArcheryTune {

///////////////////////////////////////////////////////////////////////////////////
/// sg constants : ////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
inline float adjust_factor() {return 1.05f;}
inline unsigned int steps()  {return 128;}

inline float z_infos_back_menu()      {return 0.5f;}
inline float z_rings()                {return 0.0f;}
inline float z_back()                 {return -0.1f;}
inline float z_borders()              {return 0.1f;}
inline float z_cross()                {return 0.1f;}
inline float z_numbers()              {return 0.15f;}
inline float z_ghost()                {return 0.2f;}
inline float z_scope_cache_pastille() {return 0.4f;}
inline float z_cursor_ghost()         {return 0.25f;}

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
inline void adjust_tscp_matrix(inlib::sg::matrix& a_mtx,float a_wcam,float a_hcam,float a_scope_radius) {
  float aspect = float(a_wcam)/float(a_hcam);
  float object_size = adjust_factor()*2*a_scope_radius;
  float scale = (aspect>1?a_hcam:a_wcam)/object_size;
  a_mtx.set_scale(scale,scale,1);
}

inline void adjust_infos(exlib::sg::text_freetype& a_text,inlib::sg::matrix& a_matrix,float a_wcam,float a_hcam) {
  float htext = a_text.height;

  float mn_x,mn_y,mn_z;
  float mx_x,mx_y,mx_z;
  a_text.get_bounds(htext,mn_x,mn_y,mn_z,mx_x,mx_y,mx_z);
  float th = mx_y-mn_y;
  if(th>0) {
    // th -> htext
    // x -> x*htext/th
    htext = 0.07f*a_hcam*htext/th;
    a_text.height = htext;
  }
  a_matrix.set_translate(-a_wcam*0.5f,a_hcam*0.5f,z_infos_back_menu());
}

inline void adjust_back_to_menu(inlib::sg::image_button& a_button,inlib::sg::matrix& a_matrix,float a_wcam,float a_hcam) {
  a_button.height = a_hcam*0.1f;
  a_button.width = a_button.height;
  a_matrix.set_translate(-a_wcam*0.5f+a_button.width*0.5f,
                         -a_hcam*0.5f+a_button.height*0.5f,
                         z_infos_back_menu());
}

#ifdef CURSOR_BUTTON
inline void adjust_cursor_button(inlib::sg::image_button& a_button,inlib::sg::matrix& a_matrix,float a_wcam,float a_hcam) {
  a_button.height = a_hcam*0.1f;
  a_button.width = a_button.height;
  a_matrix.set_translate(-a_wcam*0.5f+a_button.width*0.5f,
                         -a_hcam*0.5f+a_button.height*0.5f+a_button.height,
                         z_infos_back_menu());
}
#endif

///////////////////////////////////////////////////////////////////////////////////
/// sg : //////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

inline void rep_rings(inlib::sg::group& a_parent,
                      float a_back_sz,
                      unsigned int a_nring,
                      float a_wring,
                      const std::vector<inlib::colorf>& a_cols,
                      unsigned int a_num_center,
                      float a_hchar,
                      bool a_is_wall_screen_app) {

  if(a_back_sz) { //back :
    inlib::sg::separator* _sep = new inlib::sg::separator;
    a_parent.add(_sep);
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = inlib::colorf::white();
    _sep->add(mat);
    inlib::sg::matrix* m = new inlib::sg::matrix;
    m->set_translate(0,0,z_back());
    _sep->add(m);
    inlib::sg::cube* node = new inlib::sg::cube();
    node->width = a_back_sz;
    node->height = a_back_sz;
    node->depth = 0.01f;
    _sep->add(node);
  }

  typedef std::pair<float,float> rmn_mx;
  std::vector<rmn_mx> rmn_mxs(a_nring);
 {for(unsigned int i=0;i<a_nring;i++) rmn_mxs[i] = rmn_mx(i*a_wring,(i+1)*a_wring);}

  ////////////////////////////////////////////
  /// rings : ////////////////////////////////
  ////////////////////////////////////////////

 {for(unsigned int i=0;i<a_nring;i++) {
    inlib::sg::separator* _sep = new inlib::sg::separator;
    a_parent.add(_sep);
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = a_cols[i];
    _sep->add(mat);

    inlib::sg::matrix* m = new inlib::sg::matrix;
    m->set_translate(0,0,z_rings());
    _sep->add(m);

    inlib::sg::ring* node = new inlib::sg::ring();
    node->rmin = rmn_mxs[i].first;
    node->rmax = rmn_mxs[i].second;
    node->steps = steps();
    _sep->add(node);
  }}

  ///////////////////////////////////////////////
  /// inner "reduced" border : //////////////////
  ///////////////////////////////////////////////
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  a_parent.add(_sep);
  inlib::sg::rgba* mat = new inlib::sg::rgba();
  mat->color = inlib::colorf::black();
  _sep->add(mat);
  inlib::sg::draw_style* ds = new inlib::sg::draw_style;
  ds->style = inlib::sg::draw_style::lines;
  ds->line_width = a_is_wall_screen_app?5:1;
  _sep->add(ds);
  inlib::sg::matrix* m = new inlib::sg::matrix;
  m->set_translate(0,0,z_borders());
  _sep->add(m);
  inlib::sg::circle* node = new inlib::sg::circle();
  node->radius = a_wring*0.5f;
  node->steps = steps();
  _sep->add(node);}

  ///////////////////////////////////////////////
  /// borders ( = outside circle of a ring) : ///
  ///////////////////////////////////////////////
 {for(unsigned int i=0;i<a_nring;i++) {
    inlib::sg::separator* _sep = new inlib::sg::separator;
    a_parent.add(_sep);
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    if((a_cols[i]==inlib::colorf::black()) &&
       (a_cols[i+1]==inlib::colorf::black()) ){
      mat->color = inlib::colorf::white();
    } else {
      mat->color = inlib::colorf::black();
    }
    _sep->add(mat);
    inlib::sg::draw_style* ds = new inlib::sg::draw_style;
    ds->style = inlib::sg::draw_style::lines;
    ds->line_width = a_is_wall_screen_app?5:1;
    _sep->add(ds);
    inlib::sg::matrix* m = new inlib::sg::matrix;
    m->set_translate(0,0,z_borders());
    _sep->add(m);
    inlib::sg::circle* node = new inlib::sg::circle();
    node->radius = rmn_mxs[i].second;
    node->steps = steps();
    _sep->add(node);
  }}

  ////////////////////////////////////////////
  /// numbers : //////////////////////////////
  ////////////////////////////////////////////
 {for(unsigned int i=0;i<a_nring;i++) {
    inlib::sg::separator* _sep = new inlib::sg::separator;
    a_parent.add(_sep);
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = inlib::colorf::lightgrey();
    _sep->add(mat);
    inlib::sg::matrix* m = new inlib::sg::matrix;
    float xnum = (rmn_mxs[i].first+rmn_mxs[i].second)*0.5f;
    m->set_translate(xnum,0,z_numbers());
    _sep->add(m);
    exlib::sg::text_freetype* node = new exlib::sg::text_freetype();
    node->font = inlib::sg::font_helvetica_ttf();
    node->front_face = inlib::sg::winding_cw;
    node->hjust = inlib::sg::center;
    node->vjust = inlib::sg::middle;
    node->height = a_hchar;
    std::string snum = inlib::to(a_num_center-i);
    node->strings.set_value(snum);
    _sep->add(node);
  }}

 {inlib::sg::group* _sep = &a_parent; //trailing sg.
  inlib::sg::rgba* mat = new inlib::sg::rgba();
  mat->color = inlib::colorf::black();
  _sep->add(mat);
  inlib::sg::draw_style* ds = new inlib::sg::draw_style;
  ds->style = inlib::sg::draw_style::lines;
  ds->line_width = a_is_wall_screen_app?5:1;
  _sep->add(ds);
  inlib::sg::vertices* node = new inlib::sg::vertices;
  node->mode = inlib::gl::lines(); //segments
  node->add(-1, 0,z_cross());
  node->add( 1, 0,z_cross());
  node->add( 0,-1,z_cross());
  node->add( 0, 1,z_cross());
  _sep->add(node);}

}

inline void rep_nature(std::ostream& a_out,
                       const std::string& a_res_dir,
                       inlib::sg::group& a_parent,
                       const std::string& a_file,double a_h,
                       bool a_is_wall_screen_app) {

  std::string path = a_res_dir;
  path += inlib::sep();
  path += a_file;

  unsigned int w,h,bpp;
  unsigned char* buffer = exlib::jpeg::read(a_out,path,w,h,bpp);
  if(!buffer) {
    a_out << "rep_nature :"
          << " can't read file."
          << std::endl;
    return;
  }
  if(bpp!=3) {
    a_out << "rep_natue :"
          << " bpp not 3."
          << std::endl;
    return;
  }

  inlib::sg::separator* _sep = new inlib::sg::separator;
  a_parent.add(_sep);

  //inlib::sg::matrix* mtx = new inlib::sg::matrix;
  //_sep->add(mtx);

  inlib::sg::rgba* mat = new inlib::sg::rgba();
  mat->color = inlib::colorf::white();
  _sep->add(mat);

  _sep->add(new inlib::sg::normal);

  inlib::sg::tex_rect* node = new inlib::sg::tex_rect();
  //tex_rect* node = new tex_rect(*mtx);
  node->img.value().set(w,h,bpp,buffer,true);
  node->height = a_h;
  node->expand = true;

  _sep->add(node);
}

inline inlib::sg::bcbk::return_action action_slider(inlib::sg::gui_viewer& a_gv,const inlib::sg::bcbk&,
                                                    inlib::sg::slider&,void* a_tag) {
  unsigned int m_action = *((unsigned int*)a_tag);

  dac* _dac = cast_dac(a_gv);
  if(!_dac) return inlib::sg::bcbk::return_none;

         if(m_action==0) { //begin : pass infos_text in outline.
    _dac->m_infos_text.modeling = inlib::sg::font_outline;

  } else if(m_action==2) { //end : pass infos_text in outline.
    _dac->m_infos_text.modeling = inlib::sg::font_filled;

  } else if(m_action==1) { //distance cible
    inlib::sg::slider& _slider = a_gv.slider_3();

    params& _params = _dac->m_parameters;

    double dv = _params.m_slider_dist_max-_params.m_slider_dist_min;
    double v = _params.m_slider_dist_min+dv*_slider.value.value();
    _params.m_dCible = v;

    double scope_proj_diam; //in meter
    if(!scope_proj(_params.m_diamScope,
                   _params.m_dsoe,
                   _params.m_dCible,
                   _params.m_dioptrie,scope_proj_diam)||
      (scope_proj_diam<=0)){
      return inlib::sg::bcbk::return_to_render;
    }
    scope_proj_diam *= 100; //now in cm.

    double pastille_proj_diam; //in meter
    if(!scope_proj(_params.m_diamPastille,
                   _params.m_dsoe,
                   _params.m_dCible,
                   _params.m_dioptrie,pastille_proj_diam)||
      (pastille_proj_diam<=0)){
      return inlib::sg::bcbk::return_to_render;
    }
    pastille_proj_diam *= 100; //now in cm.

   {std::string s;
    inlib::sprintf(s,128,"%.1f m  %.1f cm",_params.m_dCible,scope_proj_diam);
    _dac->m_infos_text.strings.set_value(s);}
      
    float scope_radius = 0.5f*float(scope_proj_diam);
    float pastille_radius = 0.5f*float(pastille_proj_diam);

    float scope_rmx = 1.025f*scope_radius;
    _dac->m_scope.rmin = scope_radius;
    _dac->m_scope.rmax = scope_rmx;

    _dac->m_cache.rmin = scope_rmx;
    _dac->m_cache.rmax = 10*scope_rmx;

    _dac->m_pastille.rmin = pastille_radius*0.001f;
    _dac->m_pastille.rmax = pastille_radius;

   {unsigned int ww = a_gv.width();
    unsigned int wh = a_gv.height();
    float hcam = 2;
    float wcam = hcam*float(ww)/float(wh);
    adjust_tscp_matrix(_dac->m_tscp_matrix,wcam,hcam,scope_radius);}

    _dac->m_parameters.m_scope_radius = scope_radius;

  }

  return inlib::sg::bcbk::return_to_render;
}

inline inlib::sg::bcbk::return_action action_adjust_scope(inlib::sg::gui_viewer& a_gv,const inlib::sg::ecbk& a_cbk,
                                                          inlib::sg::event_dispatcher&,void*) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return inlib::sg::bcbk::return_none;

  if(const inlib::sg::size_event* sz_evt = inlib::safe_cast<inlib::sg::event,inlib::sg::size_event>(a_cbk.event_ref())){
    unsigned int ww = sz_evt->width();
    unsigned int wh = sz_evt->height();
    float hcam = 2;
    float wcam = hcam*float(ww)/float(wh);
    adjust_infos(_dac->m_infos_text,_dac->m_infos_matrix,wcam,hcam);
    adjust_back_to_menu(_dac->m_back_to_menu_button,_dac->m_back_to_menu_matrix,wcam,hcam);
#ifdef CURSOR_BUTTON
    adjust_cursor_button(_dac->m_cursor_button,_dac->m_cursor_button_matrix,wcam,hcam);
#endif
    adjust_tscp_matrix(_dac->m_tscp_matrix,wcam,hcam,_dac->m_parameters.m_scope_radius);
    a_cbk.event_action_ref().set_done(true);

#ifdef CURSOR_BUTTON
  } else if(const inlib::sg::up_event* up_evt = inlib::safe_cast<inlib::sg::event,inlib::sg::up_event>(a_cbk.event_ref())){
    if(_dac->m_cursor_switch.which.value()==inlib::sg::gui_viewer::SHOWN()) {
      _dac->m_cursor_switch.which = inlib::sg::gui_viewer::HIDDEN();
      _dac->m_scope_ghost.set_active(true);
    } else {
      _dac->m_cursor_switch.which = inlib::sg::gui_viewer::SHOWN();
      _dac->m_scope_ghost.set_active(false);
    }
#endif
  }

  return inlib::sg::bcbk::return_to_render;
}

inline void* action_begin()  {static unsigned int s_v = 0;return &s_v;}
inline void* action_drag()   {static unsigned int s_v = 1;return &s_v;}
inline void* action_end()    {static unsigned int s_v = 2;return &s_v;}

#ifdef CURSOR_BUTTON
inline void create_cursor_sg(inlib::sg::gui_viewer& a_gv,inlib::sg::separator& a_parent) {
  a_parent.clear();

  dac* _dac = cast_dac(a_gv);
  if(!_dac) return;

  a_parent.add(new inlib::sg::noderef(_dac->m_cursor_switch));
  _dac->m_cursor_switch.clear();
  inlib::sg::separator* sep = new inlib::sg::separator;
  _dac->m_cursor_switch.add(sep);
  _dac->m_cursor_switch.add(new inlib::sg::separator());
  _dac->m_cursor_switch.which = inlib::sg::gui_viewer::HIDDEN();

  float cam_height = 2;
  inlib::sg::base_camera* camera = a_gv.create_2D_camera(cam_height);
  //a_parent_camera = camera;
  sep->add(camera);

  inlib::sg::matrix* move_matrix = new inlib::sg::matrix;
  sep->add(move_matrix);

  inlib::sg::matrix* _matrix = new inlib::sg::matrix;
  _matrix->set_translate(0,0,z_cursor_ghost());
  sep->add(_matrix);

  ghost* _ghost = new ghost(*move_matrix,30);
  // size set below.
  sep->add(_ghost);

  inlib::sg::rgba* mat = new inlib::sg::rgba();
  mat->color = inlib::colorf::grey();
  sep->add(mat);

  inlib::sg::draw_style* ds = new inlib::sg::draw_style;
  ds->style = inlib::sg::draw_style::lines;
  ds->line_width = 2;
  sep->add(ds);

  inlib::sg::vertices* vtcs = new inlib::sg::vertices;
  vtcs->mode = inlib::gl::lines();
  sep->add(vtcs);

 {float size = 0.2f;
  vtcs->add(-size, size,0);
  vtcs->add( size,-size,0);

  vtcs->add(-size,-size,0);
  vtcs->add( size, size,0);

  float gsz = 2.0F*size/inlib::fsqrt(2.0F);
  _ghost->width = gsz;
  _ghost->height = gsz;}

}
#endif

inline void create_scope_sg(inlib::sg::gui_viewer& a_gv,
                            unsigned int a_blason_id,
                            double a_diamScope,      //in meter
                            double a_dsoe,           //in meter
                            double a_dCible,         //in meter
                            double a_dioptrie,       //in 1/meter
                            double a_diamPastille,   //in meter
                            double a_slider_dist_min,
                            double a_slider_dist_max){
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return;

  double scope_proj_diam; //in meter
  if(!scope_proj(a_diamScope,
                 a_dsoe,a_dCible,a_dioptrie,
                 scope_proj_diam)||
     (scope_proj_diam<=0)){
    a_gv.map_warn("bad parameter");
    return;
  }
  scope_proj_diam *= 100; //now in cm.

  double pastille_proj_diam; //in meter
  if(!scope_proj(a_diamPastille,
                 a_dsoe,a_dCible,a_dioptrie,
                 pastille_proj_diam)||
     (pastille_proj_diam<=0)) {
    a_gv.map_warn("bad parameter");
    return;
  }
  pastille_proj_diam *= 100; //now in cm.

  float scope_radius = 0.5f*float(scope_proj_diam);
  float pastille_radius = 0.5f*float(pastille_proj_diam);

  a_gv.clear_scene(); //it will do a scene().clear_cbks().

  unsigned int ww = a_gv.width();
  unsigned int wh = a_gv.height();

  inlib::sg::separator& scene_sep = a_gv.scene();

#ifdef CURSOR_BUTTON
  inlib::sg::separator* cursor_sep = new inlib::sg::separator;
  scene_sep.add(cursor_sep);
  create_cursor_sg(a_gv,*cursor_sep);
#endif

  inlib::sg::separator* scope_sep = new inlib::sg::separator;
  scene_sep.add(scope_sep);
  inlib::sg::separator& sep = *scope_sep;

  //for Android device rotation.
  _dac->m_dpt = inlib::sg::event_dispatcher(); //to reset fields.
  _dac->m_dpt.add_callback(new inlib::sg::funtag_ecbk<inlib::sg::event_dispatcher>(a_gv,_dac->m_dpt,action_adjust_scope,0));
  sep.add(new inlib::sg::noderef(_dac->m_dpt));

  //NOTE : the logic is arranged to keep camera height to 2
  //       and to adjust the tscp_matrix so that scope rmax
  //       map window height (or width according window aspect
  //       ratio).
  float hcam = 2;
  inlib::sg::base_camera* camera = a_gv.create_2D_camera(hcam);
  sep.add(camera);

  float wcam = hcam*float(ww)/float(wh);

  inlib::sg::head_light* light = new inlib::sg::head_light;
  light->direction = inlib::vec3f(1,-1,-10);
  sep.add(light);

  ////////////////////////////////////////////
  /// sumup : ////////////////////////////////
  ////////////////////////////////////////////
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  sep.add(_sep);

  _sep->add(new inlib::sg::noderef(_dac->m_infos_matrix));

  inlib::sg::rgba* mat = new inlib::sg::rgba();
  mat->color = inlib::colorf::black();
  _sep->add(mat);

  _dac->m_infos_text = exlib::sg::text_freetype(); //to reset fields.
  _dac->m_infos_text.modeling = inlib::sg::font_filled;
  _dac->m_infos_text.font = inlib::sg::font_arialbd_ttf();
  _dac->m_infos_text.front_face = inlib::sg::winding_cw;
  _dac->m_infos_text.hjust = inlib::sg::left;
  _dac->m_infos_text.vjust = inlib::sg::top;

 {std::string s;
  inlib::sprintf(s,128,"%.1f m  %.1f cm",a_dCible,scope_proj_diam);
  _dac->m_infos_text.strings.set_value(s);}

  adjust_infos(_dac->m_infos_text,_dac->m_infos_matrix,wcam,hcam);

  _sep->add(new inlib::sg::noderef(_dac->m_infos_text));}

  ////////////////////////////////////////////
  /// back to menu button : //////////////////
  ////////////////////////////////////////////
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  sep.add(_sep);
  _sep->add(new inlib::sg::noderef(_dac->m_back_to_menu_matrix));
  _dac->m_back_to_menu_button = inlib::sg::image_button(); //to reset fields.
  if(!a_gv.set_img_from_file(a_gv.out(),a_gv.res_dir(),"beos_menu.jpg",_dac->m_back_to_menu_button.img.value())) {}
  _dac->m_back_to_menu_button.img.touch();
  adjust_back_to_menu(_dac->m_back_to_menu_button,_dac->m_back_to_menu_matrix,wcam,hcam);
  _sep->add(new inlib::sg::noderef(_dac->m_back_to_menu_button));}

  ////////////////////////////////////////////
  /// cursor button : ////////////////////////
  ////////////////////////////////////////////
#ifdef CURSOR_BUTTON
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  sep.add(_sep);
  _sep->add(new inlib::sg::noderef(_dac->m_cursor_button_matrix));
  _dac->m_cursor_button = inlib::sg::image_button(); //to reset fields.
  if(!a_gv.set_img_from_file(a_gv.out(),a_gv.res_dir(),"beos_menu.jpg",_dac->m_cursor_button.img.value())) {}
  _dac->m_cursor_button.img.touch();
  adjust_cursor_button(_dac->m_cursor_button,_dac->m_cursor_button_matrix,wcam,hcam);
  _sep->add(new inlib::sg::noderef(_dac->m_cursor_button));}
#endif
  ////////////////////////////////////////////////////////
  /// target+scope+cache+pastille ////////////////////////
  ////////////////////////////////////////////////////////
   
  adjust_tscp_matrix(_dac->m_tscp_matrix,wcam,hcam,scope_radius);
  sep.add(new inlib::sg::noderef(_dac->m_tscp_matrix));

  ////////////////////////////////////////////////////////
  /// target : ///////////////////////////////////////////
  ////////////////////////////////////////////////////////

  inlib::sg::separator* target_sep = new inlib::sg::separator;
  sep.add(target_sep);

  _dac->m_scope_ghost_matrix = inlib::sg::matrix();
  target_sep->add(new inlib::sg::noderef(_dac->m_scope_ghost_matrix));

  bool do_render_mem = true; //OPTIMIZATION

  inlib::sg::matrix* ghost_matrix = 0;

 {inlib::sg::separator* _sep = new inlib::sg::separator;
  target_sep->add(_sep);
  ghost_matrix = new inlib::sg::matrix;
  ghost_matrix->set_translate(0,0,z_ghost());
  _sep->add(ghost_matrix);
  _dac->m_scope_ghost = ghost(_dac->m_scope_ghost_matrix,3.0F);
  // size set after having built the target.
  _sep->add(new inlib::sg::noderef(_dac->m_scope_ghost));}

  float wta = 0;
  float hta = 0;
  float xta = 0;
  float yta = 0;

  inlib::sg::group* target_grp = new inlib::sg::group;

 {std::vector<inlib::colorf> cols;
  cols.push_back(inlib::colorf::yellow());
  cols.push_back(inlib::colorf::yellow());
  cols.push_back(inlib::colorf::red());
  cols.push_back(inlib::colorf::red());
  cols.push_back(inlib::colorf::cornflowerblue());
  cols.push_back(inlib::colorf::cornflowerblue());
  cols.push_back(inlib::colorf::black());
  cols.push_back(inlib::colorf::black());
  cols.push_back(inlib::colorf::white());
  cols.push_back(inlib::colorf::white());
  cols.push_back(inlib::colorf::white()); //10+1

  std::vector<inlib::colorf> camps;
  camps.push_back(inlib::colorf::yellow());
  camps.push_back(inlib::colorf::yellow());
  camps.push_back(inlib::colorf::black());
  camps.push_back(inlib::colorf::black());
  camps.push_back(inlib::colorf::black());
  camps.push_back(inlib::colorf::black());
  camps.push_back(inlib::colorf::black()); //6+1
  
  /////////////////////////////////////////////////////////////////////////
  /// indoor : ////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////
         if(a_blason_id==blason_indoor_80()) {
    rep_rings(*target_grp,82,10,4,cols,10,2.5f,a_gv.is_wall_screen_app());
    wta = hta = 82;

  } else if(a_blason_id==blason_indoor_60()) {
    rep_rings(*target_grp,62,10,3,cols,10,2,a_gv.is_wall_screen_app());
    wta = hta = 62;

  } else if(a_blason_id==blason_indoor_40()) {
    rep_rings(*target_grp,42,10,2,cols,10,1.5f,a_gv.is_wall_screen_app());
    wta = hta = 42;

  } else if(a_blason_id==blason_indoor_40_31()) {
    float ys[3] = {-(11+0+11),0,11+0+11};

    for(unsigned int index=0;index<3;index++) {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      target_grp->add(_sep);
      inlib::sg::matrix* m = new inlib::sg::matrix;
      m->set_translate(0,ys[index],0);
      _sep->add(m);
      rep_rings(*_sep,22,5,2,cols,10,1.5f,a_gv.is_wall_screen_app());
    }
    wta = 22;
    hta = 3*22;

  /////////////////////////////////////////////////////////////////////////
  /// outdoor : ///////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////
  } else if(a_blason_id==blason_outdoor_122()) {
    rep_rings(*target_grp,123,10,6.1F,cols,10,3.5f,a_gv.is_wall_screen_app());

    wta = hta = 123;

  } else if(a_blason_id==blason_outdoor_80()) {
    rep_rings(*target_grp,82,10,4,cols,10,2.5f,a_gv.is_wall_screen_app());
    wta = hta = 82;

  } else if(a_blason_id==blason_outdoor_80_22()) {

    float space = 5.0F; //cm
    float dd = space*0.5F+24;

    float center_x =  dd;
    float center_y = -dd;
    xta = center_x;
    yta = center_y;

    // 2 3
    // 0 1
    float xs[4] = {-dd, dd,-dd,dd};
    float ys[4] = {-dd,-dd, dd,dd};

    for(unsigned int index=0;index<4;index++) {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      target_grp->add(_sep);
      inlib::sg::matrix* m = new inlib::sg::matrix;
      m->set_translate(center_x+xs[index],center_y+ys[index],0);
      _sep->add(m);
      rep_rings(*_sep,48,6,4,cols,10,2.5f,a_gv.is_wall_screen_app());
    }
    wta = 48+space+48;
    hta = 48+space+48;

  /////////////////////////////////////////////////////////////////////////
  /// field : /////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////
  } else if(a_blason_id==blason_field_80()) {
    rep_rings(*target_grp,0,6,8,camps,6,5,a_gv.is_wall_screen_app());
    wta = 6*8*2;
    hta = 6*8*2;

  } else if(a_blason_id==blason_field_60()) {
    rep_rings(*target_grp,0,6,6,camps,6,4,a_gv.is_wall_screen_app());
    wta = 6*6*2;
    hta = 6*6*2;

  } else if(a_blason_id==blason_field_40_22()) {

    float rad = 12; //cm
    float space = 0; //cm
    float hsp = space*0.5F; //cm
 
    float center_x =  rad+hsp;
    float center_y = -rad-hsp;
    xta = center_x;
    yta = center_y;

    // 2 3
    // 0 1
    float xs[4] = {-rad-hsp, rad+hsp,
                   -rad-hsp, rad+hsp};
    float ys[4] = {-rad-hsp,-rad-hsp,
                    rad+hsp, rad+hsp};

    for(unsigned int index=0;index<4;index++) {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      target_grp->add(_sep);
      inlib::sg::matrix* m = new inlib::sg::matrix;
      m->set_translate(center_x+xs[index],center_y+ys[index],0);
      _sep->add(m);
      rep_rings(*_sep,0,6,2,camps,6,2,a_gv.is_wall_screen_app());
    }
    wta = rad*2+space+rad*2;
    hta = rad*2+space+rad*2;

  } else if(a_blason_id==blason_field_20_34()) {

    float rad = 6; //cm
    float space = 0; //cm
    float hsp = space*0.5F; //cm

    float center_x = rad+hsp;
    float center_y =   0;
    xta = center_x;
    yta = center_y;

    // 8  9 10 11
    // 4  5  6  7
    // 0  1  2  3
    float xs[12] = {
             -(rad+hsp+space+2*rad),-(rad+hsp),rad+hsp,rad+hsp+space+2*rad,
             -(rad+hsp+space+2*rad),-(rad+hsp),rad+hsp,rad+hsp+space+2*rad,
             -(rad+hsp+space+2*rad),-(rad+hsp),rad+hsp,rad+hsp+space+2*rad};
    float ys[12] = {
             -rad-space-rad,-rad-space-rad,-rad-space-rad,-rad-space-rad,
                          0,             0,             0,             0,
              rad+space+rad, rad+space+rad, rad+space+rad, rad+space+rad};

    for(unsigned int index=0;index<12;index++) {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      target_grp->add(_sep);
      inlib::sg::matrix* m = new inlib::sg::matrix;
      m->set_translate(center_x+xs[index],center_y+ys[index],0);
      _sep->add(m);
      rep_rings(*_sep,0,6,1,camps,6,1,a_gv.is_wall_screen_app());
    }

    wta = rad*2+space+rad*2+space+rad*2+space+rad*2;
    hta = rad*2+space+rad*2+space+rad*2;

  /////////////////////////////////////////////////////////////////////////
  /// nature : ////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////
  } else if( (a_blason_id==blason_nature_hippopotame()) ||
             (a_blason_id==blason_nature_chameau())    ||
             (a_blason_id==blason_nature_daim()) ||
             (a_blason_id==blason_nature_loupgris()) ||
             (a_blason_id==blason_nature_canardmandarin()) ||
             (a_blason_id==blason_nature_lapin()) ||
             (a_blason_id==blason_nature_paon()) ||
             (a_blason_id==blason_nature_pandaroux()) ){
     do_render_mem = false;
 
    std::string image;
   {std::map<unsigned int,std::string>::const_iterator it = nature_images().find(a_blason_id);
    if(it!=nature_images().end()) {
      image = (*it).second;
    } else {
    }}

    double h;
   {std::map<unsigned int,double>::const_iterator it = nature_heights().find(a_blason_id);
    if(it!=nature_heights().end()) h = (*it).second;}

    if(image.size()) {
      rep_nature(a_gv.out(),a_gv.res_dir(),*target_grp,image,h,a_gv.is_wall_screen_app());
    }
    wta = h; //should use img aspect ratio.
    hta = h;

  } else {
    // unknown blason.
    delete target_grp;
    sep.clear();
    a_gv.map_warn("unknown target kind.");
    return;
 
  }} // blason kind

  if(do_render_mem) {
    inlib::sg::atb_vertices* pts = new inlib::sg::atb_vertices;
    inlib::sg::atb_vertices* lns = new inlib::sg::atb_vertices;
    inlib::sg::atb_vertices* trs = new inlib::sg::atb_vertices;
    inlib::sg::render_mem action(a_gv.out(),*pts,*lns,*trs);
    target_grp->render(action);
/*
    std::string s;
    s += inlib::to(pts->number())+" points.";
    s += " "+inlib::to(lns->number()/2)+" lines.";
    s += " "+inlib::to(trs->number()/3)+" triangles.";
    a_gv.out() << s << std::endl;
*/  
    target_sep->add(pts);
    target_sep->add(lns);
    target_sep->add(trs);

    delete target_grp;
  } else {
    target_sep->add(target_grp);
  }

  _dac->m_scope_ghost.width = wta;
  _dac->m_scope_ghost.height = hta;
  ghost_matrix->set_translate(xta,yta,z_ghost());

  ////////////////////////////////////////////
  /// scope : ////////////////////////////////
  ////////////////////////////////////////////
  float scope_rmx = 1.025f*scope_radius;
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  sep.add(_sep);
  inlib::sg::rgba* mat = new inlib::sg::rgba();
  mat->color = inlib::colorf::grey();
  _sep->add(mat);
  inlib::sg::matrix* m = new inlib::sg::matrix;
  m->set_translate(0,0,z_scope_cache_pastille());
  _sep->add(m);
  _dac->m_scope.rmin = scope_radius;
  _dac->m_scope.rmax = scope_rmx;
  _dac->m_scope.steps = steps();
  _sep->add(new inlib::sg::noderef(_dac->m_scope));}

  ////////////////////////////////////////////
  /// cache : ////////////////////////////////
  ////////////////////////////////////////////
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  sep.add(_sep);
  inlib::sg::rgba* mat = new inlib::sg::rgba();
  mat->color = inlib::colorf(1,1,1,0.8f);
  _sep->add(mat);
  inlib::sg::matrix* m = new inlib::sg::matrix;
  m->set_translate(0,0,z_scope_cache_pastille());
  _sep->add(m);
  _dac->m_cache.rmin = scope_rmx;
  _dac->m_cache.rmax = 10*scope_rmx;
  _dac->m_cache.steps = steps();
  _sep->add(new inlib::sg::noderef(_dac->m_cache));}

  ////////////////////////////////////////////
  /// pastille : /////////////////////////////
  ////////////////////////////////////////////
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  sep.add(_sep);
  inlib::sg::rgba* mat = new inlib::sg::rgba();
  mat->color = inlib::colorf::grey();
  _sep->add(mat);
  inlib::sg::matrix* m = new inlib::sg::matrix;
  m->set_translate(0,0,z_scope_cache_pastille());
  _sep->add(m);
  _dac->m_pastille.rmin = pastille_radius*0.001f;
  _dac->m_pastille.rmax = pastille_radius;
  _dac->m_pastille.steps = steps();
  _sep->add(new inlib::sg::noderef(_dac->m_pastille));}

  ////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////

  _dac->m_parameters.m_scope_radius = scope_radius;

  a_gv.set_scene_camera(camera);
  a_gv.set_scene_light(light);

  a_gv.hide_main_menu();

  ////////////////////////////////
  /// sliders : //////////////////
  ////////////////////////////////
 {a_gv.set_sliders_pos(inlib::sg::gui_params::s_sliders_l());

  params& prms = _dac->m_parameters;
  prms.m_diamScope = a_diamScope;
  prms.m_dsoe = a_dsoe;
  prms.m_dCible = a_dCible;
  prms.m_dioptrie = a_dioptrie;
  prms.m_diamPastille = a_diamPastille;
  prms.m_slider_dist_min = a_slider_dist_min;
  prms.m_slider_dist_max = a_slider_dist_max;

  //vertical slider : distance :
 {inlib::sg::slider& sld = a_gv.slider_3();
  sld.value = (a_dCible-a_slider_dist_min)/(a_slider_dist_max-a_slider_dist_min);
  sld.clear_cbks();
  sld.add_begin_callback(new inlib::sg::funtag_cbk<inlib::sg::slider>(a_gv,sld,action_slider,action_begin()));
  sld.add_drag_callback(new inlib::sg::funtag_cbk<inlib::sg::slider>(a_gv,sld,action_slider,action_drag()));
  sld.add_end_callback(new inlib::sg::funtag_cbk<inlib::sg::slider>(a_gv,sld,action_slider,action_end()));
  }

  a_gv.show_sliders();}

}

///////////////////////////////////////////////////////////////////////////////////
/// sight charts : ////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

inline void adjust_sight_chart_matrix(inlib::sg::matrix& a_mtx,float a_wcam,float a_hcam,float a_wruler,float a_hruler) {
  //float scale = (a_wcam*0.75F)/a_wruler;
  float scale = (a_hcam*0.9F)/a_hruler;
  a_mtx.set_scale(scale,scale,1);
}

inline inlib::sg::bcbk::return_action action_adjust_sight_chart(inlib::sg::gui_viewer& a_gv,const inlib::sg::ecbk& a_cbk,
                                                                inlib::sg::event_dispatcher&,void*) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return inlib::sg::bcbk::return_none;

  if(const inlib::sg::size_event* sz_evt = inlib::safe_cast<inlib::sg::event,inlib::sg::size_event>(a_cbk.event_ref())){
    unsigned int ww = sz_evt->width();
    unsigned int wh = sz_evt->height();
    // the two below lines must be consistent with the ones in create_ruler_sg() :
    float hcam = 2;
    float wcam = hcam*float(ww)/float(wh);

    inlib::sg::base_camera* camera = a_gv.create_2D_camera(hcam);
    _dac->m_sight_chart_camera_container.clear();
    _dac->m_sight_chart_camera_container.add(camera);
    a_gv.set_scene_camera(camera);

    adjust_back_to_menu(_dac->m_back_to_menu_button,_dac->m_back_to_menu_matrix,wcam,hcam);
#ifdef CURSOR_BUTTON
    adjust_cursor_button(_dac->m_cursor_button,_dac->m_cursor_button_matrix,wcam,hcam);
#endif
    adjust_sight_chart_matrix(_dac->m_sight_chart_matrix,wcam,hcam,_dac->m_parameters.m_wruler,_dac->m_parameters.m_hruler);
    a_cbk.event_action_ref().set_done(true);
  }

  return inlib::sg::bcbk::return_to_render;
}

inline void create_ruler_sg(inlib::sg::gui_viewer& a_gv,const std::vector< std::pair<double,double> >& a_ticks,
                            const std::string& a_title_left = "",const std::string& a_title_right = "") {
  typedef std::pair<double,double> item_t;

  dac* _dac = cast_dac(a_gv);
  if(!_dac) return;

  a_gv.clear_scene(); //it will do a scene().clear_cbks().

  unsigned int ww = a_gv.width();
  unsigned int wh = a_gv.height();

  inlib::sg::separator& sep = a_gv.scene();

  //for Android device rotation.
  _dac->m_sight_chart_dpt = inlib::sg::event_dispatcher(); //to reset fields.
  _dac->m_sight_chart_dpt.add_callback
     (new inlib::sg::funtag_ecbk<inlib::sg::event_dispatcher>(a_gv,_dac->m_sight_chart_dpt,action_adjust_sight_chart,0));
  sep.add(new inlib::sg::noderef(_dac->m_sight_chart_dpt));

  // we assume window is higher than larger.
  //float wcam = 2;
  //float hcam = wcam*float(wh)/float(ww);
  float hcam = 2;
  float wcam = hcam*float(ww)/float(wh);

  sep.add(new inlib::sg::noderef(_dac->m_sight_chart_camera_container));
  inlib::sg::base_camera* camera = a_gv.create_2D_camera(hcam);
  _dac->m_sight_chart_camera_container.clear();
  _dac->m_sight_chart_camera_container.add(camera);

  inlib::sg::head_light* light = new inlib::sg::head_light;
  light->direction = inlib::vec3f(1,-1,-10);
  sep.add(light);

  ////////////////////////////////////////////
  /// back to menu button : //////////////////
  ////////////////////////////////////////////
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  sep.add(_sep);
  _sep->add(new inlib::sg::noderef(_dac->m_back_to_menu_matrix));
  _dac->m_back_to_menu_button = inlib::sg::image_button(); //to reset fields.
  if(!a_gv.set_img_from_file(a_gv.out(),a_gv.res_dir(),"beos_menu.jpg",_dac->m_back_to_menu_button.img.value())) {}
  _dac->m_back_to_menu_button.img.touch();
  adjust_back_to_menu(_dac->m_back_to_menu_button,_dac->m_back_to_menu_matrix,wcam,hcam);
  _sep->add(new inlib::sg::noderef(_dac->m_back_to_menu_button));}

  ////////////////////////////////////////////
  /// ruler : ////////////////////////////////
  ////////////////////////////////////////////

  int ntick = (int)a_ticks.size();
  unsigned int ncase = ntick-1;

  float dist_axes = 0.1F;
  float wruler = 3*dist_axes;
  float hruler = ncase*dist_axes;
  _dac->m_parameters.m_wruler = wruler;
  _dac->m_parameters.m_hruler = hruler;
  float wghost = wruler;
  float hghost = hruler;
  float hcase = hruler/ncase;
  float yshift = 0;
/*
  if(a_title_left.size()||a_title_right.size()) {
    yshift = -hruler*0.5F;
  } else {
    yshift = -hruler*0.5F+hcase;
  }
*/
  unsigned int ndiv = ncase+10*100; //10 sub ticks
  //unsigned int ndiv = ncase+5*100; //5 sub ticks

/*
  inlib::sg::matrix* ghost_matrix = new inlib::sg::matrix;
  ghost_matrix->set_translate(0,0,z_ghost());
  sep.add(ghost_matrix);
*/

  inlib::sg::separator* axes_sep = new inlib::sg::separator;
  sep.add(axes_sep);

  _dac->m_sight_chart_matrix = inlib::sg::matrix();
  adjust_sight_chart_matrix(_dac->m_sight_chart_matrix,wcam,hcam,wruler,hruler);
  axes_sep->add(new inlib::sg::noderef(_dac->m_sight_chart_matrix));

 {inlib::sg::matrix* _matrix = new inlib::sg::matrix;
  _matrix->mul_translate(0,yshift,0);
  axes_sep->add(_matrix);}

/*
  ghost* _ghost = new ghost(*ghost_matrix);
  _ghost->width = wghost;
  _ghost->height = hghost;
  axes_sep->add(_ghost);
*/

  ///////////////////////////////////////////////////
  /// first axis : //////////////////////////////////
  ///////////////////////////////////////////////////
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  axes_sep->add(_sep);

  inlib::sg::matrix* m = new inlib::sg::matrix;
  m->mul_translate(-dist_axes*0.5F,-hruler*0.5F,0);
  m->mul_rotate(0,1,0,inlib::fpi());
  m->mul_rotate(0,0,1,inlib::fhalf_pi());
  _sep->add(m);

  inlib::sg::axis* _axis = new inlib::sg::axis(a_gv.ttf());
  _axis->width = hruler;
//#define ARCHERYTUNE_AXIS_MODELING_NONE
#ifdef ARCHERYTUNE_AXIS_MODELING_NONE
  _axis->modeling = inlib::sg::tick_modeling_none();
#else
  _axis->modeling = inlib::sg::tick_modeling_hplot();
  _axis->divisions = ndiv;
  _axis->minimum_value = inlib::mn(a_ticks.front().first,a_ticks.back().first);
  _axis->maximum_value = inlib::mx(a_ticks.front().first,a_ticks.back().first);
  _axis->labels_enforced = true;
#endif
  _axis->tick_length = dist_axes*0.5F;

  // similar layout as y axis for 2D in sg::plotter :
  _axis->tick_up = true;
  _axis->labels_style().font = inlib::sg::font_arialbd_ttf();
  _axis->labels_style().scale = 1.5F;
  _axis->labels_style().x_orientation = inlib::vec3f(0,1,0);
  _axis->labels_style().y_orientation = inlib::vec3f(1,0,0);
  _axis->labels_style().hjust = inlib::sg::right;
  _axis->labels_style().vjust = inlib::sg::middle;
  _axis->labels_style().translation = inlib::vec3f(hcase*0.05F,0,0); //cooking.

 {unsigned int index = 0;
  inlib_vforcit(item_t,a_ticks,it) {
    double value = (*it).first;
    std::string _v;
    inlib::sprintf(_v,128,"%.1f",value);
    _axis->labels.add(_v);
#ifdef ARCHERYTUNE_AXIS_MODELING_NONE
    _axis->values.add(value);
    _axis->coords.add(0+hcase*index);
#endif
    index++;
  }}

#ifdef ARCHERYTUNE_AXIS_MODELING_NONE
  _axis->tick_number = _axis->labels.size();
  _axis->minimum_value = _axis->values.values()[0];
  _axis->maximum_value = _axis->values.values()[_axis->tick_number.value()-1];
#endif

  if(a_title_left.size()) {
    _axis->title = a_title_left;
    _axis->title_style().font = inlib::sg::font_arialbd_ttf();
    _axis->title_style().scale = 1.5F;
    _axis->title_style().x_orientation = inlib::vec3f(0,1,0);
    _axis->title_style().y_orientation = inlib::vec3f(1,0,0);
    _axis->title_style().hjust = inlib::sg::center;
    _axis->title_style().vjust = inlib::sg::bottom;
    //_axis->title_style().translation = inlib::vec3f(hcase*0.5F,0,0);
    _axis->title_style().translation = inlib::vec3f(hcase*0.25F,0,0);
  }

  _sep->add(_axis);}

  ///////////////////////////////////////////////////
  /// second axis : /////////////////////////////////
  ///////////////////////////////////////////////////
 {inlib::sg::separator* _sep = new inlib::sg::separator;
  axes_sep->add(_sep);

  inlib::sg::matrix* m = new inlib::sg::matrix;
  m->mul_translate(dist_axes*0.5F,-hruler*0.5F,0);
  m->mul_rotate(0,0,1,inlib::fhalf_pi());
  _sep->add(m);

  inlib::sg::axis* _axis = new inlib::sg::axis(a_gv.ttf());
  _axis->width = hruler;
#ifdef ARCHERYTUNE_AXIS_MODELING_NONE
  _axis->modeling = inlib::sg::modeling_none();
#else
  _axis->modeling = inlib::sg::tick_modeling_hplot();
  _axis->divisions = ndiv;
  //[min,max]imum_value same as first/left axis.
  _axis->minimum_value = inlib::mn(a_ticks.front().first,a_ticks.back().first);
  _axis->maximum_value = inlib::mx(a_ticks.front().first,a_ticks.back().first);
  _axis->labels_enforced = true;
#endif
  _axis->tick_length = dist_axes*0.5F;

  // similar layout as cmap axis for 2D in sg::plotter :
  _axis->tick_up = true;
  _axis->labels_style().font = inlib::sg::font_arialbd_ttf();
  _axis->labels_style().scale = 1.5F;
  _axis->labels_style().x_orientation = inlib::vec3f(0,-1,0);
  _axis->labels_style().y_orientation = inlib::vec3f(1,0,0);
  _axis->labels_style().hjust = inlib::sg::left;
  _axis->labels_style().vjust = inlib::sg::middle;
  _axis->labels_style().translation = inlib::vec3f(hcase*0.05F,0,0); //cooking.

 {unsigned int index = 0;
  inlib_vforcit(item_t,a_ticks,it) {
    double value = (*it).second;
    std::string _v;
    inlib::sprintf(_v,128,"%.1f",value);
    _axis->labels.add(_v);
#ifdef ARCHERYTUNE_AXIS_MODELING_NONE
    _axis->values.add(value);
    _axis->coords.add(0+hcase*index);
#endif
    index++;
  }}

#ifdef ARCHERYTUNE_AXIS_MODELING_NONE
  _axis->tick_number = _axis->labels.size();
  _axis->minimum_value = _axis->values.values()[0];
  _axis->maximum_value = _axis->values.values()[_axis->tick_number.value()-1];
#endif

  if(a_title_right.size()) {
    _axis->title = a_title_right;
    _axis->title_style().font = inlib::sg::font_arialbd_ttf();
    _axis->title_style().scale = 1.5F;
    _axis->title_style().x_orientation = inlib::vec3f(0,-1,0);
    _axis->title_style().y_orientation = inlib::vec3f(1,0,0);
    _axis->title_style().hjust = inlib::sg::center;
    _axis->title_style().vjust = inlib::sg::bottom;
    //_axis->title_style().translation = inlib::vec3f(hcase*0.5F,0,0);
    _axis->title_style().translation = inlib::vec3f(hcase*0.25F,0,0);
  }

  _sep->add(_axis);}

  a_gv.set_scene_camera(camera);
  a_gv.set_scene_light(light);

  a_gv.hide_main_menu();

}

inline void create_sight_chart_sg(inlib::sg::gui_viewer& a_gv,
                                  double a_doesco,double a_hoenock,
                                  double a_qpDegreeRef,double a_qpDegree,double a_v0,double a_auTomm,
                                  double a_xFmin,double a_xFmax,double a_xFstep) {
  unsigned int ncase = (a_xFmax-a_xFmin)/a_xFstep;
  unsigned int ntick = ncase+1;
  typedef std::pair<double,double> item;
  std::vector<item> ticks;
  double mark0 = sight_chart(a_doesco,a_hoenock,a_qpDegreeRef,a_v0,a_auTomm,a_xFmin);
  for(unsigned int index=0;index<ntick;index++) {
    double xF = a_xFmin+index*a_xFstep; //m
    double mark = sight_chart(a_doesco,a_hoenock,a_qpDegree,a_v0,a_auTomm,xF)-mark0;
    //ticks.push_front(item(xF,mark));
    ticks.insert(ticks.begin(),item(xF,mark));
  }
  create_ruler_sg(a_gv,ticks);
}

}

#endif
