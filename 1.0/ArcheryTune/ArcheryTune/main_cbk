// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file ArcheryTune.license for terms.

#ifndef ArcheryTune_ArcheryTune_main_cbk
#define ArcheryTune_ArcheryTune_main_cbk

#include <inlib/sg/acbk>
#include <inlib/sg/circle>
#include <inlib/sg/ring>
#include <inlib/sg/entries>
#include <inlib/sg/list>
#include <inlib/sg/opener>
#include <inlib/sg/render_mem>
#include <inlib/sjust>

//#include <inlib/sg/f2plot>

#include <inlib/cbk/popup>

#include <exlib/jpeg>
#include <exlib/sg/text_freetype>

namespace ArcheryTune {

class main_cbk : public inlib::sg::ecbk {
  INLIB_CBK(main_cbk,ArcheryTune::main_cbk,inlib::sg::ecbk)
private:
  static float adjust_factor() {return 1.05f;}
  static unsigned int steps() {return 128;}

  static float z_rings()   {return 0.0f;}
  static float z_back()    {return -0.1f;}
  static float z_borders() {return 0.1f;}
  static float z_cross()   {return 0.1f;}
  static float z_numbers() {return 0.15f;}

  static float z_ghost()   {return 0.2f;}

  static float z_scope_cache_pastille() {return 0.4f;}
  static float z_infos_back_menu() {return 0.5f;}
public:
  static unsigned int action_main_scope()        {return 0;}
  static unsigned int action_main_icon()         {return 1;}
  static unsigned int action_main_FOC()          {return 2;}
  static unsigned int action_main_sight_charts() {return 3;}
protected:
  static unsigned int action_FOC_LA()        {return 10;}
  static unsigned int action_FOC_dm()        {return 11;}
  static unsigned int action_FOC_full()      {return 12;}
  static unsigned int action__FOC_dm()       {return 13;}
  static unsigned int action__FOC_LA()       {return 14;}
  static unsigned int action__FOC_full()     {return 15;}

  static unsigned int action_scope_kind()    {return 16;}

  static unsigned int action_scope()         {return 17;}

  static unsigned int action_scope_adjust()  {return 19;}

  static unsigned int action_infos_adjust()  {return 20;}

  static unsigned int action_sight_charts()  {return 21;}

  static unsigned int action_FITA_indoor()          {return 100;}
  static unsigned int action_FITA_outdoor()         {return 101;}
  static unsigned int action_field()                {return 102;}
  static unsigned int action_nature()               {return 103;}

  static unsigned int action_indoor_80()            {return 110;}
  static unsigned int action_indoor_60()            {return 111;}
  static unsigned int action_indoor_40()            {return 112;}
  static unsigned int action_indoor_40_31()         {return 113;}

  static unsigned int action_outdoor_122()          {return 114;}
  static unsigned int action_outdoor_80()           {return 115;}
  static unsigned int action_outdoor_80_22()        {return 116;}

  static unsigned int action_field_80()             {return 117;}
  static unsigned int action_field_60()             {return 118;}
  static unsigned int action_field_40_22()          {return 119;}
  static unsigned int action_field_20_34()          {return 120;}

  static unsigned int action_nature_big()           {return 121;}
  static unsigned int action_nature_medium()        {return 122;}
  static unsigned int action_nature_little()        {return 123;}
  static unsigned int action_nature_tiny()          {return 124;}

  static unsigned int action_nature_hippopotame()    {return 140;}
  static unsigned int action_nature_chammeau()       {return 141;}
  static unsigned int action_nature_daim()           {return 142;}
  static unsigned int action_nature_loupgris()       {return 143;}
  static unsigned int action_nature_paon()           {return 144;}
  static unsigned int action_nature_pandaroux()      {return 145;}
  static unsigned int action_nature_canardmandarin() {return 146;}
  static unsigned int action_nature_lapin()          {return 147;}

  // blason string id :
  INLIB_CLASS_STRING(indoor_80)
  INLIB_CLASS_STRING(indoor_60)
  INLIB_CLASS_STRING(indoor_40)
  INLIB_CLASS_STRING(indoor_40_31)

  INLIB_CLASS_STRING(outdoor_122)
  INLIB_CLASS_STRING(outdoor_80)
  INLIB_CLASS_STRING(outdoor_80_22)

  INLIB_CLASS_STRING(field_80)
  INLIB_CLASS_STRING(field_60)
  INLIB_CLASS_STRING(field_40_22)
  INLIB_CLASS_STRING(field_20_34)

  INLIB_CLASS_STRING(nature_hippopotame)
  INLIB_CLASS_STRING(nature_chammeau)
  INLIB_CLASS_STRING(nature_daim)
  INLIB_CLASS_STRING(nature_loupgris)
  INLIB_CLASS_STRING(nature_paon)
  INLIB_CLASS_STRING(nature_pandaroux)
  INLIB_CLASS_STRING(nature_canardmandarin)
  INLIB_CLASS_STRING(nature_lapin)

  // menu item labels :
  INLIB_CLASS_STRING_VALUE(label_indoor_80,80cm single)
  INLIB_CLASS_STRING_VALUE(label_indoor_60,60cm single)
  INLIB_CLASS_STRING_VALUE(label_indoor_40,40cm single)
  INLIB_CLASS_STRING_VALUE(label_indoor_40_31,40cm Vertical Tri-spot)

  INLIB_CLASS_STRING_VALUE(label_outdoor_122,122cm single)
  INLIB_CLASS_STRING_VALUE(label_outdoor_80,80cm single)
  INLIB_CLASS_STRING_VALUE(label_outdoor_80_22,4 x reduced 80cm)

  INLIB_CLASS_STRING_VALUE(label_field_80,80cm single)
  INLIB_CLASS_STRING_VALUE(label_field_60,60cm single)
  INLIB_CLASS_STRING_VALUE(label_field_40_22,2x2 40cm)
  INLIB_CLASS_STRING_VALUE(label_field_20_34,3x4 20cm)

/*French :
  INLIB_CLASS_STRING_VALUE(label_hippopotame,hippopotame)
  INLIB_CLASS_STRING_VALUE(label_chammeau,chammeau)
  INLIB_CLASS_STRING_VALUE(label_daim,daim)
  INLIB_CLASS_STRING_VALUE(label_loupgris,loupgris)
  INLIB_CLASS_STRING_VALUE(label_paon,paon)
  INLIB_CLASS_STRING_VALUE(label_pandaroux,pandaroux)
  INLIB_CLASS_STRING_VALUE(label_canardmandarin,canardmandarin)
  INLIB_CLASS_STRING_VALUE(label_lapin,lapin)
*/
  INLIB_CLASS_STRING_VALUE(label_hippopotame,hippopotamus)
  INLIB_CLASS_STRING_VALUE(label_chammeau,camel)
  INLIB_CLASS_STRING_VALUE(label_daim,deer)
  INLIB_CLASS_STRING_VALUE(label_loupgris,grey wolf)
  INLIB_CLASS_STRING_VALUE(label_paon,peacock)
  INLIB_CLASS_STRING_VALUE(label_pandaroux,red panda)
  INLIB_CLASS_STRING_VALUE(label_canardmandarin,mandarin duck)
  INLIB_CLASS_STRING_VALUE(label_lapin,rabbit)

  static const std::map<unsigned int,std::string>& action_blasons() {
    static std::map<unsigned int,std::string> s_v;
    if(s_v.empty()) {
      s_v[action_indoor_80()] = s_indoor_80();
      s_v[action_indoor_60()] = s_indoor_60();
      s_v[action_indoor_40()] = s_indoor_40();
      s_v[action_indoor_40_31()] = s_indoor_40_31();

      s_v[action_outdoor_122()] = s_outdoor_122();
      s_v[action_outdoor_80()] = s_outdoor_80();
      s_v[action_outdoor_80_22()] = s_outdoor_80_22();

      s_v[action_field_80()] = s_field_80();
      s_v[action_field_60()] = s_field_60();
      s_v[action_field_40_22()] = s_field_40_22();
      s_v[action_field_20_34()] = s_field_20_34();

      s_v[action_nature_hippopotame()] = s_nature_hippopotame();
      s_v[action_nature_chammeau()]    = s_nature_chammeau();
      s_v[action_nature_daim()]        = s_nature_daim();
      s_v[action_nature_loupgris()]    = s_nature_loupgris();
      s_v[action_nature_paon()]        = s_nature_paon();
      s_v[action_nature_pandaroux()]   = s_nature_pandaroux();
      s_v[action_nature_canardmandarin()] = s_nature_canardmandarin();
      s_v[action_nature_lapin()]       = s_nature_lapin();

    }
    return s_v;
  }

  typedef std::vector<std::string> dists_t;  
  typedef std::pair<dists_t,std::string> distelem;  
  static const std::map<unsigned int,distelem>& action_dists() {
    static std::map<unsigned int,distelem> s_v;
    if(s_v.empty()) {

     {dists_t def;
      def.push_back(s_18());
      def.push_back(s_25());
      def.push_back(s_30());
      def.push_back(s_50());
      def.push_back(s_70());
      s_v[action_indoor_80()] = distelem(def,s_25());
      s_v[action_indoor_60()] = distelem(def,s_18());}

     {dists_t def;
      def.push_back(s_18());
      def.push_back(s_30());
      def.push_back(s_50());
      def.push_back(s_70());
      s_v[action_indoor_40()] = distelem(def,s_18());
      s_v[action_indoor_40_31()] = distelem(def,s_18());}

     {dists_t def;
      def.push_back(s_18());
      def.push_back(s_30());
      def.push_back(s_50());
      def.push_back(s_60());
      def.push_back(s_70());
      s_v[action_outdoor_122()] = distelem(def,s_50());}

     {dists_t def;
      def.push_back(s_18());
      def.push_back(s_30());
      def.push_back(s_40());
      def.push_back(s_50());
      def.push_back(s_70());
      s_v[action_outdoor_80()] = distelem(def,s_40());
      s_v[action_outdoor_80_22()] = distelem(def,s_50());}

     {dists_t def;
      def.push_back(s_5());
      def.push_back(s_10());
      def.push_back(s_15());
      def.push_back(s_18());
      def.push_back(s_20());
      def.push_back(s_25());
      def.push_back(s_30());
      def.push_back(s_35());
      def.push_back(s_40());
      def.push_back(s_45());
      def.push_back(s_50());
      def.push_back(s_55()); 
      def.push_back(s_70());

      s_v[action_field_80()] = distelem(def,s_35());
      s_v[action_field_60()] = distelem(def,s_25());
      s_v[action_field_40_22()] = distelem(def,s_18());
      s_v[action_field_20_34()] = distelem(def,s_10());

      s_v[action_nature_hippopotame()] = distelem(def,s_35());
      s_v[action_nature_chammeau()] = distelem(def,s_35());

      s_v[action_nature_daim()] = distelem(def,s_25());
      s_v[action_nature_loupgris()] = distelem(def,s_25());

      s_v[action_nature_paon()] = distelem(def,s_18());
      s_v[action_nature_pandaroux()] = distelem(def,s_18());

      s_v[action_nature_canardmandarin()] = distelem(def,s_10());
      s_v[action_nature_lapin()] = distelem(def,s_10());
     }
    }
    return s_v;
  }

  typedef std::pair<double,double> mnmx_t;  
  static const std::map<unsigned int,mnmx_t>& action_mnmxs() {
    static std::map<unsigned int,mnmx_t> s_v;
    if(s_v.empty()) {
      s_v[action_indoor_80()] = mnmx_t(10,80);
      s_v[action_indoor_60()] = mnmx_t(10,80); 
      s_v[action_indoor_40()] = mnmx_t(10,80);
      s_v[action_indoor_40_31()] = mnmx_t(10,80);

      s_v[action_outdoor_122()] = mnmx_t(10,80);
      s_v[action_outdoor_80()] = mnmx_t(10,80);
      s_v[action_outdoor_80_22()] = mnmx_t(10,80);

      s_v[action_field_80()] = mnmx_t(20,55);
      s_v[action_field_60()] = mnmx_t(15,35);
      s_v[action_field_40_22()] = mnmx_t(10,25);
      s_v[action_field_20_34()] = mnmx_t(5,15);

      s_v[action_nature_hippopotame()] = mnmx_t(30,40);
      s_v[action_nature_chammeau()] = mnmx_t(30,40);

      s_v[action_nature_daim()] = mnmx_t(20,35);
      s_v[action_nature_loupgris()] = mnmx_t(20,35);

      s_v[action_nature_paon()] = mnmx_t(15,25);
      s_v[action_nature_pandaroux()] = mnmx_t(15,25);

      s_v[action_nature_canardmandarin()] = mnmx_t(5,15);
      s_v[action_nature_lapin()] = mnmx_t(5,15);

    }
    return s_v;
  }

  static const std::map<std::string,std::string>& nature_images() {
    static std::map<std::string,std::string> s_v;
    if(s_v.empty()) {
      s_v[s_nature_hippopotame()] = "ams_gg0036_grand_hippopotame.jpg";
      s_v[s_nature_chammeau()]    = "ams_gg0051_grand_chammeau.jpg";
      s_v[s_nature_daim()]        = "ams_mg0061_moyen_daim.jpg";
      s_v[s_nature_loupgris()]    = "ams_mg0064_moyen_loupgris.jpg";
      s_v[s_nature_paon()]        = "ams_pg0065_petit_paon.jpg";
      s_v[s_nature_pandaroux()]   = "ams_pg0068_petit_pandaroux.jpg";
      s_v[s_nature_canardmandarin()] = "ams_pa0088_petita_canardmandarin.jpg";
      s_v[s_nature_lapin()]       = "ams_pa0092_petita_lapin.jpg";
    }
    return s_v;
  }

  static const std::map<std::string,double>& nature_heights() {
    static std::map<std::string,double> s_v;
    if(s_v.empty()) {
      //100x70
      s_v[s_nature_hippopotame()] = 70;
      s_v[s_nature_chammeau()]    = 100;
      //70x50
      s_v[s_nature_daim()]        = 70;
      s_v[s_nature_loupgris()]    = 50;
      //50x35
      s_v[s_nature_paon()]        = 35;
      s_v[s_nature_pandaroux()]   = 50;
      //35x25
      s_v[s_nature_canardmandarin()] = 25;
      s_v[s_nature_lapin()]          = 35;
    }
    return s_v;
  }

//INLIB_CLASS_STRING(tri_spot_60_vertical)
//INLIB_CLASS_STRING(22_spot_80)

public:
  virtual return_action action() {

    if(m_action==action_main_scope()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add("FITA indoor",new main_cbk(m_gv,action_FITA_indoor()));
      list->add("FITA outdoor",new main_cbk(m_gv,action_FITA_outdoor()));
      list->add("Field",new main_cbk(m_gv,action_field()));
      list->add("2D - Animals",new main_cbk(m_gv,action_nature()));
  
      m_gv.push_list(list);

    } else if(m_action==action_FITA_indoor()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add(s_label_indoor_80(),new main_cbk(m_gv,action_indoor_80()));
      list->add(s_label_indoor_60(),new main_cbk(m_gv,action_indoor_60()));
      list->add(s_label_indoor_40(),new main_cbk(m_gv,action_indoor_40()));
      list->add(s_label_indoor_40_31(),new main_cbk(m_gv,action_indoor_40_31()));

      m_gv.push_list(list);
    
    } else if(m_action==action_FITA_outdoor()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add(s_label_outdoor_122(),new main_cbk(m_gv,action_outdoor_122()));
      list->add(s_label_outdoor_80(), new main_cbk(m_gv,action_outdoor_80()));
      list->add(s_label_outdoor_80_22(), new main_cbk(m_gv,action_outdoor_80_22()));
  
      m_gv.push_list(list);


    } else if(m_action==action_field()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add(s_label_field_80(),new main_cbk(m_gv,action_field_80()));
      list->add(s_label_field_60(),new main_cbk(m_gv,action_field_60()));
      list->add(s_label_field_40_22(),new main_cbk(m_gv,action_field_40_22()));
      list->add(s_label_field_20_34(),new main_cbk(m_gv,action_field_20_34()));
  
      m_gv.push_list(list);

    } else if(m_action==action_nature()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add("Big",new main_cbk(m_gv,action_nature_big()));
      list->add("Medium",new main_cbk(m_gv,action_nature_medium()));
      list->add("Small",new main_cbk(m_gv,action_nature_little()));
      list->add("Birdy",new main_cbk(m_gv,action_nature_tiny()));
  
      m_gv.push_list(list);

    } else if(m_action==action_nature_big()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add(s_label_hippopotame(),new main_cbk(m_gv,action_nature_hippopotame()));
      list->add(s_label_chammeau(),new main_cbk(m_gv,action_nature_chammeau()));
  
      m_gv.push_list(list);

    } else if(m_action==action_nature_medium()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add(s_label_daim(),new main_cbk(m_gv,action_nature_daim()));
      list->add(s_label_loupgris(),new main_cbk(m_gv,action_nature_loupgris()));
  
      m_gv.push_list(list);

    } else if(m_action==action_nature_little()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add(s_label_paon(),new main_cbk(m_gv,action_nature_paon()));
      list->add(s_label_pandaroux(),new main_cbk(m_gv,action_nature_pandaroux()));
  
      m_gv.push_list(list);

    } else if(m_action==action_nature_tiny()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add(s_label_canardmandarin(),new main_cbk(m_gv,action_nature_canardmandarin()));
      list->add(s_label_lapin(),new main_cbk(m_gv,action_nature_lapin()));
  
      m_gv.push_list(list);

    } else if(m_action==action_main_FOC()) {

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

      list->add("FOC from Lengths",new main_cbk(m_gv,action_FOC_LA()));
      list->add("Adjust point mass",new main_cbk(m_gv,action_FOC_dm()));
      list->add("FOC from Weights",new main_cbk(m_gv,action_FOC_full()));

      m_gv.push_list(list);
    
    } else if(m_action==action_main_sight_charts()) {

      inlib::sg::entries* node = new inlib::sg::entries(m_gv.ttf());
      m_gv.set_colors(*node);

      double def_doesco   = 31.5;  //inch
      double def_hoenock  = 4.7;   //inch
      double def_qpDegree = 0;     //deg
      double def_v0       = 297;   //fps
      double def_auTomm   = 1;     //

/*
      double def_doesco   = 30.79;  //inch
      double def_hoenock  = 3.82;   //inch
      double def_qpDegree = 0;     //deg
      double def_v0       = 237;   //fps
      double def_auTomm   = 1;     //
*/

      node->add_double("Eye to scope (in)",def_doesco);
      node->add_double("Eye to nock (in)" ,def_hoenock);
      node->add_double("Slope (deg)"      ,def_qpDegree);
      node->add_double("Arrow speed (fps)",def_v0);
      node->add_double("A.U to mm conv."  ,def_auTomm);

     {main_cbk* cbk = new main_cbk(m_gv,action_sight_charts());
      cbk->m_entries = node;
      node->add_callback(cbk);}

      m_gv.push_list(node);

    } else if(m_action==action_sight_charts()) {
      m_entries->label = "";
      const std::vector<std::string>& vals = m_entries->values.values();

      double doesco;
     {if(!inlib::to<double>(vals[0],doesco)){
        _map_warn("param[0] not a double");
        return return_to_render;     
      }
      if(doesco<=0) {
        _map_warn("param[0] must be >0");
        return return_to_render;     
      }}

      double hoenock;
     {if(!inlib::to<double>(vals[1],hoenock)){
        _map_warn("param[1] not a double");
        return return_to_render;     
      }
      if(hoenock<=0) {
        _map_warn("param[1] must be >0");
        return return_to_render;     
      }}

      double qpDegree;
     {if(!inlib::to<double>(vals[2],qpDegree)){
        _map_warn("param[2] not a double");
        return return_to_render;     
      }
      if(qpDegree<-90) {
        _map_warn("param[2] must be >=-90");
        return return_to_render;     
      }
      if(qpDegree>90) {
        _map_warn("param[2] must be <=90");
        return return_to_render;     
      }}

      double v0;
     {if(!inlib::to<double>(vals[3],v0)){
        _map_warn("param[3] not a double");
        return return_to_render;     
      }
      if(v0<=0) {
        _map_warn("param[3] must be >0");
        return return_to_render;     
      }}

      double auTomm;
     {if(!inlib::to<double>(vals[4],auTomm)){
        _map_warn("param[4] not a double");
        return return_to_render;     
      }
      if(auTomm<=0) {
        _map_warn("param[4] must be >0");
        return return_to_render;     
      }}

      double mark0 = sight_chart(doesco,hoenock,0,v0,auTomm,5);

      inlib::sg::list* list = new inlib::sg::list(m_gv.ttf());
      m_gv.set_colors(*list);

     {for(unsigned int index=1;index<=12;index++) {
        double xF = 5*index; //m
        double mark = sight_chart(doesco,hoenock,qpDegree,v0,auTomm,xF)-mark0;

        std::string _x = inlib::to<double>(xF);
        inlib::sprintf(_x,128,"%.1f",xF);
        inlib::justify(_x,8,inlib::side_left);

        std::string _v = inlib::to<double>(mark);
        inlib::sprintf(_v,128,"%.1f",mark);
        inlib::justify(_v,8,inlib::side_right);

        list->add(_x+_v,new inlib::cbk::none());
      }}

      m_gv.push_list(list);

    } else if(  (m_action==action_indoor_80())         ||
                (m_action==action_indoor_60())         ||
                (m_action==action_indoor_40())         ||
                (m_action==action_indoor_40_31())      ||

                (m_action==action_outdoor_122())       ||
                (m_action==action_outdoor_80())        ||
                (m_action==action_outdoor_80_22())     ||

                (m_action==action_field_80())          ||
                (m_action==action_field_60())          ||
                (m_action==action_field_40_22())       ||
                (m_action==action_field_20_34())       ||

                (m_action==action_nature_hippopotame()) ||
                (m_action==action_nature_chammeau())    ||
                (m_action==action_nature_daim()) ||
                (m_action==action_nature_loupgris()) ||
                (m_action==action_nature_canardmandarin()) ||
                (m_action==action_nature_lapin()) ||
                (m_action==action_nature_paon()) ||
                (m_action==action_nature_pandaroux()) ){

      inlib::sg::entries* node = new inlib::sg::entries(m_gv.ttf());
      m_gv.set_colors(*node);

     {std::string v;
      std::map<unsigned int,std::string>::const_iterator it = action_blasons().find(m_action);
      if(it!=action_blasons().end()) v = (*it).second;
      node->add_not_editable(s_blason(),v);}
  
      node->add_double(s_dsoe()+" (m)",0.8);
  
     {std::vector<std::string> opts;
      opts.push_back(s_0_25());
      opts.push_back(s_0_5());
      opts.push_back(s_0_625());
      opts.push_back(s_0_75());
      opts.push_back(s_0_8());
      opts.push_back(s_1());
      opts.push_back(s_1_2());
      node->add_opts(s_dioptrie()+" (1/m)",s_0_5(),opts);}

     {dists_t v;
      std::map<unsigned int,distelem>::const_iterator it = action_dists().find(m_action);
      if(it!=action_dists().end()) v = (*it).second.first;
      node->add_opts(s_dist_cible()+" (m)",(*it).second.second,v);}

     {std::vector<std::string> opts;
      opts.push_back(s_29());
      opts.push_back(s_35());
      opts.push_back(s_42());
      node->add_opts(s_diam_scope()+" (mm)",s_42(),opts);}
  
      node->add_double(s_diam_pastille()+" (mm)",2);
  
      main_cbk* cbk = new main_cbk(m_gv,action_scope());
      cbk->m_entries = node;
     {std::map<unsigned int,mnmx_t>::const_iterator it = action_mnmxs().find(m_action);
      if(it!=action_mnmxs().end()) {
        cbk->m_slider_dist_min = (*it).second.first;
        cbk->m_slider_dist_max = (*it).second.second;
      }}
      node->add_callback(cbk);
  
      m_gv.push_list(node);
  
    } else if(m_action==action_scope()) {

      const std::vector<std::string>& vals = m_entries->values.values();

      const std::string& blason = vals[0];

      double dsoe;
      if(!inlib::to(vals[1],dsoe)) dsoe = 0.8;

      double dioptrie;
      if(!inlib::to(vals[2],dioptrie)) dioptrie  = 0.75;

      double dCible;
      if(!inlib::to(vals[3],dCible)) dCible = 50;

      double diamScope;
      if(!inlib::to(vals[4],diamScope)) diamScope = 29;
      diamScope *= 0.001; //now in meter.

      double diamPastille;
      if(!inlib::to(vals[5],diamPastille)) diamPastille = 2;
      diamPastille *= 0.001; //now in meter.

      create_scope_sg(m_gv,blason,diamScope,dsoe,dCible,dioptrie,diamPastille,
                      m_slider_dist_min,m_slider_dist_max);

    } else if(m_action==action_FOC_LA()) {

      inlib::sg::entries* node = new inlib::sg::entries(m_gv.ttf());
      m_gv.set_colors(*node);
      node->shown_label_color = inlib::colorf::pink();

      double def_L = 100; //cm
      double def_A = 60;  //cm

      node->add_double("Total length (cm)",def_L);
      node->add_double("Nock - Balance Pt (cm)",def_A);

      double def_FOC = FOC_LA(def_L,def_A);
      node->label = inlib::to(def_FOC)+" %";

     {main_cbk* cbk = new main_cbk(m_gv,action__FOC_LA());
      cbk->m_entries = node;
      node->add_callback(cbk);}

      m_gv.push_list(node);

    } else if(m_action==action__FOC_LA()) {
      const std::vector<std::string>& vals = m_entries->values.values();

      double L;
     {if(!inlib::to<double>(vals[0],L)){
        _map_warn("param[0] not a double");
        return return_to_render;     
      }
      if(L<=0) {
        _map_warn("param[0] must be >0");
        return return_to_render;     
      }}

      double A;
     {if(!inlib::to<double>(vals[1],A)){
        _map_warn("param[1] not a double");
        return return_to_render;     
      }
      if(((2*A)<=L)||(A>=L)) {
        _map_warn("param[1] must be in ]L/2,L[");
        return return_to_render;     
      }}

      double FOC = FOC_LA(L,A);

      m_entries->label = inlib::to(FOC)+" %";
      m_entries->label_back_color = inlib::colorf::springgreen();

    } else if(m_action==action_FOC_dm()) {

      inlib::sg::entries* node = new inlib::sg::entries(m_gv.ttf());
      m_gv.set_colors(*node);
      node->shown_label_color = inlib::colorf::pink();

      double def_old = 15;
      double def_mass = 475;
      double def_new = 14;

      node->add_double("Current FOC (%)"   ,def_old);
      node->add_double("Tot. arrow weight (gn)",def_mass);
      node->add_double("Target FOC (%)"   ,def_new);

      double def_dm = FOC_dm(def_old,def_new,def_mass);
     {std::string s;
      if(def_dm>=0) {
        inlib::sprintf(s,128,"Add %.1f gn",def_dm);
      } else {
        inlib::sprintf(s,128,"Remove %.1f gn",-def_dm);
      }
      node->label = s;}

     {main_cbk* cbk = new main_cbk(m_gv,action__FOC_dm());
      cbk->m_entries = node;
      node->add_callback(cbk);}

      m_gv.push_list(node);
      //m_gv.hide_console();

    } else if(m_action==action__FOC_dm()) {
      const std::vector<std::string>& vals = m_entries->values.values();

      double old_FOC;
     {if(!inlib::to<double>(vals[0],old_FOC)){
        _map_warn("param[0] not a double");
        return return_to_render;     
      }
      if((old_FOC<0)||(old_FOC>50)) {
        _map_warn("param[0] not in [0,50]");
        return return_to_render;     
      }}

      double mass;
      if(!inlib::to<double>(vals[1],mass)){
        _map_warn("param[1] not a double");
        return return_to_render;     
      }

      double new_FOC;
     {if(!inlib::to<double>(vals[2],new_FOC)){
        _map_warn("param[2] not a double");
        return return_to_render;     
      }
      if((new_FOC<0)||(new_FOC>=50)) {
        _map_warn("param[2] not in [0,50[");
        return return_to_render;     
      }}

      double dm = FOC_dm(old_FOC,new_FOC,mass);

      //m_gv.map_warn(inlib::to(dm)+" grains",false);

      std::string s;
      if(dm>=0) {
        inlib::sprintf(s,128,"Add %.1f gn",dm);
      } else {
        inlib::sprintf(s,128,"Remove %.1f gn",-dm);
      }

      m_entries->label = s;
      m_entries->label_back_color = inlib::colorf::springgreen();

    } else if(m_action==action_FOC_full()) {

      inlib::sg::entries* node = new inlib::sg::entries(m_gv.ttf());
      m_gv.set_colors(*node);
      node->shown_label_color = inlib::colorf::pink();

      double def_m_Pt = 120;   //gn
      double def_rho_T = 5.9;  //gn/in
      double def_L_T = 27;     //in
      double def_m_PL = 9;     //gn
      double def_m_W = 0;      //gn
      double def_m_B = 0;      //gn
      double def_m_Pn = 0;     //gn
      double def_m_N = 6.8;    //gn

      node->add_double("Point/insert weight (gn)",def_m_Pt);
      node->add_double("Shaft per inch (gn/in)",def_rho_T);
      node->add_double("Shaft length (in)",def_L_T);
      node->add_double("All fletch weight (gn)",def_m_PL);
      node->add_double("Wrap weight (gn)",def_m_W);
      node->add_double("Bushing weight (gn)",def_m_B);
      node->add_double("Pin-nock weight (gn)",def_m_Pn);
      node->add_double("nock weight (gn)",def_m_N);

      double def_m_Tot;
      double def_FOC;
      FOC_full(def_m_Pt,def_rho_T,
               def_L_T,def_m_PL,
               def_m_W,def_m_B,
               def_m_Pn,def_m_N,
               def_m_Tot,def_FOC);
   
      std::string s;
      inlib::sprintf
        (s,512,"Tot. weight %.1f gn, FOC %.1f %%",def_m_Tot,def_FOC);
      node->label = s;
      node->label_confine = true;

     {main_cbk* cbk = new main_cbk(m_gv,action__FOC_full());
      cbk->m_entries = node;
      node->add_callback(cbk);}

      m_gv.push_list(node);
      //m_gv.hide_console();

    } else if(m_action==action__FOC_full()) {
      const std::vector<std::string>& vals = m_entries->values.values();

      double m_Pt;
     {if(!inlib::to<double>(vals[0],m_Pt)){
        _map_warn("param[0] not a double");
        return return_to_render;     
      }
      if(m_Pt<=0) {
        _map_warn("param[0] must be >0");
        return return_to_render;     
      }}

      double rho_T;
     {if(!inlib::to<double>(vals[1],rho_T)){
        _map_warn("param[1] not a double");
        return return_to_render;     
      }
      if(rho_T<=0) {
        _map_warn("param[1] must be >0");
        return return_to_render;     
      }}

      double L_T;
     {if(!inlib::to<double>(vals[2],L_T)){
        _map_warn("param[2] not a double");
        return return_to_render;     
      }
      if(L_T<=0) {
        _map_warn("param[2] must be >0");
        return return_to_render;     
      }}

      double m_PL;
     {if(!inlib::to<double>(vals[3],m_PL)){
        _map_warn("param[3] not a double");
        return return_to_render;     
      }
      if(m_PL<=0) {
        _map_warn("param[3] must be >0");
        return return_to_render;     
      }}

      double m_W;
     {if(!inlib::to<double>(vals[4],m_W)){
        _map_warn("param[4] not a double");
        return return_to_render;     
      }
      if(m_W<0) {
        _map_warn("param[4] must be >0");
        return return_to_render;     
      }}

      double m_B;
     {if(!inlib::to<double>(vals[5],m_B)){
        _map_warn("param[5] not a double");
        return return_to_render;     
      }
      if(m_B<0) {
        _map_warn("param[5] must be >0");
        return return_to_render;     
      }}

      double m_Pn;
     {if(!inlib::to<double>(vals[6],m_Pn)){
        _map_warn("param[6] not a double");
        return return_to_render;     
      }
      if(m_Pn<0) {
        _map_warn("param[6] must be >0");
        return return_to_render;     
      }}

      double m_N;
     {if(!inlib::to<double>(vals[7],m_N)){
        _map_warn("param[7] not a double");
        return return_to_render;     
      }
      if(m_N<=0) {
        _map_warn("param[7] must be >0");
        return return_to_render;     
      }}

      double m_Tot;
      double FOC;
      FOC_full(m_Pt,rho_T,L_T,m_PL,m_W,m_B,m_Pn,m_N,m_Tot,FOC);

      std::string s;
      inlib::sprintf(s,512,"Tot. weight %.1f gn, FOC %.1f %%",m_Tot,FOC);
      m_entries->label = s;
      m_entries->label_confine = true;

      m_entries->label_back_color = inlib::colorf::springgreen();

    } else if(m_action==action_scope_adjust()) {
      if(const inlib::sg::size_event* sz_evt =
         inlib::safe_cast<inlib::sg::event,inlib::sg::size_event>(*m_event)){
        unsigned int ww = sz_evt->width();
        unsigned int wh = sz_evt->height();
        float hcam = 2;
        float wcam = hcam*float(ww)/float(wh);
        adjust_infos(*m_infos_text,*m_infos_matrix,wcam,hcam);
        adjust_back_to_menu(*m_back_to_menu_button,*m_back_to_menu_matrix,
                            wcam,hcam);
        adjust_tscp_matrix(*m_tscp_matrix,wcam,hcam,m_scope_radius);
        m_event_action->set_done(true);
      }

    }

    return return_to_render;     
  }

public:
  main_cbk(inlib::sg::gui_viewer& a_gv,unsigned int a_action)
  :parent(a_action)
  ,m_gv(a_gv)

  ,m_entries(0)
  ,m_scope_radius(0)
  ,m_pastille_radius(0)
  ,m_slider_dist_min(10)
  ,m_slider_dist_max(80)
  ,m_tscp_matrix(0)
  ,m_infos_text(0)
  ,m_infos_matrix(0)
  ,m_back_to_menu_button(0)
  ,m_back_to_menu_matrix(0)
  {}
  virtual ~main_cbk(){}
protected:
  main_cbk(const main_cbk& a_from)
  :parent(a_from)
  ,m_gv(a_from.m_gv)

  ,m_entries(a_from.m_entries)
  ,m_scope_radius(a_from.m_scope_radius)
  ,m_pastille_radius(a_from.m_pastille_radius)
  ,m_sparams(a_from.m_sparams)
  ,m_slider_dist_min(a_from.m_slider_dist_min)
  ,m_slider_dist_max(a_from.m_slider_dist_max)
  ,m_tscp_matrix(a_from.m_tscp_matrix)
  ,m_infos_text(a_from.m_infos_text)
  ,m_infos_matrix(a_from.m_infos_matrix)
  ,m_back_to_menu_button(a_from.m_back_to_menu_button)
  ,m_back_to_menu_matrix(a_from.m_back_to_menu_matrix)
  {}
  main_cbk& operator=(const main_cbk& a_from){
    parent::operator=(a_from);
    m_entries = a_from.m_entries;
    m_scope_radius = a_from.m_scope_radius;
    m_pastille_radius = a_from.m_pastille_radius;
    m_sparams = a_from.m_sparams;
    m_slider_dist_min = a_from.m_slider_dist_min;
    m_slider_dist_max = a_from.m_slider_dist_max;
    m_tscp_matrix = a_from.m_tscp_matrix;
    m_infos_text = a_from.m_infos_text;
    m_infos_matrix = a_from.m_infos_matrix;
    m_back_to_menu_button = a_from.m_back_to_menu_button;
    m_back_to_menu_matrix = a_from.m_back_to_menu_matrix;
    return *this;
  }
protected:

  INLIB_CLASS_STRING_VALUE(blason,target)

  INLIB_CLASS_STRING_VALUE(dsoe,eye/scope)

  INLIB_CLASS_STRING_VALUE(dioptrie,diopter)
  INLIB_CLASS_STRING_VALUE(0_25,0.25)
  INLIB_CLASS_STRING_VALUE(0_5,0.5)
  INLIB_CLASS_STRING_VALUE(0_625,0.625)
  INLIB_CLASS_STRING_VALUE(0_75,0.75)
  INLIB_CLASS_STRING_VALUE(0_8,0.8)
  INLIB_CLASS_STRING_VALUE(1,1)
  INLIB_CLASS_STRING_VALUE(1_2,1.2)

  INLIB_CLASS_STRING_VALUE(dist_cible,distance)
  INLIB_CLASS_STRING(5)
  INLIB_CLASS_STRING(10)
  INLIB_CLASS_STRING(15)
  INLIB_CLASS_STRING(18)
  INLIB_CLASS_STRING(20)
  INLIB_CLASS_STRING(25)
  INLIB_CLASS_STRING(30)
  INLIB_CLASS_STRING(35)
  INLIB_CLASS_STRING(40)
  INLIB_CLASS_STRING(45)
  INLIB_CLASS_STRING(50)
  INLIB_CLASS_STRING(55)
  INLIB_CLASS_STRING(60)
  INLIB_CLASS_STRING(70)

  INLIB_CLASS_STRING_VALUE(diam_scope,scope)
  INLIB_CLASS_STRING(29)
//INLIB_CLASS_STRING(35)
  INLIB_CLASS_STRING(42)
  INLIB_CLASS_STRING_VALUE(diam_pastille,dot)

  static void create_scope_sg(inlib::sg::gui_viewer& a_gv,
                              const std::string& a_blason,
                              double a_diamScope,      //in meter
                              double a_dsoe,           //in meter
                              double a_dCible,         //in meter
                              double a_dioptrie,       //in 1/meter
                              double a_diamPastille,   //in meter
                              double a_slider_dist_min,
                              double a_slider_dist_max){

    double scope_proj_diam; //in meter
    if(!scope_proj(a_diamScope,
                   a_dsoe,a_dCible,a_dioptrie,
                   scope_proj_diam)||
       (scope_proj_diam<=0)){
      a_gv.map_warn("bad parameter");
      return;
    }
    scope_proj_diam *= 100; //now in cm.

    double pastille_proj_diam; //in meter
    if(!scope_proj(a_diamPastille,
                   a_dsoe,a_dCible,a_dioptrie,
                   pastille_proj_diam)||
       (pastille_proj_diam<=0)) {
      a_gv.map_warn("bad parameter");
      return;
    }
    pastille_proj_diam *= 100; //now in cm.

    float scope_radius = 0.5f*float(scope_proj_diam);
    float pastille_radius = 0.5f*float(pastille_proj_diam);

    a_gv.clear_scene(); //it will do a scene().clear_cbks().

    unsigned int ww = a_gv.width();
    unsigned int wh = a_gv.height();

    inlib::sg::separator& sep = a_gv.scene();

/*  // for viewer_popup :
    inlib::cbk::move_manip::add_cbks
      (a_gv.scene(),a_gv,a_gv.out(),a_gv.scene(),false);
    sep.up_cbks().add(new up_cbk(a_gv));
//      (new inlib::cbk::viewer_popup
//             (a_gv,inlib::cbk::viewer_popup::action_show()));
*/

    //for Android device rotation.
    inlib::sg::event_dispatcher* dpt = new inlib::sg::event_dispatcher;
    sep.add(dpt);

    //NOTE : the logic is arranged to keep camera height to 2
    //       and to adjust the tscp_matrix so that scope rmax
    //       map window height (or width according window aspect
    //       ratio).
    float hcam = 2;
    inlib::sg::base_camera* camera = a_gv.create_2D_camera(hcam);
    sep.add(camera);

    float wcam = hcam*float(ww)/float(wh);

    inlib::sg::head_light* light = new inlib::sg::head_light;
    light->direction = inlib::vec3f(1,-1,-10);
    sep.add(light);

    ////////////////////////////////////////////
    /// sumup : ////////////////////////////////
    ////////////////////////////////////////////
    inlib::sg::matrix* infos_matrix = 0;
    exlib::sg::text_freetype* infos_text = 0;
   {inlib::sg::separator* _sep = new inlib::sg::separator;
    sep.add(_sep);

    infos_matrix = new inlib::sg::matrix;
    _sep->add(infos_matrix);

    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = inlib::colorf::black();
    _sep->add(mat);

    infos_text = new exlib::sg::text_freetype();
    infos_text->modeling = inlib::sg::font_filled;
    infos_text->font = inlib::sg::font_arialbd_ttf();
    infos_text->front_face = inlib::sg::winding_cw;
    infos_text->hjust = inlib::sg::left;
    infos_text->vjust = inlib::sg::top;

   {std::string s;
    inlib::sprintf(s,128,"%.1f m  %.1f cm",a_dCible,scope_proj_diam);
    infos_text->strings.set_value(s);}

    adjust_infos(*infos_text,*infos_matrix,wcam,hcam);

    _sep->add(infos_text);}

    ////////////////////////////////////////////
    /// back to menu button : //////////////////
    ////////////////////////////////////////////
    inlib::sg::matrix* back_to_menu_matrix = 0;
    inlib::sg::image_button* back_to_menu_button = 0;
   {inlib::sg::separator* _sep = new inlib::sg::separator;
    sep.add(_sep);

    back_to_menu_matrix = new inlib::sg::matrix;
    _sep->add(back_to_menu_matrix);

    back_to_menu_button = new inlib::sg::image_button();
  //back_to_menu_button->back_area::color = a_gv.m_params.m_gui_arm_color;
    if(!a_gv.set_img_from_file(a_gv.out(),a_gv.res_dir(),"beos_menu.jpg",
                               back_to_menu_button->img.value())) {}

    adjust_back_to_menu(*back_to_menu_button,*back_to_menu_matrix,wcam,hcam);

    _sep->add(back_to_menu_button);}

    ////////////////////////////////////////////////////////
    /// target+scope+cache+pastille ////////////////////////
    ////////////////////////////////////////////////////////
   
    inlib::sg::matrix* tscp_matrix = new inlib::sg::matrix;    
    adjust_tscp_matrix(*tscp_matrix,wcam,hcam,scope_radius);
    sep.add(tscp_matrix);

    ////////////////////////////////////////////////////////
    /// target : ///////////////////////////////////////////
    ////////////////////////////////////////////////////////

    inlib::sg::separator* target_sep = new inlib::sg::separator;
    sep.add(target_sep);

    inlib::sg::matrix* target_matrix = new inlib::sg::matrix;    
    target_sep->add(target_matrix);

    bool do_render_mem = true; //OPTIMIZATION

    ghost* target_ghost = 0;
    inlib::sg::matrix* ghost_matrix = 0;

   {inlib::sg::separator* _sep = new inlib::sg::separator;
    target_sep->add(_sep);
    ghost_matrix = new inlib::sg::matrix;
    ghost_matrix->set_translate(0,0,z_ghost());
    _sep->add(ghost_matrix);
    target_ghost = new ghost(*target_matrix);
    // size set after having built the target.
    _sep->add(target_ghost);}

    float wta = 0;
    float hta = 0;
    float xta = 0;
    float yta = 0;

    inlib::sg::group* target_grp = new inlib::sg::group;

   {std::vector<inlib::colorf> cols;
    cols.push_back(inlib::colorf::yellow());
    cols.push_back(inlib::colorf::yellow());
    cols.push_back(inlib::colorf::red());
    cols.push_back(inlib::colorf::red());
    cols.push_back(inlib::colorf::cornflowerblue());
    cols.push_back(inlib::colorf::cornflowerblue());
    cols.push_back(inlib::colorf::black());
    cols.push_back(inlib::colorf::black());
    cols.push_back(inlib::colorf::white());
    cols.push_back(inlib::colorf::white());
    cols.push_back(inlib::colorf::white()); //10+1

    std::vector<inlib::colorf> camps;
    camps.push_back(inlib::colorf::yellow());
    camps.push_back(inlib::colorf::yellow());
    camps.push_back(inlib::colorf::black());
    camps.push_back(inlib::colorf::black());
    camps.push_back(inlib::colorf::black());
    camps.push_back(inlib::colorf::black());
    camps.push_back(inlib::colorf::black()); //6+1
  
    /////////////////////////////////////////////////////////////////////////
    /// indoor : ////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
           if(a_blason==s_indoor_80()) {
      rep_rings(*target_grp,82,10,4,cols,10,2.5f,a_gv.is_wall_screen_app());
      wta = hta = 82;

    } else if(a_blason==s_indoor_60()) {
      rep_rings(*target_grp,62,10,3,cols,10,2,a_gv.is_wall_screen_app());
      wta = hta = 62;

    } else if(a_blason==s_indoor_40()) {
      rep_rings(*target_grp,42,10,2,cols,10,1.5f,a_gv.is_wall_screen_app());
      wta = hta = 42;

    } else if(a_blason==s_indoor_40_31()) {
      float ys[3] = {-(11+0+11),0,11+0+11};

      for(unsigned int index=0;index<3;index++) {
        inlib::sg::separator* _sep = new inlib::sg::separator;
        target_grp->add(_sep);
        inlib::sg::matrix* m = new inlib::sg::matrix;
        m->set_translate(0,ys[index],0);
        _sep->add(m);
        rep_rings(*_sep,22,5,2,cols,10,1.5f,a_gv.is_wall_screen_app());
      }
      wta = 22;
      hta = 3*22;

    /////////////////////////////////////////////////////////////////////////
    /// outdoor : ///////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    } else if(a_blason==s_outdoor_122()) {
      rep_rings(*target_grp,123,10,6.1F,cols,10,3.5f,a_gv.is_wall_screen_app());

      wta = hta = 123;

    } else if(a_blason==s_outdoor_80()) {
      rep_rings(*target_grp,82,10,4,cols,10,2.5f,a_gv.is_wall_screen_app());
      wta = hta = 82;

    } else if(a_blason==s_outdoor_80_22()) {

      float space = 5.0F; //cm
      float dd = space*0.5F+24;

      float center_x =  dd;
      float center_y = -dd;
      xta = center_x;
      yta = center_y;

      // 2 3
      // 0 1
      float xs[4] = {-dd, dd,-dd,dd};
      float ys[4] = {-dd,-dd, dd,dd};

      for(unsigned int index=0;index<4;index++) {
        inlib::sg::separator* _sep = new inlib::sg::separator;
        target_grp->add(_sep);
        inlib::sg::matrix* m = new inlib::sg::matrix;
        m->set_translate(center_x+xs[index],center_y+ys[index],0);
        _sep->add(m);
        rep_rings(*_sep,48,6,4,cols,10,2.5f,a_gv.is_wall_screen_app());
      }
      wta = 48+space+48;
      hta = 48+space+48;

    /////////////////////////////////////////////////////////////////////////
    /// field : /////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    } else if(a_blason==s_field_80()) {
      rep_rings(*target_grp,0,6,8,camps,6,5,a_gv.is_wall_screen_app());
      wta = 6*8*2;
      hta = 6*8*2;

    } else if(a_blason==s_field_60()) {
      rep_rings(*target_grp,0,6,6,camps,6,4,a_gv.is_wall_screen_app());
      wta = 6*6*2;
      hta = 6*6*2;

    } else if(a_blason==s_field_40_22()) {

      float rad = 12; //cm
      float space = 0; //cm
      float hsp = space*0.5F; //cm
 
      float center_x =  rad+hsp;
      float center_y = -rad-hsp;
      xta = center_x;
      yta = center_y;

      // 2 3
      // 0 1
      float xs[4] = {-rad-hsp, rad+hsp,
                     -rad-hsp, rad+hsp};
      float ys[4] = {-rad-hsp,-rad-hsp,
                      rad+hsp, rad+hsp};

      for(unsigned int index=0;index<4;index++) {
        inlib::sg::separator* _sep = new inlib::sg::separator;
        target_grp->add(_sep);
        inlib::sg::matrix* m = new inlib::sg::matrix;
        m->set_translate(center_x+xs[index],center_y+ys[index],0);
        _sep->add(m);
        rep_rings(*_sep,0,6,2,camps,6,2,a_gv.is_wall_screen_app());
      }
      wta = rad*2+space+rad*2;
      hta = rad*2+space+rad*2;

    } else if(a_blason==s_field_20_34()) {

      float rad = 6; //cm
      float space = 0; //cm
      float hsp = space*0.5F; //cm

      float center_x = rad+hsp;
      float center_y =   0;
      xta = center_x;
      yta = center_y;

      // 8  9 10 11
      // 4  5  6  7
      // 0  1  2  3
      float xs[12] = {
               -(rad+hsp+space+2*rad),-(rad+hsp),rad+hsp,rad+hsp+space+2*rad,
               -(rad+hsp+space+2*rad),-(rad+hsp),rad+hsp,rad+hsp+space+2*rad,
               -(rad+hsp+space+2*rad),-(rad+hsp),rad+hsp,rad+hsp+space+2*rad};
      float ys[12] = {
               -rad-space-rad,-rad-space-rad,-rad-space-rad,-rad-space-rad,
                            0,             0,             0,             0,
                rad+space+rad, rad+space+rad, rad+space+rad, rad+space+rad};

      for(unsigned int index=0;index<12;index++) {
        inlib::sg::separator* _sep = new inlib::sg::separator;
        target_grp->add(_sep);
        inlib::sg::matrix* m = new inlib::sg::matrix;
        m->set_translate(center_x+xs[index],center_y+ys[index],0);
        _sep->add(m);
        rep_rings(*_sep,0,6,1,camps,6,1,a_gv.is_wall_screen_app());
      }

      wta = rad*2+space+rad*2+space+rad*2+space+rad*2;
      hta = rad*2+space+rad*2+space+rad*2;

    /////////////////////////////////////////////////////////////////////////
    /// nature : ////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    } else if( (a_blason==s_nature_hippopotame()) ||
               (a_blason==s_nature_chammeau())    ||
               (a_blason==s_nature_daim()) ||
               (a_blason==s_nature_loupgris()) ||
               (a_blason==s_nature_canardmandarin()) ||
               (a_blason==s_nature_lapin()) ||
               (a_blason==s_nature_paon()) ||
               (a_blason==s_nature_pandaroux()) ){

      do_render_mem = false;
 
      std::string image;
     {std::map<std::string,std::string>::const_iterator it = nature_images().find(a_blason);
      if(it!=nature_images().end()) {
        image = (*it).second;
      } else {
      }}

      double h;
     {std::map<std::string,double>::const_iterator it = nature_heights().find(a_blason);
      if(it!=nature_heights().end()) h = (*it).second;}

      if(image.size()) {
        rep_nature(a_gv.out(),a_gv.res_dir(),*target_grp,image,h,a_gv.is_wall_screen_app());
      }
      wta = h; //should use img aspect ratio.
      hta = h;

    } else {
      // unknown blason.
      delete target_grp;
      sep.clear();
      a_gv.map_warn("unknown target kind.");
      return;
 
    }} // blason kind

    if(do_render_mem) {
      inlib::sg::atb_vertices* pts = new inlib::sg::atb_vertices;
      inlib::sg::atb_vertices* lns = new inlib::sg::atb_vertices;
      inlib::sg::atb_vertices* trs = new inlib::sg::atb_vertices;
      inlib::sg::render_mem action(a_gv.out(),*pts,*lns,*trs);
      target_grp->render(action);
/*
      std::string s;
      s += inlib::to(pts->number())+" points.";
      s += " "+inlib::to(lns->number()/2)+" lines.";
      s += " "+inlib::to(trs->number()/3)+" triangles.";
      a_gv.out() << s << std::endl;
*/  
      target_sep->add(pts);
      target_sep->add(lns);
      target_sep->add(trs);

      delete target_grp;
    } else {
      target_sep->add(target_grp);
    }

    target_ghost->width = wta;
    target_ghost->height = hta;
    ghost_matrix->set_translate(xta,yta,z_ghost());

    ////////////////////////////////////////////
    /// scope : ////////////////////////////////
    ////////////////////////////////////////////
    float scope_rmx = 1.025f*scope_radius;
    inlib::sg::ring* ph_scope = 0;
   {inlib::sg::separator* _sep = new inlib::sg::separator;
    sep.add(_sep);
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = inlib::colorf::grey();
    _sep->add(mat);
    inlib::sg::matrix* m = new inlib::sg::matrix;
    m->set_translate(0,0,z_scope_cache_pastille());
    _sep->add(m);
    ph_scope = new inlib::sg::ring();
    ph_scope->rmin = scope_radius;
    ph_scope->rmax = scope_rmx;
    ph_scope->steps = steps();
    _sep->add(ph_scope);}

    ////////////////////////////////////////////
    /// cache : ////////////////////////////////
    ////////////////////////////////////////////
    inlib::sg::ring* ph_cache = 0;
   {inlib::sg::separator* _sep = new inlib::sg::separator;
    sep.add(_sep);
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = inlib::colorf(1,1,1,0.8f);
    _sep->add(mat);
    inlib::sg::matrix* m = new inlib::sg::matrix;
    m->set_translate(0,0,z_scope_cache_pastille());
    _sep->add(m);
    ph_cache = new inlib::sg::ring();
    ph_cache->rmin = scope_rmx;
    ph_cache->rmax = 10*scope_rmx;
    ph_cache->steps = steps();
    _sep->add(ph_cache);}

    ////////////////////////////////////////////
    /// pastille : /////////////////////////////
    ////////////////////////////////////////////
    inlib::sg::ring* ph_pastille = 0;
   {inlib::sg::separator* _sep = new inlib::sg::separator;
    sep.add(_sep);
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = inlib::colorf::grey();
    _sep->add(mat);
    inlib::sg::matrix* m = new inlib::sg::matrix;
    m->set_translate(0,0,z_scope_cache_pastille());
    _sep->add(m);
    ph_pastille = new inlib::sg::ring();   
    ph_pastille->rmin = pastille_radius*0.001f;
    ph_pastille->rmax = pastille_radius;
    ph_pastille->steps = steps();
    _sep->add(ph_pastille);}

    ////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////

   {main_cbk* _cbk = new main_cbk(a_gv,action_scope_adjust());
    _cbk->m_scope_radius = scope_radius;
    _cbk->m_pastille_radius = pastille_radius;
    _cbk->m_tscp_matrix = tscp_matrix;
    _cbk->m_infos_text = infos_text;
    _cbk->m_infos_matrix = infos_matrix;
    _cbk->m_back_to_menu_button = back_to_menu_button;
    _cbk->m_back_to_menu_matrix = back_to_menu_matrix;
    dpt->add_callback(_cbk);}

    a_gv.set_scene_camera(camera);
    a_gv.set_scene_light(light);

    a_gv.hide_main_menu();

    ////////////////////////////////
    /// sliders : //////////////////
    ////////////////////////////////
   {a_gv.set_sliders_pos(inlib::sg::gui_params::s_sliders_l());

    params prms;
    prms.m_blason = a_blason;
    prms.m_diamScope = a_diamScope;
    prms.m_dsoe = a_dsoe;
    prms.m_dCible = a_dCible;
    prms.m_dioptrie = a_dioptrie;
    prms.m_diamPastille = a_diamPastille;
    prms.m_slider_dist_min = a_slider_dist_min;
    prms.m_slider_dist_max = a_slider_dist_max;

    //horizontal slider : scope size :
/*
   {inlib::sg::slider& sld = a_gv.slider_1();
    sld.value = 0.5f;
    sld.clear_cbks();
    sld.add_drag_callback
      (new slider_cbk(a_gv,sld,*ph_scope,*ph_pastille,prms,0));}
*/

    //vertical slider : distance :     
   {inlib::sg::slider& sld = a_gv.slider_3();
    sld.value =
      (a_dCible-a_slider_dist_min)/(a_slider_dist_max-a_slider_dist_min);
    sld.clear_cbks();
    sld.add_begin_callback
      (new slider_cbk(a_gv,sld,*ph_scope,*ph_cache,*ph_pastille,*dpt,
                      *tscp_matrix,*infos_text,*infos_matrix,
                      *back_to_menu_button,*back_to_menu_matrix,
                      prms,0));
    sld.add_drag_callback
      (new slider_cbk(a_gv,sld,*ph_scope,*ph_cache,*ph_pastille,*dpt,
                      *tscp_matrix,*infos_text,*infos_matrix,
                      *back_to_menu_button,*back_to_menu_matrix,
                      prms,1));
    sld.add_end_callback
      (new slider_cbk(a_gv,sld,*ph_scope,*ph_cache,*ph_pastille,*dpt,
                      *tscp_matrix,*infos_text,*infos_matrix,
                      *back_to_menu_button,*back_to_menu_matrix,
                      prms,2));}

    a_gv.show_sliders();}

  }

  static bool scope_proj(double a_diamScope, //in meter
                         double a_dsoe,      //in meter
                         double a_dCible,    //in meter
                         double a_dioptrie,  //in 1/meter
                         double& a_value) {  //in meter

    /* JEC mathematica formula :
    DiamBlason[d2, dv, d1, dsoe, dCible, diamScope] := (
      dCible diamScope)/(
      dsoe Abs[dCible/(
        dCible - d1 dCible dsoe + d1 dsoe^2 + 
          d2 (dsoe - dv) (dCible + dv - d1 dCible dv + dsoe (-1 + d1 dv)))])
    */

    double d2 = 0;
    double dv = 0;

    double tmp_1  =
      a_dCible - a_dioptrie*a_dCible*a_dsoe + a_dioptrie*a_dsoe*a_dsoe + 
      d2 * (a_dsoe - dv) *
      (a_dCible + dv - a_dioptrie*a_dCible*dv + a_dsoe*(-1.0 + a_dioptrie*dv));

    if(!tmp_1) {a_value=0;return false;}

    double tmp_2 = a_dsoe * ::fabs(a_dCible/tmp_1);
    if(!tmp_2) {a_value=0;return false;}

    a_value = (a_dCible * a_diamScope)/tmp_2;

    return true;
  }

/*
  static double in2m() {return 0.0254;}

  static double sight_chart(double a_doesco,
                            double a_hoenock,
                            double a_qpDegree,
                            double a_v0, 
                            double a_auTomm,
                            double a_xF) {
    double g = 9.81; //(acceleration pesanteur en m/s^2)
    double xFmax = (0.09290340576035999*::pow(a_v0,2.0))/g;
    // (transformation Deg -> Rad, le "-" pour se caler
    // avec la convention interne)
    double qp = -0.017453292519943295*a_qpDegree;
    double hoenock = in2m()*a_hoenock; //(tranformation inch -> m)
    double tan0 = (4*xFmax*::cos(qp)*(a_xF*::cos(qp) - 3*hoenock*::sin(qp)) - 
                 2*::sqrt(::cos(qp)*::pow(a_xF*::cos(qp) - hoenock*::sin(qp),2)*
                 (-12*hoenock*xFmax - (::pow(hoenock,2.0) + 3*::pow(a_xF,2.0) - 
                 4*::pow(xFmax,2.0))*::cos(qp) + 4*hoenock*xFmax*::cos(2*qp) + 
                 (hoenock - a_xF)*(hoenock + a_xF)*::cos(3*qp) + 
                 2*hoenock*a_xF*::sin(qp) + 4*a_xF*xFmax*::sin(2*qp) + 
                 2*hoenock*a_xF*::sin(3*qp))))/
        (8*hoenock*xFmax + (::pow(hoenock,2.0) + 3*::pow(a_xF,2.0))*::cos(qp) - 
         8*hoenock*xFmax*::cos(2*qp) + 
         (-::pow(hoenock,2.0) + ::pow(a_xF,2.0))*::cos(3*qp)
          - 2*hoenock*a_xF*::sin(qp) - 4*a_xF*xFmax*::sin(2*qp)
          - 2*hoenock*a_xF*::sin(3*qp));

    //transformation mm->unite arbitraire du viseur
    double doesco = in2m()*a_doesco;
    double mark = -doesco * tan0 * 1000;
    return mark*a_auTomm;
  }
*/

  static double Power(double a_x,double a_y) {return ::pow(a_x,a_y);}
  static double Cos(double a_x) {return ::cos(a_x);}
  static double Sin(double a_x) {return ::sin(a_x);}
  static double Sqrt(double a_x) {return ::sqrt(a_x);}

  static double sight_chart(double doesco, double hoenock, double qpDegree, double v0, double auTomm, double xF) {
    double g = 9.81;  //(acceleration pesanteur en m/s^2)
    double xFmax = (0.09290340576035999*Power(v0,2))/g;
    // (transformation Deg -> Rad, le "-" pour se caler
    // avec la convention interne)
    double qp = -0.017453292519943295*qpDegree;
    hoenock *= 0.0254;                     //      (tranformation inch -> m)
    doesco *= 0.0254;
    double tan0 = (4*xFmax*Cos(qp)*(xF*Cos(qp) - 3*hoenock*Sin(qp)) - 
       2*Sqrt(Cos(qp)*Power(xF*Cos(qp) - hoenock*Sin(qp),2)*
       (-12*hoenock*xFmax - (Power(hoenock,2) + 3*Power(xF,2) - 
       4*Power(xFmax,2))*Cos(qp) + 4*hoenock*xFmax*Cos(2*qp) + 
       (hoenock - xF)*(hoenock + xF)*Cos(3*qp) + 
       2*hoenock*xF*Sin(qp) + 4*xF*xFmax*Sin(2*qp) + 
       2*hoenock*xF*Sin(3*qp))))/
       (8*hoenock*xFmax + (Power(hoenock,2) + 3*Power(xF,2))*Cos(qp) - 
        8*hoenock*xFmax*Cos(2*qp) + 
       (-Power(hoenock,2) + Power(xF,2))*Cos(3*qp) - 2*hoenock*xF*Sin(qp) - 
        4*xF*xFmax*Sin(2*qp) - 2*hoenock*xF*Sin(3*qp));
    //transformation mm->unite arbitraire du viseur
    double mark = -doesco * tan0 * 1000;
    return mark*auTomm;
  }	

  class archery_func {  
  public:
    bool in_domain(double) const {return true;}
    double value(double a_dsoe) const { //dsoe is in meter.
      double value;
      if(!scope_proj(m_diamScope,a_dsoe,m_dCible,m_dioptrie,value)) return 0;
      return value/0.01; //returned value in cm.
    }
  public:
    archery_func(double a_dCible,double a_diamScope,double a_dioptrie)
    :m_dCible(a_dCible)
    ,m_diamScope(a_diamScope)
    ,m_dioptrie(a_dioptrie)
    {}
    virtual ~archery_func(){}
  public:
    archery_func(const archery_func& a_from)
    :m_dCible(a_from.m_dCible)
    ,m_diamScope(a_from.m_diamScope)
    ,m_dioptrie(a_from.m_dioptrie)
    {}
    archery_func& operator=(const archery_func& a_from) {
      m_dCible = a_from.m_dCible;
      m_diamScope = a_from.m_diamScope;
      m_dioptrie = a_from.m_dioptrie;
      return *this;
    }
  protected: 
    double m_dCible;
    double m_diamScope;
    double m_dioptrie;
  };


/*
  static void exa_archery_plot_(inlib::sg::gui_viewer& a_gv,
                                const inlib::args& a_opts) {


    double dioptrie;
    if(!a_opts.find(s_dioptrie(),dioptrie)) dioptrie  = 0.75;

    double dCible;
    if(!a_opts.find(s_dist_cible(),dCible)) dCible = 50;

    double diamScope;
    if(!a_opts.find(s_diam_scope(),diamScope)) diamScope = 29;
    diamScope *= 0.001; //now in meter

    archery_func func(dCible,diamScope,dioptrie);

    ///////////////////////////////////
    /// plot : ////////////////////////
    ///////////////////////////////////

    inlib::sg::plots* plots = a_gv.evd_get_plots();

    plots->set_regions(1,1);

    inlib::sg::plotter& plotter = plots->current_plotter();
    plotter.clear();
    a_gv.style_from_res(a_gv.s_default(),plotter);

    plotter.add_plottable(new inlib::sg::f1d2plot_cp<archery_func>(func));

    plotter.title_automated = false;
    inlib::sprintf(plotter.title.value(),256,"Target at %g m",dCible);
    plotter.title_style().color = inlib::colorf::blue();
    plotter.title_style().font = inlib::sg::font_arialbd_ttf();
    plotter.title_style().front_face = inlib::sg::winding_cw;

    plotter.x_axis_automated = false;
    plotter.x_axis_min = 0.7; //m
    plotter.x_axis_max = 0.9; //m

  //plotter.y_axis_automated = false;
  //plotter.y_axis_min = 0;
  //plotter.y_axis_max = 100; //cm

    plotter.x_axis().title = "Scope-Eye (m)";

    inlib::sprintf(plotter.y_axis().title.value(),256,
      "Seen target (cm)-scope of %g mm",diamScope/0.001);

    plotter.func_style(0).color = inlib::colorf::blue();

    plotter.x_axis().ticks_style().color = inlib::colorf::blue();
    plotter.x_axis().labels_style().color = inlib::colorf::blue();
    plotter.x_axis().labels_style().font = inlib::sg::font_arialbd_ttf();
    plotter.x_axis().labels_style().front_face = inlib::sg::winding_cw;

    plotter.x_axis().title_style().color = inlib::colorf::blue();
    plotter.x_axis().title_style().font = inlib::sg::font_arialbd_ttf();
    plotter.x_axis().title_style().front_face = inlib::sg::winding_cw;
    plotter.x_axis().title_hjust = inlib::sg::center;

    plotter.y_axis().ticks_style().color = inlib::colorf::blue();
    plotter.y_axis().labels_style().color = inlib::colorf::blue();
    plotter.y_axis().labels_style().font = inlib::sg::font_arialbd_ttf();
    plotter.y_axis().labels_style().front_face = inlib::sg::winding_cw;

    plotter.y_axis().title_style().color = inlib::colorf::blue();
    plotter.y_axis().title_style().font = inlib::sg::font_arialbd_ttf();
    plotter.y_axis().title_style().front_face = inlib::sg::winding_cw;
    plotter.y_axis().title_hjust = inlib::sg::center;

    a_gv.hide_main_menu();
  }
*/

  static void rep_rings(inlib::sg::group& a_parent,
                        float a_back_sz,
                        unsigned int a_nring,
                        float a_wring,
                        const std::vector<inlib::colorf>& a_cols,
                        unsigned int a_num_center,
                        float a_hchar,
                        bool a_is_wall_screen_app) {

    if(a_back_sz) { //back :
      inlib::sg::separator* _sep = new inlib::sg::separator;
      a_parent.add(_sep);
      inlib::sg::rgba* mat = new inlib::sg::rgba();
      mat->color = inlib::colorf::white();
      _sep->add(mat);
      inlib::sg::matrix* m = new inlib::sg::matrix;
      m->set_translate(0,0,z_back());
      _sep->add(m);
      inlib::sg::cube* node = new inlib::sg::cube();   
      node->width = a_back_sz;
      node->height = a_back_sz;
      node->depth = 0.01f;
      _sep->add(node);
    }

    typedef std::pair<float,float> rmn_mx;
    std::vector<rmn_mx> rmn_mxs(a_nring);
   {for(unsigned int i=0;i<a_nring;i++) rmn_mxs[i] = rmn_mx(i*a_wring,(i+1)*a_wring);}

    ////////////////////////////////////////////
    /// rings : ////////////////////////////////
    ////////////////////////////////////////////

   {for(unsigned int i=0;i<a_nring;i++) {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      a_parent.add(_sep);
      inlib::sg::rgba* mat = new inlib::sg::rgba();
      mat->color = a_cols[i];
      _sep->add(mat);

      inlib::sg::matrix* m = new inlib::sg::matrix;
      m->set_translate(0,0,z_rings());
      _sep->add(m);

      inlib::sg::ring* node = new inlib::sg::ring();   
      node->rmin = rmn_mxs[i].first;
      node->rmax = rmn_mxs[i].second;
      node->steps = steps();
      _sep->add(node);
    }}

    ///////////////////////////////////////////////
    /// inner "reduced" border : //////////////////
    ///////////////////////////////////////////////
    {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      a_parent.add(_sep);
      inlib::sg::rgba* mat = new inlib::sg::rgba();
      mat->color = inlib::colorf::black();
      _sep->add(mat);
      inlib::sg::draw_style* ds = new inlib::sg::draw_style;
      ds->style = inlib::sg::draw_style::lines;
      ds->line_width = a_is_wall_screen_app?5:1;
      _sep->add(ds);
      inlib::sg::matrix* m = new inlib::sg::matrix;
      m->set_translate(0,0,z_borders());
      _sep->add(m);
      inlib::sg::circle* node = new inlib::sg::circle();   
      node->radius = a_wring*0.5f;
      node->steps = steps();
      _sep->add(node);
    }

    ///////////////////////////////////////////////
    /// borders ( = outside circle of a ring) : ///
    ///////////////////////////////////////////////
   {for(unsigned int i=0;i<a_nring;i++) {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      a_parent.add(_sep);
      inlib::sg::rgba* mat = new inlib::sg::rgba();
      if((a_cols[i]==inlib::colorf::black()) &&
         (a_cols[i+1]==inlib::colorf::black()) ){
        mat->color = inlib::colorf::white();
      } else {
        mat->color = inlib::colorf::black();
      }
      _sep->add(mat);
      inlib::sg::draw_style* ds = new inlib::sg::draw_style;
      ds->style = inlib::sg::draw_style::lines;
      ds->line_width = a_is_wall_screen_app?5:1;
      _sep->add(ds);
      inlib::sg::matrix* m = new inlib::sg::matrix;
      m->set_translate(0,0,z_borders());
      _sep->add(m);
      inlib::sg::circle* node = new inlib::sg::circle();   
      node->radius = rmn_mxs[i].second;
      node->steps = steps();
      _sep->add(node);
    }}

    ////////////////////////////////////////////
    /// numbers : //////////////////////////////
    ////////////////////////////////////////////
   {for(unsigned int i=0;i<a_nring;i++) {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      a_parent.add(_sep);
      inlib::sg::rgba* mat = new inlib::sg::rgba();
      mat->color = inlib::colorf::lightgrey();
      _sep->add(mat);
      inlib::sg::matrix* m = new inlib::sg::matrix;
      float xnum = (rmn_mxs[i].first+rmn_mxs[i].second)*0.5f;
      m->set_translate(xnum,0,z_numbers());
      _sep->add(m);
      exlib::sg::text_freetype* node = new exlib::sg::text_freetype();
      node->font = inlib::sg::font_helvetica_ttf();
      node->front_face = inlib::sg::winding_cw;
      node->hjust = inlib::sg::center;
      node->vjust = inlib::sg::middle;
      node->height = a_hchar;
      std::string snum = inlib::to(a_num_center-i);
      node->strings.set_value(snum);
      _sep->add(node);
    }}

   {inlib::sg::group* _sep = &a_parent; //trailing sg.
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = inlib::colorf::black();
    _sep->add(mat);
    inlib::sg::draw_style* ds = new inlib::sg::draw_style;
    ds->style = inlib::sg::draw_style::lines;
    ds->line_width = a_is_wall_screen_app?5:1;
    _sep->add(ds);
    inlib::sg::vertices* node = new inlib::sg::vertices;
    node->mode = inlib::gl::lines(); //segments
    node->add(-1, 0,z_cross());
    node->add( 1, 0,z_cross());
    node->add( 0,-1,z_cross());
    node->add( 0, 1,z_cross());
    _sep->add(node);}

  }

  static void rep_nature(std::ostream& a_out,
                         const std::string& a_res_dir,
                         inlib::sg::group& a_parent,
                         const std::string& a_file,double a_h,
                         bool a_is_wall_screen_app) {

    std::string path = a_res_dir;
    path += inlib::sep();
    path += a_file;

    unsigned int w,h,bpp;
    unsigned char* buffer = exlib::jpeg::read(a_out,path,w,h,bpp);
    if(!buffer) {
      a_out << "rep_nature :"
            << " can't read file."
            << std::endl;
      return;
    }
    if(bpp!=3) {
      a_out << "rep_natue :"
            << " bpp not 3."
            << std::endl;
      return;
    }

    inlib::sg::separator* _sep = new inlib::sg::separator;
    a_parent.add(_sep);

    //inlib::sg::matrix* mtx = new inlib::sg::matrix;
    //_sep->add(mtx);

    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = inlib::colorf::white();
    _sep->add(mat);

    _sep->add(new inlib::sg::normal);

    inlib::sg::tex_rect* node = new inlib::sg::tex_rect();
    //tex_rect* node = new tex_rect(*mtx);
    node->img.value().set(w,h,bpp,buffer,true);
    node->height = a_h;
    node->expand = true;

    _sep->add(node);
  }

protected:
  static double FOC_dm(double a_old,double a_new,double a_mass){
    return ((a_new - a_old)/(50 - a_new)) * a_mass;
  }

  static double FOC_LA(double a_L,double a_A){
    return 100*(a_A/a_L-0.5);
  }

  static void FOC_full(double a_m_Pt,double a_rho_T,
                       double a_L_T,double a_m_PL,
                       double a_m_W,double a_m_B,
                       double a_m_Pn,double a_m_N,
                       double& a_m_Tot,double& a_FOC) {
    double m_Tube = a_rho_T*a_L_T;
    double m_Ntot = a_m_PL + a_m_W + a_m_B + a_m_Pn + a_m_N;
    a_m_Tot = a_m_Pt + m_Tube + m_Ntot;
    a_FOC = 100 * 0.5 * (a_m_Pt-m_Ntot)/a_m_Tot;
  }

  static void adjust_tscp_matrix(inlib::sg::matrix& a_mtx,
                                 float a_wcam,float a_hcam,
                                 float a_scope_radius) {
    float aspect = float(a_wcam)/float(a_hcam);
    float object_size = adjust_factor()*2*a_scope_radius;
    float scale = (aspect>1?a_hcam:a_wcam)/object_size;
    a_mtx.set_scale(scale,scale,1);
  }

  static void adjust_infos(exlib::sg::text_freetype& a_text,
                           inlib::sg::matrix& a_matrix, 
                           float a_wcam,float a_hcam) {  
    float htext = a_text.height;

    float mn_x,mn_y,mn_z;
    float mx_x,mx_y,mx_z;
    a_text.get_bounds(htext,mn_x,mn_y,mn_z,mx_x,mx_y,mx_z);
    float th = mx_y-mn_y;
    if(th>0) {
      // th -> htext
      // x -> x*htext/th
      htext = 0.07f*a_hcam*htext/th;
      a_text.height = htext;
    }
    a_matrix.set_translate(-a_wcam*0.5f,a_hcam*0.5f,z_infos_back_menu());
  }

  static void adjust_back_to_menu(inlib::sg::image_button& a_button,
                                  inlib::sg::matrix& a_matrix,
                                  float a_wcam,float a_hcam) {  
    a_button.height = a_hcam*0.1f;
    a_button.width = a_button.height;
    a_matrix.set_translate(-a_wcam*0.5f+a_button.width*0.5f,
                           -a_hcam*0.5f+a_button.height*0.5f,
                           z_infos_back_menu());
  }

  class params {
  public:
    params()
    :m_blason(s_indoor_80())
    ,m_diamScope(0.029)
    ,m_dsoe(0.8)
    ,m_dCible(50)
    ,m_dioptrie(0.75)
    ,m_diamPastille(0.002)
    ,m_slider_dist_min(10)
    ,m_slider_dist_max(80)
    {}
    params(const params& a_from)
    :m_blason(a_from.m_blason)
    ,m_diamScope(a_from.m_diamScope)
    ,m_dsoe(a_from.m_dsoe)
    ,m_dCible(a_from.m_dCible)
    ,m_dioptrie(a_from.m_dioptrie)
    ,m_diamPastille(a_from.m_diamPastille)
    ,m_slider_dist_min(a_from.m_slider_dist_min)
    ,m_slider_dist_max(a_from.m_slider_dist_max)
    {}
    params& operator=(const params& a_from){
      m_blason = a_from.m_blason;
      m_diamScope = a_from.m_diamScope;
      m_dsoe = a_from.m_dsoe;
      m_dCible = a_from.m_dCible;
      m_dioptrie = a_from.m_dioptrie;
      m_diamPastille = a_from.m_diamPastille;
      m_slider_dist_min = a_from.m_slider_dist_min;
      m_slider_dist_max = a_from.m_slider_dist_max;
      return *this;
    }
  public:
    std::string m_blason;
    double m_diamScope;
    double m_dsoe;
    double m_dCible;
    double m_dioptrie;
    double m_diamPastille;
    double m_slider_dist_min;
    double m_slider_dist_max;
  } m_params;

  class slider_cbk : public inlib::sg::acbk {
    INLIB_CBK(slider_cbk,ArcheryTune::main_cbk::slider_cbk,inlib::sg::acbk)
  public:
    virtual return_action action() {
             if(m_action==0) { //begin : pass infos_text in outline.
        m_infos_text.modeling = inlib::sg::font_outline;

      } else if(m_action==2) { //end : pass infos_text in outline.
        m_infos_text.modeling = inlib::sg::font_filled;
 
      } else if(m_action==1) { //distance cible

        double dv = m_params.m_slider_dist_max-m_params.m_slider_dist_min;
        double v = m_params.m_slider_dist_min+dv*m_slider.value.value();
        m_params.m_dCible = v;

        double scope_proj_diam; //in meter
        if(!scope_proj(m_params.m_diamScope,
                       m_params.m_dsoe,
                       m_params.m_dCible,
                       m_params.m_dioptrie,scope_proj_diam)||
          (scope_proj_diam<=0)){
          return return_to_render;
        }
        scope_proj_diam *= 100; //now in cm.

        double pastille_proj_diam; //in meter
        if(!scope_proj(m_params.m_diamPastille,
                       m_params.m_dsoe,
                       m_params.m_dCible,
                       m_params.m_dioptrie,pastille_proj_diam)||
          (pastille_proj_diam<=0)){
          return return_to_render;
        }
        pastille_proj_diam *= 100; //now in cm.

       {std::string s;
        inlib::sprintf(s,128,"%.1f m  %.1f cm",
          m_params.m_dCible,scope_proj_diam);
        m_infos_text.strings.set_value(s);}
      
        float scope_radius = 0.5f*float(scope_proj_diam);
        float pastille_radius = 0.5f*float(pastille_proj_diam);

        float scope_rmx = 1.025f*scope_radius;
        m_scope.rmin = scope_radius;
        m_scope.rmax = scope_rmx;

        m_cache.rmin = scope_rmx;
        m_cache.rmax = 10*scope_rmx;

        m_pastille.rmin = pastille_radius*0.001f;
        m_pastille.rmax = pastille_radius;

       {unsigned int ww = m_gv.width();
        unsigned int wh = m_gv.height();
        float hcam = 2;
        float wcam = hcam*float(ww)/float(wh);
        adjust_tscp_matrix(m_tscp_matrix,wcam,hcam,scope_radius);}

        main_cbk* _cbk = new main_cbk(m_gv,action_scope_adjust());
        _cbk->m_scope_radius = scope_radius;
        _cbk->m_pastille_radius = pastille_radius;
        _cbk->m_tscp_matrix = &m_tscp_matrix;
        _cbk->m_infos_text = &m_infos_text;
        _cbk->m_infos_matrix = &m_infos_matrix;
        _cbk->m_back_to_menu_button = &m_back_to_menu_button;
        _cbk->m_back_to_menu_matrix = &m_back_to_menu_matrix;
        m_dpt.clear_cbks();
        m_dpt.add_callback(_cbk);

      }
      return return_to_render;
    }
  public:
    slider_cbk(inlib::sg::gui_viewer& a_gv,
               inlib::sg::slider& a_slider,
               inlib::sg::ring& a_scope,
               inlib::sg::ring& a_cache,
               inlib::sg::ring& a_pastille,
               inlib::sg::event_dispatcher& a_dpt,
               inlib::sg::matrix& a_tscp_matrix,
               exlib::sg::text_freetype& a_infos_text,
               inlib::sg::matrix& a_infos_matrix,
               inlib::sg::image_button& a_back_to_menu_button,
               inlib::sg::matrix& a_back_to_menu_matrix,
               const params& a_params,
               unsigned int a_action)
    :parent(a_action)
    ,m_gv(a_gv)
    ,m_slider(a_slider)
    ,m_scope(a_scope)
    ,m_cache(a_cache)
    ,m_pastille(a_pastille)
    ,m_dpt(a_dpt)
    ,m_tscp_matrix(a_tscp_matrix)
    ,m_infos_text(a_infos_text)
    ,m_infos_matrix(a_infos_matrix)
    ,m_back_to_menu_button(a_back_to_menu_button)
    ,m_back_to_menu_matrix(a_back_to_menu_matrix)
    ,m_params(a_params)
    {}
    virtual ~slider_cbk(){}
  public:
    slider_cbk(const slider_cbk& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    ,m_slider(a_from.m_slider)
    ,m_scope(a_from.m_scope)
    ,m_cache(a_from.m_cache)
    ,m_pastille(a_from.m_pastille)
    ,m_dpt(a_from.m_dpt)
    ,m_tscp_matrix(a_from.m_tscp_matrix)
    ,m_infos_text(a_from.m_infos_text)
    ,m_infos_matrix(a_from.m_infos_matrix)
    ,m_back_to_menu_button(a_from.m_back_to_menu_button)
    ,m_back_to_menu_matrix(a_from.m_back_to_menu_matrix)
    ,m_params(a_from.m_params)
    {}
    slider_cbk& operator=(const slider_cbk& a_from){
      parent::operator=(a_from);
      m_params = a_from.m_params;
      return *this;
    }
  protected:
    inlib::sg::gui_viewer& m_gv;
    inlib::sg::slider& m_slider;
    inlib::sg::ring& m_scope;
    inlib::sg::ring& m_cache;
    inlib::sg::ring& m_pastille;
    inlib::sg::event_dispatcher& m_dpt;
    inlib::sg::matrix& m_tscp_matrix;
    exlib::sg::text_freetype& m_infos_text;
    inlib::sg::matrix& m_infos_matrix;
    inlib::sg::image_button& m_back_to_menu_button;
    inlib::sg::matrix& m_back_to_menu_matrix;
    params m_params;
  };

/*
  class tex_rect : public inlib::sg::tex_rect {
    INLIB_NODE(tex_rect,ArcheryTune::main_cbk::tex_rect,inlib::sg::tex_rect)
  public:
    virtual void event(inlib::sg::event_action& a_action) {

      if(inlib::sg::move_event* mevt =
          inlib::safe_cast<inlib::sg::event,inlib::sg::move_event>
            (a_action.get_event())) {

        const inlib::sg::state& state = a_action.state();

        float x,y,z;
        if(!state.screen2wc(mevt->x(),mevt->y(),x,y,z)) return;

        float aspect = float(img.value().width())/float(img.value().height());
        float h2 = height*0.5f;
        float w2 = aspect*h2;

        if((y<-h2)||(h2<y)) return;
        if((x<-w2)||(w2<x)) return;

        inlib::vec3f dmevt(float(mevt->x())-float(mevt->ox()),
                           float(mevt->y())-float(mevt->oy()),0);
        float win_diag = 
          inlib::fsqrt(float(state.m_ww)*float(state.m_ww)+
                       float(state.m_wh)*float(state.m_wh));
        float mevt_fac = dmevt.length()/win_diag;

        float tfac = 3; //pure cooking.

        inlib::vec3f u(dmevt[0],dmevt[1],0);
        u.normalize();
        u *= height.value() * mevt_fac * tfac;

        m_matrix.mul_translate(u.x(),u.y(),u.z());

        a_action.set_done(true); //trigger a render in m_gv.touch_move()
      }
    }
  public:
    tex_rect(inlib::sg::matrix& a_matrix)
    :parent()
    ,m_matrix(a_matrix)
    {}
    virtual ~tex_rect(){}
  protected:
    tex_rect(const tex_rect& a_from)
    :parent(a_from)
    ,m_matrix(a_from.m_matrix)
    {}
    tex_rect& operator=(const tex_rect& a_from){
      parent::operator=(a_from);
      return *this;
    }
  protected:
    inlib::sg::matrix& m_matrix;
  };
*/

  class ghost : public inlib::sg::ghost {
    INLIB_NODE(ghost,ArcheryTune::main_cbk::ghost,inlib::sg::ghost)
  public:
    virtual void event(inlib::sg::event_action& a_action) {
      if(inlib::sg::move_event* mevt = inlib::safe_cast<inlib::sg::event,inlib::sg::move_event>(a_action.get_event())) {

        const inlib::sg::state& state = a_action.state();

        float x,y,z;
        if(!state.screen2wc(mevt->x(),mevt->y(),x,y,z)) return;

        float h2 = height*0.5f;
        float w2 = width*0.5f;

        if((y<-h2)||(h2<y)) return;
        if((x<-w2)||(w2<x)) return;

        inlib::vec3f dmevt(float(mevt->x())-float(mevt->ox()),
                           float(mevt->y())-float(mevt->oy()),0);
        float win_diag = 
          inlib::fsqrt(float(state.m_ww)*float(state.m_ww)+
                       float(state.m_wh)*float(state.m_wh));
        float mevt_fac = dmevt.length()/win_diag;

        float tfac = 3; //pure cooking.

        inlib::vec3f u(dmevt[0],dmevt[1],0);
        u.normalize();
        u *= height.value() * mevt_fac * tfac;

        m_matrix.mul_translate(u.x(),u.y(),u.z());

        a_action.set_done(true); //trigger a render in m_gv.touch_move()
      }
    }
  public:
    ghost(inlib::sg::matrix& a_matrix):parent(),m_matrix(a_matrix){}
    virtual ~ghost(){}
  protected:
    ghost(const ghost& a_from):parent(a_from),m_matrix(a_from.m_matrix){}
    ghost& operator=(const ghost& a_from){parent::operator=(a_from);return *this;}
  protected:
    inlib::sg::matrix& m_matrix;
  };

/*
  class up_cbk : public inlib::sg::ecbk {
    INLIB_CBK(up_cbk,ArcheryTune::main_cbk::up_cbk,inlib::sg::ecbk)
  public:
    virtual return_action action() {
      inlib::cbk::move_manip::toggle_manip(m_gv,m_gv.out(),m_gv.scene(),
                                           m_node,m_gv.verbose());
      inlib::sg::cube_manip* cm =
        inlib::cbk::move_manip::is_maniped
          (m_gv.out(),m_gv.scene(),m_node,m_gv.verbose());
      if(cm) {
        //cm->shape_mask = inlib::sg::cube_manip::shape_translate_xy();
        cm->shape_mask =
          inlib::sg::cube_manip::shape_rotate_x()|
          inlib::sg::cube_manip::shape_rotate_y();
      }
      return return_none;     
    }
  public:
    up_cbk(inlib::sg::gui_viewer& a_gv)
    :parent(0)
    ,m_gv(a_gv)
    {}
    virtual ~up_cbk(){}
  protected:
    up_cbk(const up_cbk& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    {}
    up_cbk& operator=(const up_cbk& a_from){
      parent::operator=(a_from);
      return *this;
    }
  protected:
    inlib::sg::gui_viewer& m_gv;
  };
*/
protected:
  void _map_warn(const std::string& a_s) {
    m_entries->label = a_s;
    m_entries->label_back_color = inlib::colorf::salmon();
    //m_gv.map_warn(a_s);
  }

protected:
  inlib::sg::gui_viewer& m_gv;
  inlib::sg::entries* m_entries;
  float m_scope_radius;
  float m_pastille_radius;
  std::vector<std::string> m_sparams;
  double m_slider_dist_min;
  double m_slider_dist_max;
  inlib::sg::matrix* m_tscp_matrix;
  exlib::sg::text_freetype* m_infos_text;
  inlib::sg::matrix* m_infos_matrix;
  inlib::sg::image_button* m_back_to_menu_button;
  inlib::sg::matrix* m_back_to_menu_matrix;
};

}

#endif
