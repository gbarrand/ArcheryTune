// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_entries
#define inlib_sg_entries

// A panel of entries with an ok button.

#include "base_list"
#include "_switch"

#include "entry"
#include "numeric"
#include "keyboard"
#include "colors"
#include "edvalop"
#include "file_chooser"

#include "../entries_color"
#include "../valop2s"

namespace inlib {
namespace sg {

class entries : public base_list {
public:
  INLIB_NODE(entries,inlib::sg::entries,base_list)
public:
  enum entry_type {
    entry_uint,
    entry_int,
    entry_real,
    entry_range,
    entry_ip,
    entry_string,
    entry_bool,
    entry_color,
    entry_math,
    entry_file,
    entry_opts,
    entry_not_editable
  };
public:
  sf<float> text_wmargin_factor;
  sf<float> text_hmargin_factor;
  mf_string labels;
  mf_enum<entry_type> types;
  mf_std_vec<std::string> opts;
  mf_string values; //output

  sf<float> numeric_width;
  sf<float> numeric_height;
  sf<float> keyboard_width;
  sf<float> keyboard_height;
  sf<float> colors_width;
  sf<float> colors_height;
  sf<float> edvalop_width;
  sf<float> edvalop_height;
  sf<float> file_chooser_width;
  sf<float> file_chooser_height;
  sf<float> list_width;
  sf<float> list_height;
  sf<float> list_scroll_width;
  sf<unsigned int> list_visible_items;
  sf<float> entry_label_result_factor;
  sf_vec<colorf,float> labels_back_color;
  sf_vec<colorf,float> shown_label_color;
public:
  virtual const std::vector<field_desc>& node_fields() const {
    static std::vector<field_desc> s_v;
    if(s_v.empty()) {
      s_v = parent::node_fields();
      INLIB_ADD_FIELD_DESC(text_wmargin_factor)
      INLIB_ADD_FIELD_DESC(text_hmargin_factor)
      INLIB_ADD_FIELD_DESC(labels)
      INLIB_ADD_FIELD_DESC(types)
      INLIB_ADD_FIELD_DESC(opts)
      INLIB_ADD_FIELD_DESC(values)
      INLIB_ADD_FIELD_DESC(numeric_width)
      INLIB_ADD_FIELD_DESC(numeric_height)
      INLIB_ADD_FIELD_DESC(keyboard_width)
      INLIB_ADD_FIELD_DESC(keyboard_height)
      INLIB_ADD_FIELD_DESC(colors_width)
      INLIB_ADD_FIELD_DESC(colors_height)
      INLIB_ADD_FIELD_DESC(edvalop_width)
      INLIB_ADD_FIELD_DESC(edvalop_height)
      INLIB_ADD_FIELD_DESC(file_chooser_width)
      INLIB_ADD_FIELD_DESC(file_chooser_height)
      INLIB_ADD_FIELD_DESC(list_width)
      INLIB_ADD_FIELD_DESC(list_height)
      INLIB_ADD_FIELD_DESC(list_scroll_width)
      INLIB_ADD_FIELD_DESC(list_visible_items)
      INLIB_ADD_FIELD_DESC(entry_label_result_factor)
      INLIB_ADD_FIELD_DESC(labels_back_color)
      INLIB_ADD_FIELD_DESC(shown_label_color)
    }
    return s_v;
  }
private:
  void add_fields(){
    add_field(&text_wmargin_factor);
    add_field(&text_hmargin_factor);
    add_field(&labels);
    add_field(&types);
    add_field(&opts);
    add_field(&values);
    add_field(&numeric_width);
    add_field(&numeric_height);
    add_field(&keyboard_width);
    add_field(&keyboard_height);
    add_field(&colors_width);
    add_field(&colors_height);
    add_field(&edvalop_width);
    add_field(&edvalop_height);
    add_field(&file_chooser_width);
    add_field(&file_chooser_height);
    add_field(&list_width);
    add_field(&list_height);
    add_field(&list_scroll_width);
    add_field(&list_visible_items);
    add_field(&entry_label_result_factor);
    add_field(&labels_back_color);
    add_field(&shown_label_color);
  }
public:
  virtual void render(render_action& a_action) {
    if(touched()) {
      update_sg(a_action.out());
      reset_touched();
    }
    m_switch.render(a_action);
  }
  virtual void pick(pick_action& a_action) {
    if(touched()) {
      update_sg(a_action.out());
      reset_touched();
    }
    m_switch.pick(a_action);
    if(a_action.done()) return;
  }
  virtual void search(search_action& a_action) {
    node::search(a_action);
    if(a_action.done()) return;
    if(touched()) {
      update_sg(a_action.out());
      reset_touched();
    }
    m_switch.search(a_action);
    if(a_action.done()) return;
  }
public:
  entries(const base_freetype& a_ttf)
  :parent()

  ,text_wmargin_factor(0.9f)
  ,text_hmargin_factor(0.9f)
  ,labels()
  ,types()
  ,opts()
  ,values()
  ,numeric_width(1)
  ,numeric_height(1)
  ,keyboard_width(1)
  ,keyboard_height(1)
  ,colors_width(1)
  ,colors_height(1)
  ,edvalop_width(1)
  ,edvalop_height(1)
  ,file_chooser_width(1)
  ,file_chooser_height(1)
  ,list_width(1)
  ,list_height(1)
  ,list_scroll_width(0.2f)
  ,list_visible_items(5)
  ,entry_label_result_factor(0.6f)
  ,labels_back_color(colorf::white())
  ,shown_label_color(colorf::white())

  ,m_ttf(a_ttf)

  ,m_cbks()

  ,m_numeric(a_ttf)
  ,m_keyboard(a_ttf)
  ,m_colors(a_ttf)
  ,m_edvalop(a_ttf)
  ,m_file_chooser(a_ttf)

  ,m_active_index(-1)
  {
    add_fields();
    m_switch.which = WHICH_PANEL();
  }
  virtual ~entries(){}
public:
  entries(const entries& a_from)
  :parent(a_from)

  ,text_wmargin_factor(a_from.text_wmargin_factor)
  ,text_hmargin_factor(a_from.text_hmargin_factor)
  ,labels(a_from.labels)
  ,types(a_from.types)
  ,opts(a_from.opts)
  ,values(a_from.values)
  ,numeric_width(a_from.numeric_width)
  ,numeric_height(a_from.numeric_height)
  ,keyboard_width(a_from.keyboard_width)
  ,keyboard_height(a_from.keyboard_height)
  ,colors_width(a_from.colors_width)
  ,colors_height(a_from.colors_height) 
  ,edvalop_width(a_from.edvalop_width)
  ,edvalop_height(a_from.edvalop_height)
  ,file_chooser_width(a_from.file_chooser_width)
  ,file_chooser_height(a_from.file_chooser_height)
  ,list_width(a_from.list_width)
  ,list_height(a_from.list_height)
  ,list_scroll_width(a_from.list_scroll_width)
  ,list_visible_items(a_from.list_visible_items)
  ,entry_label_result_factor(a_from.entry_label_result_factor)
  ,labels_back_color(a_from.labels_back_color)
  ,shown_label_color(a_from.shown_label_color)

  ,m_ttf(a_from.m_ttf)

  ,m_cbks(a_from.m_cbks)

  ,m_numeric(m_ttf)
  ,m_keyboard(m_ttf)
  ,m_colors(m_ttf)
  ,m_edvalop(m_ttf)
  ,m_file_chooser(m_ttf)

  ,m_active_index(a_from.m_active_index)
  ,m_valops(a_from.m_valops)
  {
    add_fields();
    m_switch.which = a_from.m_switch.which;
  }
  entries& operator=(const entries& a_from){
    parent::operator=(a_from);

    text_wmargin_factor = a_from.text_wmargin_factor;
    text_hmargin_factor = a_from.text_hmargin_factor;
    labels = a_from.labels;
    types = a_from.types;
    opts = a_from.opts;
    values = a_from.values;
    numeric_width = a_from.numeric_width;
    numeric_height = a_from.numeric_height;
    keyboard_width = a_from.keyboard_width;
    keyboard_height = a_from.keyboard_height;
    colors_width = a_from.colors_width;
    colors_height = a_from.colors_height;
    edvalop_width = a_from.edvalop_width;
    edvalop_height = a_from.edvalop_height;
    file_chooser_width = a_from.file_chooser_width;
    file_chooser_height = a_from.file_chooser_height;
    list_width = a_from.list_width;
    list_height = a_from.list_height;
    list_scroll_width = a_from.list_scroll_width;
    list_visible_items = a_from.list_visible_items;
    entry_label_result_factor = a_from.entry_label_result_factor;
    labels_back_color = a_from.labels_back_color;
    shown_label_color = a_from.shown_label_color;

    m_cbks = a_from.m_cbks;

    m_switch.which = a_from.m_switch.which;
    m_active_index = a_from.m_active_index;

    m_valops = a_from.m_valops;

    return *this;
  }
public:
  void add_callback(bcbk* a_cbk) { //we take ownership of a_cbk
    m_cbks.add(a_cbk);
    touch();
  }
  void clear_cbks(){
    m_cbks.clear();
    touch();
  }
public:
  void add_generic(const std::string& a_label,
                   entry_type a_type,
                   const std::string& a_default,
                   const std::vector<std::string>& a_opts =
                   std::vector<std::string>()) {
    labels.add(a_label);
    types.add(a_type);
    values.add(a_default);
    opts.add(a_opts);
    m_valops.push_back(valop::def());
  }
  void add_float(const std::string& a_label,float a_default){
    labels.add(a_label);
    types.add(entry_real);
    values.add(to<float>(a_default));
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_double(const std::string& a_label,double a_default){
    labels.add(a_label);
    types.add(entry_real);
    values.add(to<double>(a_default));
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_range(const std::string& a_label,double a_default,
                 double a_min,double a_max){
    labels.add(a_label);
    types.add(entry_range);
    values.add(to<double>(a_default));
    std::vector<std::string> v;
    v.push_back(to<double>(a_min));
    v.push_back(to<double>(a_max));
    opts.add(v);
    m_valops.push_back(valop::def());
  }
  void add_uint(const std::string& a_label,unsigned int a_default){
    labels.add(a_label);
    types.add(entry_uint);
    values.add(to<unsigned int>(a_default));
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_int(const std::string& a_label,int a_default){
    labels.add(a_label);
    types.add(entry_int);
    values.add(to<int>(a_default));
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_bool(const std::string& a_label,bool a_default){
    labels.add(a_label);
    types.add(entry_bool);
    values.add(to(a_default));
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_string(const std::string& a_label,const std::string& a_default){
    labels.add(a_label);
    types.add(entry_string);
    values.add(a_default);
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_opts(const std::string& a_label,
                const std::string& a_default,
                const std::vector<std::string>& a_opts){
    labels.add(a_label);
    types.add(entry_opts);
    values.add(a_default);
    opts.add(a_opts);
    m_valops.push_back(valop::def());
  }
  void add_color(const std::string& a_label,const colorf& a_default){
    labels.add(a_label);
    types.add(entry_color);
    values.add(colorf::to(a_default));
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_color(const std::string& a_label,const std::string& a_default){
    labels.add(a_label);
    types.add(entry_color);
    values.add(a_default);
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_math(const std::string& a_label,const valop& a_default){
    labels.add(a_label);
    types.add(entry_math);
   {valop2s v;
    if(!v.visit(const_cast<valop&>(a_default))) {}
    values.add(v.m_s);}
    opts.add(std::vector<std::string>());
    m_valops.push_back(a_default);
  }
  void add_file(const std::string& a_label,const std::string& a_default){
    labels.add(a_label);
    types.add(entry_file);
    values.add(a_default);
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  void add_not_editable(const std::string& a_label,
                        const std::string& a_default){
    labels.add(a_label);
    types.add(entry_not_editable);
    values.add(a_default);
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }
  template <class T>
  void add_not_editable(const std::string& a_label,
                        const T& a_default){
    labels.add(a_label);
    types.add(entry_not_editable);
    values.add(to<T>(a_default));
    opts.add(std::vector<std::string>());
    m_valops.push_back(valop::def());
  }

  template <class T>
  bool get_color(unsigned int a_index,T& a_r,T& a_g,T& a_b,T& a_a) {
    return entries_color(values.values()[a_index],a_r,a_g,a_b,a_a);
  }

  const valop& get_valop(unsigned int a_index) const {
    return m_valops[a_index];
  }
  valop& get_valop(unsigned int a_index) {return m_valops[a_index];}
public:
  sg::edvalop& edvalop() {return m_edvalop;}
  sg::file_chooser& file_chooser() {return m_file_chooser;}
protected:
  static unsigned int action_show_numeric()      {return 0;}
  static unsigned int action_hide_numeric()      {return 1;}
  static unsigned int action_show_keyboard()     {return 2;}
  static unsigned int action_hide_keyboard()     {return 3;}
  static unsigned int action_show_colors()       {return 4;}
  static unsigned int action_hide_colors()       {return 5;}
  static unsigned int action_show_edvalop()      {return 6;}
  static unsigned int action_hide_edvalop()      {return 7;}
  static unsigned int action_show_file_chooser() {return 8;}
  static unsigned int action_hide_file_chooser() {return 9;}
  static unsigned int action_show_opts()         {return 10;}
  static unsigned int action_hide_opts()         {return 11;}

  INLIB_CLASS_STRING(Ok)
  INLIB_CLASS_STRING(true)
  INLIB_CLASS_STRING(false)

  class _cbk : public acbk {
  public:
    virtual return_action action() {
      if(m_action==action_show_numeric()) {
        m_this.label_back_color = m_this.shown_label_color;
        entry_type type;
        if(!m_this.types.get_value(m_index,type)) {
          type = entry_real;
        }        
        if(type==entry_real) {
          m_this.m_numeric.number_type = sg::number_real;
        } else if(type==entry_range) {
          m_this.m_numeric.number_type = sg::number_real;
          m_this.m_numeric.show_slider = true;
          const std::vector<std::string>& sv = m_this.opts[m_index];
          if(sv.size()==2) {
           {double v;
            if(to<double>(sv[0],v)) m_this.m_numeric.slider_min = v;}
           {double v;
            if(to<double>(sv[1],v)) m_this.m_numeric.slider_max = v;}
          }
        } else if(type==entry_uint) {
          m_this.m_numeric.number_type = sg::number_uint;
        } else if(type==entry_int) {
          m_this.m_numeric.number_type = sg::number_int;
        } else if(type==entry_ip) {
          m_this.m_numeric.number_type = sg::number_ip;
        }
        //as long as we can edit the result area it makes no sense
        //to set a default value in numeric.
        //m_this.m_numeric->value = m_this.values[m_index];

        m_this.m_numeric.value = "";
        m_this.m_numeric.clear_cbks();
        m_this.m_numeric.add_callback
          (new _cbk(m_this,m_out,m_index,action_hide_numeric()));
        m_this.m_switch.which = WHICH_NUMERIC();
        m_this.m_active_index = m_index;

      } else if(m_action==action_hide_numeric()) {
        entry* entry = m_this.find_entry(m_index);
        if(!entry) {
          m_out << "inlib::sg::entries::_cbk :"
                << " hide_numeric : entry not found for index "
                << m_index << "."
                << std::endl;
        } else {
          entry->value = m_this.m_numeric.value.value();
          m_this.values.set_value(m_index,entry->value.value());
        }
        m_this.m_switch.which = WHICH_PANEL();
        m_this.m_active_index = (-1);

      } else if(m_action==action_show_keyboard()) {
        m_this.label_back_color = m_this.shown_label_color;
        //as long as we can edit the result area it makes no sense
        //to set a default value in keyboard.
        //m_this.m_keyboard.value = m_this.values[m_index];
        m_this.m_keyboard.value = "";
        m_this.m_keyboard.clear_cbks();
        m_this.m_keyboard.add_callback
          (new _cbk(m_this,m_out,m_index,action_hide_keyboard()));
        m_this.m_switch.which = WHICH_KEYBOARD();
        m_this.m_active_index = m_index;

      } else if(m_action==action_hide_keyboard()) {
        entry* entry = m_this.find_entry(m_index);
        if(!entry) {
          m_out << "inlib::sg::entries::_cbk :"
                << " hide_keyboard : entry not found for index "
                << m_index << "."
                << std::endl;
        } else {
          entry->value = m_this.m_keyboard.value;
          m_this.values.set_value(m_index,entry->value.value());
        }
        m_this.m_switch.which = WHICH_PANEL();
        m_this.m_active_index = (-1);

      } else if(m_action==action_show_colors()) {
        m_this.label_back_color = m_this.shown_label_color;
        m_this.m_colors.value = "";
        m_this.m_colors.clear_cbks();
        m_this.m_colors.add_callback
          (new _cbk(m_this,m_out,m_index,action_hide_colors()));
        m_this.m_switch.which = WHICH_COLORS();
        m_this.m_active_index = m_index;

      } else if(m_action==action_hide_colors()) {
        entry* entry = m_this.find_entry(m_index);
        if(!entry) {
          m_out << "inlib::sg::entries::_cbk :"
                << " hide_colors : entry not found for index "
                << m_index << "."
                << std::endl;
        } else {
          entry->value = m_this.m_colors.value;
          m_this.values.set_value(m_index,entry->value.value());
        }
        m_this.m_switch.which = WHICH_PANEL();
        m_this.m_active_index = (-1);

      } else if(m_action==action_show_opts()) {
        m_this.label_back_color = m_this.shown_label_color;
        m_this.m_switch.which = WHICH_OPTS();
        m_this.m_active_index = m_index;

        separator* sep = (separator*)(m_this.m_switch[entries::WHICH_OPTS()]);
        sep->clear();
        if(m_opts.empty()) return return_to_render;

        float wlist = m_this.list_width;
        float hlist = m_this.list_height;

        sg::list* list = new sg::list(m_this.m_ttf);
        list->width = wlist;
        list->height = hlist;
        list->scroll_width = m_this.list_scroll_width;
        list->text_common_height = true;
        list->visible_items = m_this.list_visible_items;

        //a_gv.set_colors(*list);
        list->back_color = m_this.back_color;
        list->border_color = m_this.border_color;
        list->front_color = m_this.front_color;
        //list->dir_color = m_gui_dir_color;
        list->arm_color = m_this.arm_color;
        list->text_hmargin_factor = 0.5f; //Apple

        for(unsigned int index=0;index<m_opts.size();index++) {
          std::vector<std::string> value;
          value.push_back(m_opts[index]);
          _cbk* cbk2 = new _cbk(m_this,m_out,m_index,action_hide_opts());
          cbk2->m_opts = value;
          list->add(m_opts[index],cbk2);
        }

        sep->add(list);

      } else if(m_action==action_hide_opts()) {

        entry* entry = m_this.find_entry(m_index);
        if(!entry) {
          m_out << "inlib::sg::entries::_cbk :"
                << " hide_opts : entry not found for index "
                << m_index << "."
                << std::endl;
        } else {
          entry->value = m_opts.size()?m_opts[0]:"";
          m_this.values.set_value(m_index,entry->value.value());
        }
        m_this.m_switch.which = WHICH_PANEL();
        m_this.m_active_index = (-1);

      } else if(m_action==action_show_edvalop()) {
        m_this.label_back_color = m_this.shown_label_color;
        m_this.m_edvalop.result() = valop::def();
        m_this.m_edvalop.clear_cbks();
        m_this.m_edvalop.add_callback
          (new _cbk(m_this,m_out,m_index,action_hide_edvalop()));
        m_this.m_switch.which = WHICH_EDVALOP();
        m_this.m_active_index = m_index;

      } else if(m_action==action_hide_edvalop()) {

        valop& res = m_this.m_edvalop.result();
        m_this.m_valops[m_index] = res;

        entry* entry = m_this.find_entry(m_index);
        if(!entry) {
          m_out << "inlib::sg::entries::_cbk :"
                << " hide_edvalop : entry not found for index "
                << m_index << "."
                << std::endl;
        } else {
          valop2s v;
          entry->value = v.visit(res)?v.m_s:"?";
          m_this.values.set_value(m_index,entry->value.value());
        }

        m_this.m_switch.which = WHICH_PANEL();
        m_this.m_active_index = (-1);

      } else if(m_action==action_show_file_chooser()) {
        m_this.label_back_color = m_this.shown_label_color;

        m_this.m_file_chooser.value = ""; //default ?
        m_this.m_file_chooser.clear_cbks();
        m_this.m_file_chooser.add_callback
          (new _cbk(m_this,m_out,m_index,action_hide_file_chooser()));
        m_this.m_file_chooser.initialize(m_out);

        m_this.m_switch.which = WHICH_FILE_CHOOSER();
        m_this.m_active_index = m_index;

      } else if(m_action==action_hide_file_chooser()) {

        entry* entry = m_this.find_entry(m_index);
        if(!entry) {
          m_out << "inlib::sg::entries::_cbk :"
                << " hide_edvalop : entry not found for index "
                << m_index << "."
                << std::endl;
        } else {
          entry->value = m_this.m_file_chooser.value;
          m_this.values.set_value(m_index,entry->value.value());
        }

        m_this.m_switch.which = WHICH_PANEL();
        m_this.m_active_index = (-1);

      }

      return return_to_render;
    }
    virtual bcbk* copy() const {return new _cbk(*this);}
  public:
    _cbk(entries& a_this,std::ostream& a_out,
         unsigned int a_index,unsigned int a_action)
    :acbk(a_action)
    ,m_this(a_this)
    ,m_out(a_out)
    ,m_index(a_index)
    {}
    virtual ~_cbk(){}
  public:
    _cbk(const _cbk& a_from)
    :acbk(a_from)
    ,m_this(a_from.m_this)
    ,m_out(a_from.m_out)
    ,m_index(a_from.m_index)
    ,m_opts(a_from.m_opts)
    {}
    _cbk& operator=(const _cbk& a_from){
      acbk::operator=(a_from);
      m_index = a_from.m_index;
      m_opts = a_from.m_opts;
      return *this;
    }
  protected:
    entries& m_this;
    std::ostream& m_out;
    unsigned int m_index;
  public:
    std::vector<std::string> m_opts; 
  };

  static int WHICH_PANEL()        {return 0;}
  static int WHICH_NUMERIC()      {return 1;}
  static int WHICH_KEYBOARD()     {return 2;}
  static int WHICH_COLORS()       {return 3;}
  static int WHICH_EDVALOP()      {return 4;}
  static int WHICH_FILE_CHOOSER() {return 5;}
  static int WHICH_OPTS()         {return 6;}

protected: //base_list
  virtual unsigned int number_of_items() const {return labels.size();}
  virtual node* create_item(std::ostream& a_out,unsigned int a_index) {
    entry* entry = create_entry(a_out,a_index);
    m_entries[a_index] = entry;

    //NOTE : some entry results are too long (for exa a file name).
    entry->update_sg();
    m_texts.add(new noderef(entry->label_widget()));

    entry_type type = types[a_index];
    if(type==entry_uint) {
      m_texts.add(new noderef(entry->result_widget()));
    } else if(type==entry_int) {
      m_texts.add(new noderef(entry->result_widget()));
    } else if(type==entry_real) {
    } else if(type==entry_range) {
    } else if(type==entry_ip) {
    } else if(type==entry_string) {
    } else if(type==entry_color) {
    } else if(type==entry_math) {
    } else if(type==entry_file) {
    } else if(type==entry_bool) {
      m_texts.add(new noderef(entry->result_widget()));
    } else if(type==entry_opts) {
    } else { //not_editable
    }

    return entry;
  }
  virtual node* create_cancel() const {return create_ok();}
  virtual void enforce_common_text_height(std::ostream& a_out) {
    sg::enforce_common_text_height(a_out,m_texts);
  }
  virtual bool show_cancel() const {return true;} //in fact ok button.

  virtual node* create_label() const {
    float wtext = witem();
    float htext = hitem();

    sg::text* head_label = new sg::text(m_ttf);
    head_label->width = wtext;
    head_label->height = htext;
    head_label->back_area::color = label_back_color;
    head_label->confine = label_confine;
    head_label->back_area::border_color = border_color;
    head_label->color = front_color;
    head_label->font = gui_font();
    head_label->wmargin_factor = text_wmargin_factor;
    head_label->hmargin_factor = text_hmargin_factor;

    head_label->strings.clear();
    head_label->strings.add(label.value());

    head_label->corner_radius = corner_radius;

    return head_label;
  }
protected:
  void update_sg(std::ostream& a_out) {
    m_entries.clear();
    parent::update_sg(a_out);

    //update_sg may come from an iPad rotation. We have to restore state.
    int old_switch_which = m_switch.which;
    std::string old_numeric_value = m_numeric.value.value();
    std::string old_keyboard_value = m_keyboard.value.value();
    std::string old_colors_value = m_colors.value.value();

    m_switch.clear();

    if(width.value()<=0) return;
    if(height.value()<=0) return;
    if(types.size()!=labels.size()) return;
    if(labels.empty()) {values.clear();return;}

    values.values().resize(labels.size());

    m_numeric.back_color = back_color;
    m_numeric.front_color = front_color;
    m_numeric.border_color = border_color;
    m_numeric.arm_color = arm_color;
    m_numeric.width = numeric_width;
    m_numeric.height = numeric_height;
    m_numeric.text_wmargin_factor = text_wmargin_factor;
    m_numeric.text_hmargin_factor = text_hmargin_factor;
    m_numeric.value = "";
    m_numeric.clear_cbks();
    m_numeric.corner_radius = corner_radius;

    m_keyboard.back_color = back_color;
    m_keyboard.front_color = front_color;
    m_keyboard.border_color = border_color;
    m_keyboard.arm_color = arm_color;
    m_keyboard.width = keyboard_width;
    m_keyboard.height = keyboard_height;
    m_keyboard.text_wmargin_factor = text_wmargin_factor;
    m_keyboard.text_hmargin_factor = text_hmargin_factor;
    m_keyboard.value = "";
    m_keyboard.clear_cbks();

    m_colors.back_color = back_color;
    m_colors.front_color = front_color;
    m_colors.border_color = border_color;
    m_colors.arm_color = arm_color;
    m_colors.width = colors_width;
    m_colors.height = colors_height;
    m_colors.text_wmargin_factor = text_wmargin_factor;
    m_colors.text_hmargin_factor = text_hmargin_factor;
    m_colors.value = "";
    m_colors.clear_cbks();

    m_edvalop.back_color = back_color;
    m_edvalop.front_color = front_color;
    m_edvalop.border_color = border_color;
    m_edvalop.arm_color = arm_color;
    m_edvalop.width = edvalop_width;
    m_edvalop.height = edvalop_height;
    m_edvalop.text_wmargin_factor = text_wmargin_factor;
    m_edvalop.text_hmargin_factor = text_hmargin_factor;
    m_edvalop.numeric_width = numeric_width;
    m_edvalop.numeric_height = numeric_height;
    m_edvalop.list_width = list_width;
    m_edvalop.list_height = list_height;
    m_edvalop.list_scroll_width = list_scroll_width;
    m_edvalop.list_visible_items = list_visible_items;
    //m_edvalop.vars.set_values();
    m_edvalop.result() = valop::def();
    m_edvalop.clear_cbks();

    m_file_chooser.back_color = back_color;
    m_file_chooser.front_color = front_color;
    m_file_chooser.border_color = border_color;
    m_file_chooser.arm_color = arm_color;
    m_file_chooser.width = file_chooser_width;
    m_file_chooser.height = file_chooser_height;
    m_file_chooser.text_wmargin_factor = text_wmargin_factor;
    m_file_chooser.text_hmargin_factor = text_hmargin_factor;
    m_file_chooser.value = "";
    m_file_chooser.clear_cbks();

    m_switch.add(new noderef(m_sep));          //WHICH_PANEL
    m_switch.add(new noderef(m_numeric));      //WHICH_NUMERIC
    m_switch.add(new noderef(m_keyboard));     //WHICH_KEYBOARD
    m_switch.add(new noderef(m_colors));       //WHICH_COLORS
    m_switch.add(new noderef(m_edvalop));      //WHICH_EDVALOP
    m_switch.add(new noderef(m_file_chooser)); //WHICH_FILE_CHOOSER
    m_switch.add(new separator());             //WHICH_OPTS

    m_switch.which = old_switch_which;
    if(m_switch.which==WHICH_NUMERIC()) { //numeric is shown.
      entry_type type;
      if(!types.get_value(m_active_index,type)) {
        type = entry_real;
      }        
      if(type==entry_real) {
        m_numeric.number_type = number_real;
      } else if(type==entry_range) {
        m_numeric.number_type = number_real;
        m_numeric.show_slider = true;
        const std::vector<std::string>& sv = opts[m_active_index];
        if(sv.size()==2) {
         {double v;
          if(to<double>(sv[0],v)) m_numeric.slider_min = v;}
         {double v;
          if(to<double>(sv[1],v)) m_numeric.slider_max = v;}
        }
      } else if(type==entry_uint) {
        m_numeric.number_type = number_uint;
      } else if(type==entry_int) {
        m_numeric.number_type = number_int;
      } else if(type==entry_ip) {
        m_numeric.number_type = number_ip;
      }
      m_numeric.value = old_numeric_value;
      m_numeric.clear_cbks();
      m_numeric.add_callback
        (new _cbk(*this,a_out,m_active_index,action_hide_numeric()));

    } else if(m_switch.which==WHICH_KEYBOARD()) { //keyboard is shown.
      m_keyboard.value = old_keyboard_value;
      m_keyboard.clear_cbks();
      m_keyboard.add_callback
        (new _cbk(*this,a_out,m_active_index,action_hide_keyboard()));

    } else if(m_switch.which==WHICH_COLORS()) { //colors is shown.
      m_colors.value = old_colors_value;
      m_colors.clear_cbks();
      m_colors.add_callback
        (new _cbk(*this,a_out,m_active_index,action_hide_colors()));

    }


  }

  entry* create_entry(std::ostream& a_out,unsigned int a_index) {

    float wentry = witem();
    float hentry = hitem();

    sg::entry* entry = new sg::entry(m_ttf);
    //entry->font = gui_font();
    entry->front_color = front_color;
    entry->back_color = back_color;
    entry->border_color = border_color;
    entry->arm_color = arm_color;
    entry->text_wmargin_factor = text_wmargin_factor;
    entry->text_hmargin_factor = text_hmargin_factor;
    entry->label_result_factor = entry_label_result_factor;
    entry->label_back_color = labels_back_color;

    entry->width = wentry;
    entry->height = hentry;

    entry->label = labels[a_index];
    entry->value = values[a_index];

    entry->corner_radius = corner_radius;

    entry_type type = types[a_index];

    if( (type==entry_uint)  ||
        (type==entry_int)   ||
        (type==entry_real)  ||
        (type==entry_range) ||
        (type==entry_ip)    ){
      entry->add_callback(new _cbk(*this,a_out,a_index,action_show_numeric()));

    } else if(type==entry_string) {
      entry->add_callback(new _cbk(*this,a_out,a_index,action_show_keyboard()));

    } else if(type==entry_color) {
      entry->add_callback(new _cbk(*this,a_out,a_index,action_show_colors()));

    } else if(type==entry_math) {
      entry->add_callback(new _cbk(*this,a_out,a_index,action_show_edvalop()));

    } else if(type==entry_file) {
      entry->add_callback
        (new _cbk(*this,a_out,a_index,action_show_file_chooser()));

    } else if(type==entry_bool) {
      _cbk* cbk = new _cbk(*this,a_out,a_index,action_show_opts());
      cbk->m_opts.clear();
      cbk->m_opts.push_back(s_true());
      cbk->m_opts.push_back(s_false());
      entry->add_callback(cbk);

    } else if(type==entry_opts) {
      _cbk* cbk = new _cbk(*this,a_out,a_index,action_show_opts());
      cbk->m_opts.clear();
      if(a_index<opts.size()) cbk->m_opts = opts.values()[a_index];
      entry->add_callback(cbk);

    } else { //not_editable
    }

    return entry;
  }

  node* create_ok() const {
    float wtext = witem();
    float htext = hitem();

    text_button* b = new text_button(m_ttf);
    b->width = wtext;
    b->height = htext;
    b->back_area::color = back_color;
    b->back_area::border_color = border_color;
    b->color = front_color;
    b->font = gui_font();
    b->set_label(s_Ok());
    b->arm_color = arm_color;
    b->wmargin_factor = text_wmargin_factor;
    b->hmargin_factor = text_hmargin_factor;
    	
    b->hjust = center;

    b->corner_radius = corner_radius;

    b->copy_cbks(m_cbks);

    return b;
  }

protected:
  entry* find_entry(unsigned int a_index) const {
    std::map<unsigned int,entry*>::const_iterator it = m_entries.find(a_index);
    if(it==m_entries.end()) return 0;
    return (*it).second;
  }
protected:
  const base_freetype& m_ttf;

  sg::cbks m_cbks;
  _switch m_switch;

  numeric m_numeric;
  keyboard m_keyboard;
  colors m_colors;
  sg::edvalop m_edvalop;
  sg::file_chooser m_file_chooser;

  int m_active_index;
  std::vector<valop> m_valops;
  std::map<unsigned int,entry*> m_entries;
};

}}

#endif
