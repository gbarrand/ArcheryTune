// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_tex_rect
#define inlib_sg_tex_rect

// node to render an RGB inlib::img_byte with ::glTexImage2D.

#include "node"
#include "sfs"
#include "render_action"
#include "pick_action"
#include "bbox_action"
#include "event_action"
#include "gl_manager"
#include "../pointer"
#include "gstos"
#include "base_tex"

namespace inlib {
namespace sg {

class tex_rect : public node, public gstos, public base_tex {
  INLIB_NODE(tex_rect,inlib::sg::tex_rect,node)
public:
  sf<bool> show_border;
  sf<float> height;
public:
  virtual const std::vector<field_desc>& node_fields() const {
    static std::vector<field_desc> s_v;
    if(s_v.empty()) {
      s_v = parent::node_fields();
      INLIB_ADD_FIELD_DESC(img)
      INLIB_ADD_FIELD_DESC(back_color)
      INLIB_ADD_FIELD_DESC(expand)
      INLIB_ADD_FIELD_DESC(limit)
      INLIB_ADD_FIELD_DESC(show_border)
      INLIB_ADD_FIELD_DESC(height)
    }
    return s_v;
  }
private:
  void add_fields(){
    add_field(&img);
    add_field(&back_color);
    add_field(&expand);
    add_field(&limit);
    add_field(&show_border);
    add_field(&height);
  }
public:
  virtual void render(render_action& a_action) {
    //a_action.out() << "inlib::tex_rect::render : " << std::endl;

    //NOTE : we draw border (show_border is true) and background even if
    //       gen_texture() failed.

    if(touched()) {
      update_sg(a_action.out());
      reset_touched();
    }
    if(m_img.is_empty()) return;

    unsigned int _id = get_tex_id(a_action.out(),a_action.gl_manager(),m_img);
  
    const state& state = a_action.state();

    //image must be 2^n,2^m in size !
    // exa : 128x64

    if(show_border.value()) {
      floatp box,nms;
      _front(box,nms,0.01f);

      a_action.color4f(1,0,0,1);
      a_action.line_width(4);

      a_action.draw_vertex_array(gl::line_loop(),12,box);

      //pushes back the filled polygons to avoid z-fighting with lines
      a_action.set_polygon_offset(true);

      a_action.color4f(state.m_color);
      a_action.line_width(state.m_line_width);
    }

    //draw a back face pointing toward negative z :
   {a_action.color4f(back_color.value());
    floatp tris,nms;
    _tris(tris,nms);
    a_action.draw_vertex_normal_array(gl::triangles(),18,tris,nms);
    a_action.color4f(state.m_color);}

    if(_id) {
      floatp box,nms;
      _front(box,nms);
      float tcs[8];
      set_tcs(tcs);
      a_action.draw_vertex_normal_array_texture(gl::triangle_fan(),12,box,nms,_id,tcs);
    }
    a_action.set_polygon_offset(state.m_GL_POLYGON_OFFSET_FILL);
  }
  virtual void pick(pick_action& a_action) {
    if(touched()) {
      update_sg(a_action.out());
      reset_touched();
    }
    if(m_img.is_empty()) return;
    floatp xyzs,nms;
    _front(xyzs,nms);
    a_action.add__primitive(*this,gl::triangle_fan(),12,xyzs,true);
  }

  virtual void bbox(bbox_action& a_action) {
    if(touched()) {
      update_sg(a_action.out());
      reset_touched();
    }
    if(m_img.is_empty()) return;
    floatp xyzs,nms;
    _front(xyzs,nms);
    a_action.add_points(12,xyzs);
  }

public:
  tex_rect()
  :parent()
  ,base_tex()
  ,show_border(false)
  ,height(1)
  {
    add_fields();
  }
  virtual ~tex_rect(){}
public:
  tex_rect(const tex_rect& a_from)
  :parent(a_from)
  ,gstos(a_from)
  ,base_tex(a_from)
  ,show_border(a_from.show_border)
  ,height(a_from.height)
  {
    add_fields();
  }
  tex_rect& operator=(const tex_rect& a_from){
    parent::operator=(a_from);
    gstos::operator=(a_from);
    base_tex::operator=(a_from);
    if(&a_from==this) return *this;
    show_border = a_from.show_border;
    height = a_from.height;
    return *this;
  }
public:

  //const img_byte& rendered_img() const {return m_img;}

  void rendered_size(std::ostream& a_out,unsigned int& a_w,unsigned int& a_h) {
    update_sg(a_out);
    reset_touched();
    a_w = m_img.width();
    a_h = m_img.height();
  }

/*
*/
protected:
  virtual void update_sg(std::ostream& a_out) {
    //NOTE : virtual for diaporama node.
    clean_gstos(); //must reset for all gl_manager.
    base_tex::_update_sg_(a_out);
  }
protected:
  void _front(float*& a_front,float*& a_nms,float a_epsil = 0.0f) { //[12]
    static float front[12]; //WARNING : writable static.
    static float nms[12];  

    float aspect = float(img.value().width())/float(img.value().height());
    float h2 = height*0.5f;
    float w2 = aspect*h2;

    h2 += a_epsil;
    w2 += a_epsil;

    front[0] = -w2;
    front[1] = -h2;
    front[2] =  0;

    front[3] =  w2;
    front[4] = -h2;
    front[5] =  0;

    front[6] =  w2;
    front[7] =  h2;
    front[8] =  0;

    front[ 9] = -w2;
    front[10] =  h2;
    front[11] =  0;

    nms[0] = 0;
    nms[1] = 0;
    nms[2] = 1;

    nms[3] = 0;
    nms[4] = 0;
    nms[5] = 1;

    nms[6] = 0;
    nms[7] = 0;
    nms[8] = 1;

    nms[9] = 0;
    nms[10] = 0;
    nms[11] = 1;

    a_front  = front;
    a_nms = nms;
  }

  void _back(float*& a_back) { //[12]
    static float back[12];

    float aspect = float(img.value().width())/float(img.value().height());
    float h2 = height*0.5f;
    float w2 = aspect*h2;
    float d2 = 0;

    back[0] =  w2;back[ 1] = -h2;back[ 2] = d2;
    back[3] = -w2;back[ 4] = -h2;back[ 5] = d2;
    back[6] = -w2;back[ 7] =  h2;back[ 8] = d2;
    back[9] =  w2;back[10] =  h2;back[11] = d2;

    a_back  = back;
  }

  typedef float* floatp;

  void _tris(float*& a_tris,float*& a_nms){ //[18]

    floatp back;
    _back(back);

    static float tris[18];
    static float nms[18];  

    tris[0] = back[0];
    tris[1] = back[1];
    tris[2] = back[2];

    tris[3] = back[3];
    tris[4] = back[4];
    tris[5] = back[5];

    tris[6] = back[6];
    tris[7] = back[7];
    tris[8] = back[8];
    //
    tris[9]  = back[6];
    tris[10] = back[7];
    tris[11] = back[8];

    tris[12] = back[9];
    tris[13] = back[10];
    tris[14] = back[11];

    tris[15] = back[0];
    tris[16] = back[1];
    tris[17] = back[2];

    ///////////////////// back
    nms[0] = 0;
    nms[1] = 0;
    nms[2] = -1;

    nms[3] = 0;
    nms[4] = 0;
    nms[5] = -1;

    nms[6] = 0;
    nms[7] = 0;
    nms[8] = -1;
    //
    nms[9]  = 0;
    nms[10] = 0;
    nms[11] = -1;

    nms[12] = 0;
    nms[13] = 0;
    nms[14] = -1;

    nms[15] = 0;
    nms[16] = 0;
    nms[17] = -1;

    a_tris = tris;
    a_nms = nms;
  }
};

}}

#endif
