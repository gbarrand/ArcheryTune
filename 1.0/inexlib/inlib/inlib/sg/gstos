// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_gstos
#define inlib_sg_gstos

#include "gl_manager"
#include <vector>

namespace inlib {
namespace sg {

class gstos {
protected:
  gstos() {}
  virtual ~gstos() {clean_gstos();}
protected:
  gstos(const gstos&) {}
  gstos& operator=(const gstos& a_from) {
    if(&a_from==this) return *this;
    clean_gstos();
    return *this;
  }
protected:
  virtual unsigned int create_gsto(std::ostream&,gl_manager&) = 0;

  unsigned int get_gsto_id(std::ostream& a_out,gl_manager& a_mgr){
    unsigned int _id = _find(&a_mgr);
    if(!a_mgr.is_gsto_id_valid(_id)){
      clean_gstos(&a_mgr);
      _id = 0;
    }
    if(!_id) {
      _id = create_gsto(a_out,a_mgr);
      if(!_id) {
        // could be ok if there is no graphical data to load.
        //a_out << "inlib::sg::gstos::get_gsto_id :"
        //      << " create_gsto() failed."
        //      << std::endl;
      } else {
        m_gstos.push_back(std::pair<unsigned int,gl_manager*>(_id,&a_mgr));    
      }
    }
    return _id;
  }  
protected:
  void clean_gstos() {
    std::vector< std::pair<unsigned int,gl_manager*> >::iterator it;
    for(it=m_gstos.begin();it!=m_gstos.end();){
      (*it).second->delete_gsto((*it).first);
      it = m_gstos.erase(it);      
    }
  }
  void clean_gstos(gl_manager* a_mgr) {
    std::vector< std::pair<unsigned int,gl_manager*> >::iterator it;
    for(it=m_gstos.begin();it!=m_gstos.end();){
      if((*it).second==a_mgr) {
        (*it).second->delete_gsto((*it).first);
        it = m_gstos.erase(it);      
      } else {
        it++;
      }
    }
  }
protected:
  unsigned int _find(gl_manager* a_mgr) {
    std::vector< std::pair<unsigned int,gl_manager*> >::iterator it;
    for(it=m_gstos.begin();it!=m_gstos.end();++it){
      if((*it).second==a_mgr) return (*it).first;
    }
    return 0;
  }

protected:
  std::vector< std::pair<unsigned int,gl_manager*> > m_gstos;
};

}}

#endif
