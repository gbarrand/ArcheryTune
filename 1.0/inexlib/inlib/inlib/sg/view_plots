// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_view_plots
#define inlib_sg_view_plots

#include "view_evd"

#include "h2plot_cp"
#include "cloud2plot_cp"
#include "event_dispatcher"
#include "plots"

namespace inlib {
namespace sg {

class view_plots {
public:
  INLIB_SCLASS(inlib::sg::view_plots)
public:
  view_plots(gui_viewer& a_gv):m_gv(a_gv){}
  virtual ~view_plots(){}
protected:
  view_plots(const view_plots& a_from):m_gv(a_from.m_gv){}
  view_plots& operator=(const view_plots&){return *this;}
public:
  void plot(const inlib::histo::h1d& a_histo,bool a_cp = true) {
    plots* _plots = get_plots();if(!_plots) return;
    plotter& plotter = _plots->current_plotter();
    plotter.clear();
    if(a_cp) {
      plotter.add_plottable(new h1d2plot_cp(a_histo));
    } else {
      plotter.add_plottable(new h1d2plot(a_histo));
    }
    style_from_res(guiv::s_default(),plotter);       
  }
  void plot(const inlib::histo::h2d& a_histo,bool a_cp = true) {
    plots* _plots = get_plots();if(!_plots) return;
    plotter& plotter = _plots->current_plotter();
    plotter.clear();
    if(a_cp) {
      plotter.add_plottable(new h2d2plot_cp(a_histo));
    } else {
      plotter.add_plottable(new h2d2plot(a_histo));
    }
    style_from_res(guiv::s_default(),plotter);       
  }
  void plot(const inlib::histo::p1d& a_histo) {
    plots* _plots = get_plots();if(!_plots) return;
    plotter& plotter = _plots->current_plotter();
    plotter.clear();
    plottable* ptb = new p1d2plot_cp(a_histo);
    plotter.add_plottable(ptb);
    style_from_res(guiv::s_default(),plotter);       
  }

  void plot(const inlib::histo::c2d& a_histo) {
    plots* _plots = get_plots();if(!_plots) return;
    plotter& plotter = _plots->current_plotter();
    plotter.clear();
    plottable* ptb = new c2d2plot_cp(a_histo);
    plotter.add_plottable(ptb);
    style_from_res(guiv::s_default(),plotter);       
  }

public:
  virtual plots* get_plots() { //overriten by exlib/geant4/viewer.
    plots* _plots = _get_plots();
    if(!_plots) _plots = create_sg_plots();
    if(!_plots) return 0;
    _plots->adjust_size(m_gv.width(),m_gv.height());
    return _plots;
  }

public:
  void style_from_res(const std::string& a_path,plotter& a_plotter) {
    //sg::fields of plotter :
   {typedef inlib::xml::styles::style_t style_t;
    const style_t* _style = m_gv.styles().find_style(a_path);
    if(_style){
      a_plotter.set_from_style(m_gv.out(),*_style);
    } else {
      m_gv.out() << "inlib::sg::view_plots::style_from_res :"
                    << " style " << inlib::sout(a_path) << " not found."
                    << std::endl;
    }}

    //sg::fields of various xml::styles :
    m_gv.styles().res_sg_style<style>(a_path+".bins_style.0",a_plotter.bins_style(0));
    m_gv.styles().res_sg_style<style>(a_path+".errors_style.0",a_plotter.errors_style(0));
    m_gv.styles().res_sg_style<style>(a_path+".func_style.0",a_plotter.func_style(0));
    m_gv.styles().res_sg_style<style>(a_path+".points_style.0",a_plotter.points_style(0));

    m_gv.styles().res_sg_style<style>(a_path+".background_style",a_plotter.background_style());
    m_gv.styles().res_sg_style<text_style>(a_path+".title_style",a_plotter.title_style());
    m_gv.styles().res_sg_style<text_style>(a_path+".infos_style",a_plotter.infos_style());
    m_gv.styles().res_sg_style<text_style>(a_path+".title_box_style",a_plotter.title_box_style());
    m_gv.styles().res_sg_style<style>(a_path+".inner_frame_style",a_plotter.inner_frame_style());
    m_gv.styles().res_sg_style<style>(a_path+".grid_style",a_plotter.grid_style());

    style_from_res(a_path+".x_axis",a_plotter.x_axis());
    style_from_res(a_path+".y_axis",a_plotter.y_axis());
    style_from_res(a_path+".z_axis",a_plotter.z_axis());
    style_from_res(a_path+".colormap_axis",a_plotter.colormap_axis());

  }
  void style_from_res(const std::string& a_path,axis& a_axis) {
   {typedef inlib::xml::styles::style_t style_t;
    const style_t* style = m_gv.styles().find_style(a_path);
    if(style){
      a_axis.set_from_style(m_gv.out(),*style);
    } else {
      if(m_gv.verbose()) {
        m_gv.out() << "inlib::sg::view_plots::style_from_res(axis) :"
                      << " style " << inlib::sout(a_path) << " not found."
                      << std::endl;
      }
    }}

    m_gv.styles().res_sg_style<line_style>(a_path+".line_style",a_axis.line_style());
    m_gv.styles().res_sg_style<line_style>(a_path+".ticks_style",a_axis.ticks_style());
    m_gv.styles().res_sg_style<text_style>(a_path+".labels_style",a_axis.labels_style());
    m_gv.styles().res_sg_style<text_style>(a_path+".mag_style",a_axis.mag_style());
    m_gv.styles().res_sg_style<text_style>(a_path+".title_style",a_axis.title_style());
  }

protected:
  plots* _get_plots() {
    view_evd* _evd = cast_view_evd(m_gv);
    if(!_evd) return 0;
    if(!_evd->is_evd()) return 0;
    separator& dsep = _evd->detector_sg();
    if(dsep.size()!=1) return 0;
    separator* _sep = safe_cast<node,separator>(*(dsep[0]));
    if(!_sep) return 0;
    if(_sep->size()!=3) return 0;
    return safe_cast<node,plots>(*((*_sep)[1]));
  }

  plots* create_sg_plots(){
    view_evd* _evd = cast_view_evd(m_gv);
    if(!_evd) return 0;
 
    if(!_evd->is_evd()) _evd->create_sg_evd();

    m_gv.set_plane_viewer(true);

    separator& dsep = _evd->detector_sg();
    dsep.clear();

    separator* sep = new separator;
    dsep.add(sep);

    //float cam_height = m_gv.wanted_size();
    float cam_height = 2;
 
    matrix* _matrix = new matrix;
    _matrix->set_scale(cam_height,cam_height,cam_height);
    sep->add(_matrix);    

    plots* _plots = new plots(m_gv.ttf());
    _plots->width = 1;
    _plots->height = 1;
    _plots->cols = 1;
    _plots->rows = 1;
    _plots->view_border = false;
    _plots->border_visible = true;
    _plots->border_width = 0.05f; //outside width,height square.
    _plots->border_height = 0.05f;
    sep->add(_plots);

    event_dispatcher* dpt = new event_dispatcher;
    dpt->add_callback(new plots_cbk(*_plots));
    sep->add(dpt);

   {base_camera* cam = m_gv.create_2D_camera(cam_height);
    if(cam) _evd->replace_camera(cam);}
   
    return _plots;
  }

protected:
  class plots_cbk : public ecbk {
    INLIB_CBK(plots_cbk,inlib::sg::view_plots::plots_cbk,ecbk)
  public:
    virtual return_action action() {
      if(const size_event* sz_evt =
           safe_cast<event,size_event>(*m_event)){
        m_plots.adjust_size(sz_evt->width(),sz_evt->height());
        m_event_action->set_done(true);
      }
      return return_none;
    }
  public:
    plots_cbk(plots& a_plots)
    :parent(0),m_plots(a_plots){}
    virtual ~plots_cbk(){}
  protected:
    plots_cbk(const plots_cbk& a_from)
    :parent(a_from),m_plots(a_from.m_plots){}
    plots_cbk& operator=(const plots_cbk& a_from){
      parent::operator=(a_from);
      return *this;
    }
  protected:
    plots& m_plots;
  };

protected:
  gui_viewer& m_gv;
};


inline view_plots* cast_view_plots(inlib::sg::viewer& a_viewer) {
  return safe_cast<viewer,view_plots>(a_viewer);
}

inline plots* scene_plots(inlib::sg::viewer& a_viewer) {
  sg::view_plots* _vp = cast_view_plots(a_viewer);
  if(!_vp) return 0;
  return _vp->get_plots();
}

}}

#endif
