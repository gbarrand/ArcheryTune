// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_cloud2plot
#define inlib_sg_cloud2plot

#include "plottable"

#include "../words"
#include "../sto"

#include "../histo/c2d"

#ifdef INLIB_MEM
#include "../mem"
#endif

namespace inlib {
namespace sg {

class c2d2plot : public virtual points2D {
  INLIB_SCLASS(inlib::sg::c2d2plot)
public: //plottable
  virtual plottable* copy() const {return new c2d2plot(*this);}
  virtual bool is_valid() const {return true;}
  virtual std::string name(){return m_name;}
  virtual void set_name(const std::string& a_s) {m_name = a_s;}
  virtual std::string title(){return "";}
  virtual std::string legend(){return m_legend;}
  virtual void set_legend(const std::string& a_s) {m_legend = a_s;}

  virtual std::string infos(const std::string& a_opts){
    std::string f_lf("\n");
    std::string sinfos;
    std::vector<std::string> words;
    inlib::words(a_opts," ",false,words);
    std::vector<std::string>::const_iterator it;
  
    for(it=words.begin();it!=words.end();++it) {
      if(((*it)=="name") && m_name.size()) {
        if(sinfos.size()) sinfos += f_lf;
        sinfos += "Name\n";
        sinfos += m_name;
  
      } else if((*it)=="entries") {
        if(sinfos.size()) sinfos += f_lf;
        sinfos += "Entries\n";
        sinfos += inlib::to<unsigned int>(m_data.entries());
  
      } else if((*it)=="mean") {
        if(sinfos.size()) sinfos += f_lf;
        sinfos += "MeanX\n";
        sinfos += inlib::to<double>(m_data.mean_x());
        sinfos += f_lf;
        sinfos += "MeanY\n";
        sinfos += inlib::to<double>(m_data.mean_y());

      } else if((*it)=="rms") {
        if(sinfos.size()) sinfos += f_lf;
        sinfos += "RMS X\n";
        sinfos += inlib::to<double>(m_data.rms_x());
        sinfos += f_lf;
        sinfos += "RMS Y\n";
        sinfos += inlib::to<double>(m_data.rms_y());
  
      }
    }
  
    return sinfos;
  }  
public: //points2D
  virtual float x_axis_min() const {return (float)m_data.lower_edge_x();}
  virtual float x_axis_max() const {return (float)m_data.upper_edge_x();}
  virtual float y_axis_min() const {return (float)m_data.lower_edge_y();}
  virtual float y_axis_max() const {return (float)m_data.upper_edge_y();}

  virtual unsigned int points() const {return m_data.entries();}
  virtual bool ith_point(unsigned int a_index,float& a_x,float& a_y) const {
    if(a_index>=m_data.entries()) {a_x = 0;a_y = 0;return false;}
    if(a_index>=m_data.entries()) {a_x = 0;a_y = 0;return false;}
    a_x = (float)m_data.value_x(a_index);
    a_y = (float)m_data.value_y(a_index);
    return true;
  }
public:
  c2d2plot(const histo::c2d& a_data)
  :m_data(a_data)
  {
#ifdef INLIB_MEM
    mem::increment(s_class().c_str());
#endif
  }
  virtual ~c2d2plot(){
#ifdef INLIB_MEM
    mem::decrement(s_class().c_str());
#endif
  }
public:
  c2d2plot(const c2d2plot& a_from)
  :plottable(a_from)
  ,points2D(a_from)
  ,m_data(a_from.m_data)
  ,m_name(a_from.m_name)
  ,m_legend(a_from.m_legend)
  {
#ifdef INLIB_MEM
    mem::increment(s_class().c_str());
#endif
  }  
  c2d2plot& operator=(const c2d2plot& a_from){
    m_name = a_from.m_name;
    m_legend = a_from.m_legend;
    return *this;
  }
protected:
  const histo::c2d& m_data;
  std::string m_name;
  std::string m_legend;
};

}}

#endif
