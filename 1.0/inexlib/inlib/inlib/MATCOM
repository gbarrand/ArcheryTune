// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_MATCOM
#define inlib_MATCOM

// common code to class mat and nmat.

#define INLIB_MATCOM \
protected:\
  static T zero() {return T();}\
  static T one() {return T(1);}\
  static T minus_one() {return T(-1);}\
  static T two() {return T(2);}\
public:\
  void set_value(unsigned int aR,unsigned int aC,const T& a_value) { \
    m_vec[aR + aC * dimension()] = a_value;\
  }\
\
  const T& value(unsigned int aR,unsigned int aC) const { \
    return m_vec[aR + aC * dimension()];\
  }\
\
  T value(unsigned int aR,unsigned int aC) { \
    return m_vec[aR + aC * dimension()];\
  }\
\
  void set_matrix(const INLIB_MAT_CLASS& a_m){ /*optimization.*/\
    _copy(a_m.m_vec);\
  }\
\
  void set_constant(const T& a_v){\
    for(unsigned int i=0;i<dim2();i++) m_vec[i] = a_v;\
  }\
  void set_zero(){\
    set_constant(zero());\
  }\
  void set_identity() {\
    set_zero();\
    for(unsigned int i=0;i<dimension();i++) m_vec[i+i*dimension()] = one();\
  }\
  void set_diagonal(const T& a_s) {\
    set_zero();\
    for(unsigned int i=0;i<dimension();i++) m_vec[i+i*dimension()] = a_s;\
  }\
public:\
/*\
  void mul_vec(T a_v[]) const {\
    T tmp[dimension()];\
    for(unsigned int r=0;r<D;r++) {\
      T v = T();\
      for(unsigned int c=0;c<D;c++) {\
        v += m_vec[r+c*dimension()]*a_v[c];\
      }\
      tmp[r] = v;\
    }\
   {for(unsigned int i=0;i<D;i++) a_v[i] = tmp[i];}\
  }\
*/\
  void mul_mtx(const INLIB_MAT_CLASS& a_m) {\
    _mul_mtx(a_m.m_vec);\
  }\
  void mul_mtx(const INLIB_MAT_CLASS& a_m,T a_tmp[]) {\
    _mul_mtx(a_m.m_vec,a_tmp);\
  }\
  void left_mul_mtx(const INLIB_MAT_CLASS& a_m) {    \
    /* this = a_m * this :*/\
    _left_mul_mtx(a_m.m_vec);\
  }\
  bool equal(const INLIB_MAT_CLASS& a_m) const {\
    for(unsigned int i=0;i<dim2();i++) {\
      if(m_vec[i]!=a_m.m_vec[i]) return false;\
    }\
    return true;\
  }\
\
  bool equal(const INLIB_MAT_CLASS& a_m,const T& a_epsil) const {\
    T* tp = (T*)m_vec;\
    T* mp = (T*)a_m.m_vec;\
    for(unsigned int i=0;i<dim2();i++,tp++,mp++) {\
      T diff = (*tp) - (*mp);\
      if(diff<zero()) diff *= minus_one();\
      if(diff>=a_epsil) {\
        return false;\
      }\
    }\
    return true;\
  }\
\
  void mx_diff(const INLIB_MAT_CLASS& a_m,T& a_mx_diff) const {\
    T* tp = (T*)m_vec;\
    T* mp = (T*)a_m.m_vec;\
    a_mx_diff = (*tp) - (*mp);\
    if(a_mx_diff<zero()) a_mx_diff *= minus_one();\
    for(unsigned int i=0;i<dim2();i++,tp++,mp++) {\
      T diff = (*tp) - (*mp);\
      if(diff<zero()) diff *= minus_one();\
      a_mx_diff = (diff>a_mx_diff?diff:a_mx_diff);\
    }\
  }\
\
  const T* data() const {return m_vec;}\
  unsigned int size() const {return dim2();}\
\
  T trace() const {\
    T _value = zero();\
    unsigned int _D = dimension();\
    for(unsigned int c=0;c<_D;c++) _value += m_vec[c+c*_D];\
    return _value;\
  }\
\
  void transpose() {\
    unsigned int _D = dimension();\
    for(unsigned int r=0;r<_D;r++) {\
      for(unsigned int c=(r+1);c<_D;c++) {\
        T vrc = value(r,c);\
        T vcr = value(c,r);\
        set_value(r,c,vcr);\
        set_value(c,r,vrc);\
      }\
    }\
  }\
\
  void multiply(const T& a_T) {\
    for(unsigned int i=0;i<dim2();i++) m_vec[i] *= a_T;\
  }\
\
  bool is_symmetric() const {\
    unsigned int _D = dimension();\
    for(unsigned int r=0;r<_D;r++) {\
      for(unsigned int c=(r+1);c<_D;c++) {\
        if(value(r,c)!=value(c,r)) return false;\
      }\
    }\
    return true;\
  }\
\
  bool is_antisymmetric() const {\
    unsigned int _D = dimension();\
   {for(unsigned int r=0;r<_D;r++) {\
      if(value(r,r)!=zero()) return false;\
    }}\
    for(unsigned int r=0;r<_D;r++) {\
      for(unsigned int c=(r+1);c<_D;c++) {\
        if(value(r,c)!=minus_one()*value(c,r)) return false;\
      }\
    }\
    return true;\
  }\
\
  void symmetric_part(INLIB_MAT_CLASS& a_res) const {\
    a_res = *this;\
    a_res.transpose();\
    a_res += *this;\
    a_res.multiply(one()/two());\
  }\
\
  void antisymmetric_part(INLIB_MAT_CLASS& a_res) const {\
    a_res = *this;\
    a_res.transpose();\
    a_res.multiply(minus_one());\
    a_res += *this;\
    a_res.multiply(one()/two());\
  }\
\
  T determinant() const {\
    unsigned int ord = dimension();\
    if(ord==0) return zero();\
    else if(ord==1) return value(0,0);\
    else if(ord==2) return (value(0,0) * value(1,1) - \
                            value(1,0) * value(0,1));\
\
    unsigned int rord = ord-1;\
    unsigned int* cs = new unsigned int[rord];\
    unsigned int* rs = new unsigned int[rord];\
\
    T det = zero();\
   {for(unsigned int i=0;i<rord;i++) {cs[i] = i+1;}}\
    unsigned int c = 0;\
\
   {for(unsigned int i=0;i<rord;i++) {rs[i] = i+1;}}\
    bool sg = true; /*c=0+r=0*/\
    for(unsigned int r=0;r<ord;r++) {\
      if(r>=1) rs[r-1] = r-1;\
      T subdet = sub_determinant(rord,rs,cs);\
      if(sg) \
        det += value(r,c) * subdet;\
      else\
        det -= value(r,c) * subdet;\
      sg = sg?false:true;\
    }\
\
    delete [] cs;\
    delete [] rs;\
\
    return det;\
  }\
\
  bool invert(INLIB_MAT_CLASS& a_res) const {\
    /*Generic invertion method.*/\
    unsigned int ord = dimension();\
    if(ord==0) return true;\
\
    if(ord==1) {\
      T v = value(0,0);\
      if(v==zero()) return false;\
      a_res.set_value(0,0,one()/v);\
      return true;\
    }\
  \
    unsigned int rord = ord-1;\
    unsigned int* cs = new unsigned int[rord];\
    unsigned int* rs = new unsigned int[rord];\
  \
    /* Get det with r = 0;*/\
    T det = zero();\
   {\
   {for(unsigned int i=0;i<rord;i++) {rs[i] = i+1;}}\
    unsigned int r = 0;\
    /*if(r>=1) rs[r-1] = r-1;*/\
  \
   {for(unsigned int i=0;i<rord;i++) {cs[i] = i+1;}}\
    bool sg = true; /*r=0+c=0*/\
    for(unsigned int c=0;c<ord;c++) {\
      if(c>=1) cs[c-1] = c-1;\
      T subdet = sub_determinant(rord,rs,cs);\
      T sgn = sg ? one() : minus_one();\
      det += value(r,c) * subdet * sgn;\
      T _value = subdet * sgn;\
      a_res.set_value(c,r,_value);\
      sg = sg?false:true;\
    }}\
  \
    if(det==zero()) {\
      delete [] cs;\
      delete [] rs;\
      return false;\
    }  \
\
   {for(unsigned int c=0;c<ord;c++) {\
      a_res.set_value(c,0,a_res.value(c,0)/det);\
    }}\
  \
   {for(unsigned int i=0;i<rord;i++) {rs[i] = i+1;}}\
    bool sgr = false; /*r=1+c=0*/\
    for(unsigned int r=1;r<ord;r++) {\
      if(r>=1) rs[r-1] = r-1;\
     {for(unsigned int i=0;i<rord;i++) {cs[i] = i+1;}}\
      bool sg = sgr;\
      for(unsigned int c=0;c<ord;c++) {\
        if(c>=1) cs[c-1] = c-1;\
        T subdet = sub_determinant(rord,rs,cs);\
        T sgn = sg ? one() : minus_one();\
        T _value = (subdet * sgn)/det;\
        a_res.set_value(c,r,_value);\
        sg = sg?false:true;\
      }\
      sgr = sgr?false:true;\
    }\
  \
    delete [] cs;\
    delete [] rs;\
\
    return true;\
  }\
\
  void power(unsigned int a_n,INLIB_MAT_CLASS& a_res) const {\
    a_res.set_identity();\
    for(unsigned int i=0;i<a_n;i++) {\
      a_res._mul_mtx(m_vec);\
    }\
  }\
\
  void exp(unsigned int a_le,INLIB_MAT_CLASS& a_res) const {\
    /* result = I + M + M**2/2! + M**3/3! + .... */\
    a_res.set_identity();\
    INLIB_MAT_CLASS tmp;     \
    tmp.set_identity();\
    for(unsigned int i=1;i<=a_le;i++) {\
      tmp._mul_mtx(m_vec);\
      tmp.multiply(one()/T(i)); \
      a_res += tmp;\
    }\
  }\
\
  void log(unsigned int a_le,INLIB_MAT_CLASS& a_res) const {\
    /* result = (M-I) - (M-I)**2/2 + (M-I)**3/3 +... */\
    /* WARNING : touchy, it may not converge ! */\
    a_res.set_zero();\
\
    INLIB_MAT_CLASS M_I;\
    M_I.set_identity();\
    M_I.multiply(minus_one());\
    M_I._add_mtx(m_vec);\
\
    INLIB_MAT_CLASS M_Ip(M_I);\
    T fact = -1;\
\
    INLIB_MAT_CLASS tmp;\
\
    for(unsigned int i=0;i<=a_le;i++) {\
      fact *= minus_one();      \
      tmp = M_Ip;\
      tmp.multiply(fact/T(i+1)); \
      a_res += tmp;\
      M_Ip._mul_mtx(M_I.m_vec);\
    }\
  }\
public: /*operators*/\
  T operator()(unsigned int a_r,unsigned int a_c) const {\
    /*WARNING : no check on a_r,a_c.*/\
    return m_vec[a_r + a_c * dimension()];\
  }\
\
  T& operator[](unsigned int a_index) { /*for inlib/sg/sf_vec*/\
    /*WARNING : no check on a_index.*/\
    return m_vec[a_index];\
  }\
  const T& operator[](unsigned int a_index) const {\
    /*WARNING : no check on a_index.*/\
    return m_vec[a_index];\
  }\
  bool operator==(const INLIB_MAT_CLASS& a_array) const {\
    return equal(a_array);\
  }\
  bool operator!=(const INLIB_MAT_CLASS& a_array) const {\
    return !operator==(a_array);\
  }\
  INLIB_MAT_CLASS& operator*=(const INLIB_MAT_CLASS& a_m) {\
    _mul_mtx(a_m.m_vec);\
    return *this;\
  }\
  INLIB_MAT_CLASS& operator+=(const INLIB_MAT_CLASS& a_m) {\
    _add_mtx(a_m.m_vec);\
    return *this;\
  }\
  INLIB_MAT_CLASS& operator-=(const INLIB_MAT_CLASS& a_m) {\
    _sub_mtx(a_m.m_vec);\
    return *this;\
  }\
  INLIB_MAT_CLASS& operator*=(const T& a_fac) {\
    for(unsigned int i=0;i<dim2();i++) m_vec[i] *= a_fac;\
    return *this;\
  }\
protected:\
  void _copy(const T a_m[]) {\
   {for(unsigned int i=0;i<dim2();i++) m_vec[i] = a_m[i];}\
   /* memcpy does not work with mat<symbol,4> see inlib/tests/symbolic.cpp */\
   /*::memcpy(m_vec,a_m,dim2()*sizeof(T));*/ /*OPTIMIZATION*/\
  }\
\
  void _add_mtx(const T a_m[]) {  /* this = this + a_m, */\
    for(unsigned int i=0;i<dim2();i++) m_vec[i] += a_m[i];\
  }\
  void _sub_mtx(const T a_m[]) {  /* this = this - a_m, */\
    for(unsigned int i=0;i<dim2();i++) m_vec[i] -= a_m[i];\
  }\
\
/*\
  void _mul_mtx(const T a_m[],T a_tmp[]) {\
    unsigned int ord = dimension();\
    for(unsigned int r=0;r<ord;r++) {\
      for(unsigned int c=0;c<ord;c++) {\
        T _value = zero();\
        for(unsigned int i=0;i<ord;i++) {\
          _value += (*(m_vec+r+i*ord)) * (*(a_m+i+c*ord)); //optimize.\
        }\
        *(a_tmp+r+c*ord) = _value;\
      }\
    }\
    _copy(a_tmp);\
  }\
*/\
  void _mul_mtx(const T a_m[],T a_tmp[]) { /*OPTIMIZATION*/\
    /* this = this * a_m */\
    typedef T* Tp;\
    Tp tpos,ttpos,rpos,apos,mpos,aapos;\
    T _value;\
    unsigned int r,c,i;\
\
    unsigned int _D = dimension();\
\
    tpos = a_tmp;\
    for(r=0;r<_D;r++,tpos++) {\
      ttpos = tpos;\
      rpos = m_vec+r;\
      apos = (T*)a_m;\
      for(c=0;c<_D;c++,ttpos+=_D,apos+=_D) {\
        _value = zero();\
        mpos = rpos;\
        aapos = apos;\
        for(i=0;i<_D;i++,mpos+=_D,aapos++) _value += (*mpos) * (*aapos);\
        *ttpos = _value;\
      }\
    }\
    _copy(a_tmp);\
  }\
\
  void _mul_mtx(const T a_m[]) {\
    T* res = new T[dim2()];\
    _mul_mtx(a_m,res);\
    delete [] res;\
  }\
\
  void _left_mul_mtx(const T a_m[]) {\
    /* this = a_m * this */\
    unsigned int _D = dimension();\
    T* res = new T[dim2()];\
    for(unsigned int r=0;r<_D;r++) {\
      for(unsigned int c=0;c<_D;c++) {\
        T _value = zero();\
        for(unsigned int i=0;i<_D;i++) {\
          _value += (*(a_m+r+i*_D)) * (*(m_vec+i+c*_D)); /*optimize.*/\
        }\
        *(res+r+c*_D) = _value;\
      }\
    }\
    _copy(res);\
    delete [] res;\
  }\
\
  T sub_determinant(unsigned int a_ord,\
                    unsigned int aRs[],\
                    unsigned int aCs[]) const {\
    /*WARNING : to optimize, we do not check the content of aRs, aCs.*/\
    unsigned int ord = a_ord;\
    if(ord==0) return zero();\
    else if(ord==1) return value(aRs[0],aCs[0]);\
    else if(ord==2) {\
      /*return (value(aRs[0],aCs[0]) * value(aRs[1],aCs[1]) -\
               value(aRs[1],aCs[0]) * value(aRs[0],aCs[1])); \
      Optimize the upper :*/\
\
      unsigned int r_0 = aRs[0];\
      unsigned int r_1 = aRs[1];\
      unsigned int c_0 = aCs[0];\
      unsigned int c_1 = aCs[1];\
\
      unsigned int _ord = dimension();\
      const T* p = m_vec;\
\
      return ( (*(p+r_0+c_0*_ord)) * (*(p+r_1+c_1*_ord)) -\
               (*(p+r_1+c_0*_ord)) * (*(p+r_0+c_1*_ord)) );\
    }\
\
    unsigned int rord = ord-1;\
    unsigned int* cs = new unsigned int[rord];\
    unsigned int* rs = new unsigned int[rord];\
\
    T det = zero();\
   {for(unsigned int i=0;i<rord;i++) {cs[i] = aCs[i+1];}}\
    unsigned int c = 0;\
    /*if(c>=1) cs[c-1] = c-1;*/\
\
   {for(unsigned int i=0;i<rord;i++) {rs[i] = aRs[i+1];}}\
    bool sg = true; /*c=0+r=0*/\
    for(unsigned int r=0;r<ord;r++) {\
      if(r>=1) rs[r-1] = aRs[r-1];\
      T subdet = sub_determinant(rord,rs,cs);\
      if(sg)\
        det += value(aRs[r],aCs[c]) * subdet;\
      else\
        det -= value(aRs[r],aCs[c]) * subdet;\
      sg = sg?false:true;\
    }\
\
    delete [] cs;\
    delete [] rs;\
\
    return det;\
  }

#endif
