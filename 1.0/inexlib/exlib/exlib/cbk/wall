// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file exlib.license for terms.

#ifndef exlib_cbk_wall
#define exlib_cbk_wall

#include <inlib/wall/data_client>
#include <inlib/wall/protocol>
#include <inlib/wall/send_sg>
#include <inlib/wall/args>

#include <inlib/sg/gv_list>
#include <inlib/sg/gv_entries>
#include <inlib/sg/gv_grid>
#include <inlib/sg/view_plots>

#include "../app/wall_client"
#include "../xml/xml_wall"

namespace exlib {
namespace wall {

inline inlib::sg::bcbk::return_action action_send_plots(inlib::sg::gui_viewer& a_gv,
                                                         inlib::sg::gv_grid<inlib::sg::simple_button>& a_grid) {
  inlib::sg::plots* _plots = inlib::sg::scene_plots(a_gv);
  if(!_plots) {
    a_gv.map_warn("no plots given");
    return inlib::sg::bcbk::return_none;
  }

  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) {
    a_gv.map_warn("viewer is not a wall client");
    return inlib::sg::bcbk::return_none;
  }

  //a_gv.out() << " col " << a_grid.m_selected_col << std::endl;
  //a_gv.out() << " row " << a_grid.m_selected_row << std::endl;

  inlib::args opts;
  opts.add(inlib::wall::s_placement(),inlib::wall::s_plots());

  if(a_grid.back_selected()){
    opts.add(inlib::sg::s_whole(),"true");
  } else {
    opts.add(inlib::sg::s_whole(),"false");
    opts.add(inlib::sg::s_col(),inlib::tos((unsigned int)a_grid.m_selected_col));
    opts.add(inlib::sg::s_row(),inlib::tos((unsigned int)a_grid.m_selected_row));
  }

  // the below does not send a camera.
  bool status = inlib::wall::send_sg(wc->m_data_client,*_plots,a_gv.ziper(),opts);

  if(!status) a_gv.map_warn_failed();
  else        a_gv.map_warn_done();

  return inlib::sg::bcbk::return_to_render;
}

inline inlib::sg::bcbk::return_action action_plots_placement(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  if(!wc->m_data_client.socket().is_connected()) {
    a_gv.map_warn_not_connected();
    return inlib::sg::bcbk::return_to_render;
  }

  // ask wall cols rows :

  float wall_aspect = 1;
  unsigned int cols = 1;
  unsigned int rows = 1;

 {unsigned int ww,wh,bw,bh;
  std::string s;
  if(!wc->m_data_client.get_wall_params(s)){
    a_gv.map_warn_net_error();
    return inlib::sg::bcbk::return_to_render;
  }
  if(!inlib::wall::s2params(s,ww,wh,bw,bh,cols,rows)) {
    a_gv.map_warn("can't get wall params");
    return inlib::sg::bcbk::return_to_render;
  }
  unsigned int wall_ww = cols * (ww+2*bw);
  unsigned int wall_wh = rows * (wh+2*bh);
  wall_aspect = float(wall_ww-2*bw)/float(wall_wh-2*bh);}

  float wcw,wch;
 {float tx,ty,aspect;
  a_gv.get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}

  typedef inlib::sg::gv_grid<inlib::sg::simple_button>::cbk_func func_t; //it should not be needed.
  inlib::sg::gv_grid<inlib::sg::simple_button>* grid =
    new inlib::sg::gv_grid<inlib::sg::simple_button>(a_gv,(func_t)action_send_plots);

  grid->cols = cols;
  grid->rows = rows;
  grid->width = wcw*0.98f;
  grid->height = grid->width.value()/wall_aspect;

  grid->border_height = grid->height*0.1f; //border should be touchable.
  grid->border_width = grid->border_height;

  grid->auto_resize = true;

  a_gv.push_list(grid);
  return inlib::sg::bcbk::return_to_render;
}

inline inlib::sg::bcbk::return_action action_connect(inlib::sg::gui_viewer& a_gv,inlib::sg::entries& a_entries) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  const std::string& host = a_entries.values[0];
  unsigned int port;
  if(!inlib::to<unsigned int>(a_entries.values[1],port)) {
    a_gv.map_warn_nan();
    return inlib::sg::bcbk::return_to_render;
  }
  if(!wc->m_data_client.initialize(host,port)) {
    std::string s("can't connect to ");
    s += host;
    s += " ";
    s += inlib::tos(port);
    a_gv.map_warn(s);
    return inlib::sg::bcbk::return_to_render;
  }
  a_gv.map_warn("connected",false);
  return inlib::sg::bcbk::return_to_render;
}

inline inlib::sg::bcbk::return_action action_walls(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;

  //std::string host;
  //if(!inlib::net::host_name(a_gv.out(),host)){
  //  a_gv.map_warn("cannot get host name");
  //  return return_to_render;
  //}

  //::printf("debug : \"%s\"\n",host.c_str());
  inlib::sg::gv_entries* entries = new inlib::sg::gv_entries(a_gv,action_connect);
  entries->label = "connect";

 {std::vector<std::string> opts;
  //opts.push_back(host);
  const std::vector<exlib::xml::wall>& walls = wc->m_xml_wall.walls();
  inlib_vforcit(exlib::xml::wall,walls,it) opts.push_back((*it).host());
  entries->add_opts("wall front-end",
                    walls.size()?walls.front().host():"",
                    opts);}
  entries->add_uint("port",50800);

  a_gv.push_list(entries);
  return inlib::sg::bcbk::return_to_render;
}


//////////////////////////////////////////////////
/// remote wall control //////////////////////////
//////////////////////////////////////////////////
inline inlib::sg::bcbk::return_action action_toggle_cursor(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  if(!wc->m_data_client.socket().is_connected()) {
    a_gv.map_warn_not_connected();
    return inlib::sg::bcbk::return_to_render;
  }
  if(!wc->m_data_client.socket().send_string(inlib::wall::protocol::s_rwc_toggle_cursor())) {}
  return inlib::sg::bcbk::return_none;
}

inline inlib::sg::bcbk::return_action action_toggle_menu(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  if(!wc->m_data_client.socket().is_connected()) {
    a_gv.map_warn_not_connected();
    return inlib::sg::bcbk::return_to_render;
  }
  if(!wc->m_data_client.socket().send_string(inlib::wall::protocol::s_rwc_toggle_menu())) {}
  return inlib::sg::bcbk::return_none;
}

inline inlib::sg::bcbk::return_action action_gui_wall(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  wc->show_wall_menu();
  return inlib::sg::bcbk::return_to_render;
}

inline inlib::sg::bcbk::return_action action_clear(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  if(!wc->m_data_client.socket().is_connected()) {
    a_gv.map_warn_not_connected();
    return inlib::sg::bcbk::return_to_render;
  }
  if(!wc->m_data_client.socket().send_string(inlib::wall::protocol::s_rwc_clear_scene())) {}
  return inlib::sg::bcbk::return_none;
}

inline inlib::sg::bcbk::return_action action_reset(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  if(!wc->m_data_client.socket().is_connected()) {
    a_gv.map_warn_not_connected();
    return inlib::sg::bcbk::return_to_render;
  }
  if(!wc->m_data_client.socket().send_string(inlib::wall::protocol::s_rwc_reset_camera())) {}
  return inlib::sg::bcbk::return_none;
}

inline inlib::sg::bcbk::return_action action_send_detector(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  return app::wall_client::action_send_detector(*wc);
}

inline inlib::sg::bcbk::return_action action_disconnect(inlib::sg::gui_viewer& a_gv,inlib::sg::list&) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;
  return app::wall_client::action_disconnect(*wc);
}

inline inlib::sg::bcbk::return_action action_main(inlib::sg::gui_viewer& a_gv) {
  exlib::app::wall_client* wc = exlib::app::cast_wall_client(a_gv);
  if(!wc) return inlib::sg::bcbk::return_none;

  inlib::sg::gv_list* list = new inlib::sg::gv_list(a_gv);

  typedef exlib::app::wall_client wc_t;

  list->add_item("connect",action_walls);
  list->add_item("send plots",action_plots_placement);
  list->add_item("send detector",action_send_detector);
  list->add_item("clear",action_clear);
  list->add_item("reset",action_reset);
  list->add_item("toggle cursor",action_toggle_cursor);
  list->add_item("toggle menu",action_toggle_menu);
  list->add_item("gui wall",action_gui_wall);
  list->add_item("disconnect",action_disconnect);

  a_gv.push_list(list);
  return inlib::sg::bcbk::return_to_render;
}

}}

#endif

//exlib_build_use inlib glutess freetype expat zlib png jpeg
