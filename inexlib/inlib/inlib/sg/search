// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_search
#define inlib_sg_search

#include "search_action"
#include "path"

namespace inlib {
namespace sg {

inline const path_t& find_path(search_action& a_action,
                               node& a_from,
                               node* a_node,
                               bool a_verbose) {
  a_action.reset();
  a_action.set_what(search_action::search_path_to_node);
  a_action.set_node(a_node);
  a_from.search(a_action);
  if(!a_action.done()) {
    if(a_verbose) {
      a_action.out() << "inlib::sg::find_path :"
            << " not found node of class " << a_node->s_cls()
            << " from head node of class " << a_from.s_cls()
            << std::endl;
    }
    a_action.clear_path();
    return a_action.path();
  }
  if(a_verbose) {
    a_action.out() << "inlib::sg::find_path :"
          << " found node of class " << a_node->s_cls()
          << " from head node of class " << a_from.s_cls()
          << std::endl;
  }
  const path_t& path = a_action.path();
  if(path.empty()) {
    if(a_verbose) {
      a_action.out() << "inlib::sg::search_node_group :"
            << " node has no path !"
            << std::endl;
    }
    return path;
  }
  if(a_node!=path[path.size()-1]) {
    a_action.out() << "inlib::sg::search_node_group :"
          << " node / path tail mismatch !"
          << " node " << a_node->s_cls()
          << " tail " << path[path.size()-1]->s_cls()
          << std::endl;
    a_action.clear_path();
    return a_action.path();
  }
  return path;
}  

template <class NODE>
inline const search_action::paths_t& find_paths(search_action& a_action,
                                                node& a_from){
  a_action.reset();
  a_action.set_what(search_action::search_path_to_node_of_class);
  a_action.set_class(NODE::s_class());
  a_from.search(a_action);
  return a_action.paths();
}

template <class NODE>
inline NODE* find_ancestor(std::ostream& a_out,
                           node& a_from,node* a_node,bool a_verbose) {
  search_action action(a_out);
  return rfind<NODE>(find_path(action,a_from,a_node,a_verbose));
}

template <class CONTAINER>
inline CONTAINER* find_container(std::ostream& a_out,
                                 node& a_from,node* a_node,bool a_verbose) {
  search_action action(a_out);
  return container<CONTAINER>(find_path(action,a_from,a_node,a_verbose));
}

}}

#endif
