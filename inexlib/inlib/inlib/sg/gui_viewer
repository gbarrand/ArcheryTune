// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_gui_viewer
#define inlib_sg_gui_viewer

#include "../platform"

#include "guiv"

#include "gui_items"
#include "holder" //for m_tmp_group
#include "selection"
#include "torche"
#include "progress"
#include "depth_test"
#include "ortho"
#include "perspective"
#include "frustum"
#include "lrbt"
#include "simple_button"
#include "button_grid"
#include "cube_manip"
#include "search"
#include "camera_anim"
#include "count_action"
#include "scroll_text"
#include "scroll_infos"
#include "entry"
#include "entries"
#include "shade_model"
#include "params2entries"
#include "opener"

#include "../cbk/timer"
#include "../event_timer"
#include "../mapmanip"

#include "fundata_cbk"
#include "gv_cbk"
#include "base_dumper"
#include "zb_manager"
#include "mem_action"
#include "../atime2s"
#include "../squote"
#include "../svar"
#include "../chars"

#include "../sys/file" //tmpname

#include "../insh"
#include "../paper_format"
#include "write_paper"
#include "write_bsg"
//#include "write_exsg"

#include "../get_lines"
#include "senum"
#include "../parse"
#include "../insh_ls"
#include "../insh_console" //windows.h

#include "slice_anim"
#include "../sglprims"
#include "../iabs"

#include "object_manager"

//#ifdef _MSC_VER
//#pragma warning(disable:4355)
//#endif

namespace inlib {
namespace sg {

INLIB_GLOBAL_STRING(zoom_in_out)
INLIB_GLOBAL_STRING(zoom_in_out_rot)

class gui_viewer : public guiv {
  INLIB_HEADER(gui_viewer,inlib::sg::gui_viewer,guiv)
private:
  INLIB_CLASS_STRING(event_timer)
protected:
  typedef std::vector<void*> ptrs_t;
public:
  static int SHOWN() {return 0;}
  static int HIDDEN() {return 1;}
public: //Android, iPhone.
  virtual void set_size(unsigned int a_w,unsigned int a_h) {
    //m_out << "debug : inlib::sg::gui_viewer::set_size :"
    //      << " ww " << a_w
    //      << " wh " << a_h
    //      << std::endl;
    parent::set_size(a_w,a_h);
    ask_to_rebuild_gui(); //should have a set_gui_layout().
    cursor_visible.touch();
  }

public: //alert
  virtual void warn(const std::string& a_msg,bool a_warn = true) {
    // if needed we could secure the execution in a work.
    map_warn(a_msg,a_warn);
  }
  virtual std::ostream& out_stream() const {return m_out;}
  virtual void show_console(const std::string& a_v) {
    m_console.set_label(a_v);
    show_console();
  }
public: //guib
  virtual void ask_to_rebuild_gui() {
    // invalidate cbks that contain pointer to buttons that are going to be deleted.
    invalidate_works(arm_work::s_class());
    invalidate_works(disarm_work::s_class());
    gui_visible.touch();
  }
public:
  virtual bool has_mail_panel() {return false;}
  virtual bool mail_panel(const std::string& /*a_to*/,
                          const std::string& /*a_subject*/,
                          const std::string& /*a_msg*/,
                          const std::string& /*a_path*/,
                          const std::string& /*a_mime*/){
    return false;
  }
  virtual bool has_open_panel() {return false;}
  virtual bool open_panel(std::string& a_path) {a_path.clear();return false;}
public: //OpenGL infos.
  // see exlib/sg/GL_VIEWER
  virtual void gl_infos(std::vector<std::string>& a_v) const {a_v.clear();}
public:
  template <class T>
  void num2console(const T& a_v) {
    std::string stmp;
    if(!num2s(a_v,stmp)) {}
    m_console.set_label(stmp);
    show_console();
  }
  void atime2console(const atime& a_time) {
    std::string stmp = atime2s(a_time);
    m_console.set_label(stmp);
    //a_gv.m_params.m_console_width = 0.6F;
    //set_console_layout();
    show_console();
  }

public:
  virtual void clear_scene() {
    m_scene->clear();
    m_scene->clear_cbks();
    set_scene_camera(0);
    m_params.m_plane_viewer = true;
    m_params.m_cam_tiled = true;
    m_scene_light = 0;
    m_scene_blend = 0;
    m_scene_shade_model = 0;
    hide_sliders();
    //stop_cam_anim();  //any cam_anim node are now deleted.
    //NOTE : we do not stop the event anim here. Someone may want to
    //       clear the scene for one event but continue to vis
    //       further events.
    //stop_event_anim();
  }

  // cursor :
  virtual bool set_cursor_shape(cursor_shape a_shape) {
    cursor_model = a_shape;
    return true;
  }

  ///////////////////////////////////////////////////
  /// virtual for wall/screen_main : ////////////////
  ///////////////////////////////////////////////////

  virtual selection* create_selection() const {return new selection;}

  virtual base_camera* create_camera(camera_type a_type,float a_near_height,float a_near) {
    if(a_type==camera_ortho) {
      ortho* camera = new ortho;
      camera->height = a_near_height;
      camera->znear = a_near;
      return camera;
    } else if(a_type==camera_perspective) {
      perspective* camera = new perspective;

      float angle = 2 * fatan((a_near_height*0.5f)/a_near);

      camera->height_angle = angle;
      camera->znear = a_near;

      return camera;
    } else {
      return 0;
    }
  }

  // in case cam ortho, get one screen world coords size :
  virtual void get_gui_wcw_wch(float& a_wcw,float& a_wch,float& a_tx,float& a_ty,float& a_aspect) const {
    get_screen_wcw_wch(gui_camera_height(),0,0,a_wcw,a_wch,a_tx,a_ty,a_aspect);
    if(m_vr_mode) a_wcw *= 0.5;
  }

  virtual void get_screens(unsigned int& a_cols,unsigned int& a_rows){
    a_cols = 1;
    a_rows = 1;
  }

  virtual void get_screen_wcw_wch(float a_cam_height,
                                  unsigned int,unsigned int,
                                  float& a_wcw,float& a_wch,
                                  float& a_tx,float& a_ty,
                                  float& a_aspect) const {
    a_aspect = float(m_ww)/float(m_wh);
    a_wch = a_cam_height;
    a_wcw = a_wch*a_aspect;
    a_tx = 0;
    a_ty = 0;
  }

  virtual void get_gui_all_wcw_wch(float& a_wcw,float& a_wch) const {
    float aspect = float(m_ww)/float(m_wh);
    a_wch = gui_camera_height();
    a_wcw = a_wch*aspect;
  }

  virtual void get_inside_pixels(unsigned int& a_w,unsigned int& a_h) const {
    a_w = m_ww;
    a_h = m_wh;
  }

  virtual void screen_to_gui(int a_ix,int a_iy,float& a_x,float& a_y) const {
    // for popup.
    float aspect = float(m_ww)/float(m_wh);
    float wch = gui_camera_height();
    float wcw = wch*aspect;
    a_x = float(a_ix)*wcw/float(m_ww)-wcw*0.5f;
    a_y = float(a_iy)*wch/float(m_wh)-wch*0.5f;
  }

  virtual void toggle_camera_menu_at_pos(int,int) {toggle_camera_menu();}

  virtual bool treat_anim(const atime& a_t) {
    anim_event e(a_t.seconds(),a_t.micro_seconds());
    event_action action(m_out,m_ww,m_wh,e);
    m_sg.event(action);
    return e.some_found(); //someone did something with this event.
  }

  virtual void enable_anim() {
    if(has_valid_work(anim_work::s_class())) return;
    add_work(new anim_work(*this));
    m_params.m_anim_on = true;
    m_camenu_disable_anim_image_button.color = colorf_pink();
    m_camenu_disable_anim_text_button.back_area::color = colorf_pink();
  }

  virtual void disable_anim() {
    invalidate_works(anim_work::s_class());
    m_params.m_anim_on = false;
    m_camenu_disable_anim_image_button.color = m_params.m_gui_back_color;
    m_camenu_disable_anim_text_button.back_area::color = m_params.m_gui_back_color;
  }

  virtual void ask_to_sync_clients() {}

  virtual void wait_sync_client() {}

  virtual void clear_caches() {m_tmp_group.clear();}

  ////////////////////////////////////
  /// camedit panel : ////////////////
  ////////////////////////////////////
protected:
  virtual bool swap_scene_camera_kind(){
    if(!m_scene_camera) return false;

    base_camera* new_cam = 0;

    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){
      //have to find a correct value for an ortho height.

      ortho* new_oc = new ortho;
      new_oc->height = 2.0f*m_scene_camera->focal.value()*ftan(pc->height_angle.value()*0.5f);
      new_cam = new_oc;

    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
      //have to find a correct value for a perspective angle_height.

      perspective* new_pc = new perspective;
      // we assume that ortho height "at focal" is a good parameter
      // to guess a reasonnable perspective height_angle.
      new_pc->height_angle = 2.0f*fatan2(0.5f*oc->height.value(),m_scene_camera->focal.value());
      new_cam = new_pc;

    } else {
      m_out << "inlib::sg::gui_viewer::swap_scene_camera_kind :"
            << " camera not ortho and not perspective."
            << std::endl;
      return false;
    }

    new_cam->znear = m_scene_camera->znear;
    new_cam->zfar = m_scene_camera->zfar;
    new_cam->position = m_scene_camera->position;
    new_cam->orientation = m_scene_camera->orientation;
    new_cam->dx = m_scene_camera->dx;
    new_cam->da = m_scene_camera->da;
    new_cam->ds = m_scene_camera->ds;
    new_cam->focal = m_scene_camera->focal;

    set_scene_camera(new_cam);

    return true;
  }
public:
  bool swap_camera_kind() {
    base_camera* cam = m_scene_camera;
    if(!cam) return false;
    group* grp = find_container<group>(m_out,*m_scene,*cam,false);
    if(!grp) return false;
    if(!swap_scene_camera_kind()) return false;
    base_camera* new_cam = m_scene_camera;
    return grp->replace(cam,new_cam,true);
  }

public:
  virtual inlib::opener& opener() {return m_opener;} //inlib:: needed.
private:
  sf<bool> gui_visible;
public:

  sf<bool> cursor_visible;
  sf<float> cursor_line_width;
  sf_enum<cursor_shape> cursor_model;

  sf<bool> params_button_visible;
  sf<bool> camera_button_visible;

  sf<bool> camenu_edit_visible;
  sf<bool> camenu_90_visible;
  sf<bool> camenu_focal_visible;
  sf<bool> camenu_viewing_visible;
  sf<bool> camenu_view_all_visible;
public:
  gui_viewer(std::ostream& a_out,
             render_manager& a_gl_mgr,
             const base_freetype& a_ttf,    //template ttf node.
             const selection& a_selection,  //template selection node.
             unsigned int a_width,unsigned int a_height,
             bool a_verbose = false)
  :parent(a_out,a_width,a_height,a_verbose)
  ,gui_visible(true)
  ,cursor_visible(false)
  ,cursor_line_width(2)
  ,cursor_model(cursor_default)
  ,params_button_visible(true)
  ,camera_button_visible(true)

  ,camenu_edit_visible(true)
  ,camenu_90_visible(true)
  ,camenu_focal_visible(true)
  ,camenu_viewing_visible(true)
  ,camenu_view_all_visible(true)

  ,m_render_manager(a_gl_mgr)
  ,m_ttf(a_ttf)

  ,m_scene(0)

  ,m_scene_camera(0)
  ,m_reset_camera(0)
  ,m_scene_light(0)
  ,m_scene_blend(0)
  ,m_scene_shade_model(0)

  ,m_gui(0)

  ,m_camenu_anim_mode_button(a_ttf)
  ,m_camenu_sshoot_text_button(a_ttf)
  ,m_camenu_90_text_button(a_ttf)
  ,m_camenu_focal_button(a_ttf)
  ,m_camenu_viewing_button(a_ttf)
  ,m_camenu_gsto_text_button(a_ttf)
  ,m_camenu_light_text_button(a_ttf)
  ,m_camenu_blend_text_button(a_ttf)
  ,m_camenu_smooth_text_button(a_ttf)
  ,m_camenu_plane_exam_button(a_ttf)
  ,m_camenu_disable_anim_text_button(a_ttf)
  ,m_console(a_ttf)

  ,m_popup_cbks()

  ,m_meta_had_been_shown(false)

  ,m_tab_current(-1)

  ,m_touch_in_motion(false)
  ,m_touch_prev_x(0)
  ,m_touch_prev_y(0)

  ,m_gesture_begin_x(0)
  ,m_gesture_begin_y(0)
  ,m_gesture_begin_camera(0)

  ,m_motion_slider(0)

  //,m_treat_mouse_motion(false)

  ,m_cursor_camera(0)

  ,m_memory_warning(false)
  //,m_jpeg_data(a_out)

  //,m_action_prots()

  ,m_dumpers()
  ,m_opener(get_me(),0)
  ,m_png_writer(0)
  ,m_jpeg_writer(0)
  ,m_vr_mode(false)
  ,m_insh(get_me())
  ,m_object_manager(a_out)
  {
    m_scene = safe_cast<node,selection>(*(a_selection.copy()));
    m_gui = safe_cast<node,selection>(*(a_selection.copy()));

    m_object_manager.add_source(m_scene,"viewer_scene"); //dangerous. m_scene must not be deleted.

    //WARNING : in m_sg, m_scene_switch expected at 0, m_gui at 1.
    //          If changing that, look at touch_[down,up]().
    m_sg.add(new noderef(m_scene_switch));

    m_scene_switch.add(new noderef(*m_scene));
    m_scene_switch.add(new separator());
    m_scene_switch.which = gui_visible.value()?HIDDEN():SHOWN();

    //m_gui after m_scene because it disables depth test.
    // (But for picking it should be traversed first !)
    m_sg.add(new noderef(*m_gui));

    m_gui->down_cbks().add(new gv_cbk(*this,action_touch_down));
    m_gui->up_cbks().add(new gv_cbk(*this,action_touch_up));
    m_gui->move_cbks().add(new gv_cbk(*this,action_touch_move));

    //m_gui->stop_at_first = true; //FIXME : because of buttons.
    //m_gui->verbose = true;

    m_sg.add(new noderef(m_cursor));

    m_main_menu_switch.which = gui_visible.value()?SHOWN():HIDDEN();
    m_camenu_switch.which = HIDDEN();
    m_gui_sliders_switch.which = HIDDEN();
    m_sliders_switch.which = HIDDEN();
    m_progress_switch.which = HIDDEN();
    m_console_switch.which = HIDDEN();
    m_popup_switch.which = HIDDEN();
    m_meta_switch.which = HIDDEN();
    m_cursor_switch.which = HIDDEN();

    m_cursor_matrix.set_identity();

    set_arconf(m_params,m_console,"");
    m_console.hjust = sg::left;
    m_console.confine = false;
    m_console.add_callback
      (new fundata_cbk<gui_viewer,_switch,pos_data>(*this,m_console_switch,action_hide,pos_data(false,0,0)));

    // set default gsto mode on m_params :
    gsto_mode2s(m_render_manager.get_gsto_mode(),m_params.m_gsto_mode);

    ////////////////////////////////////////////
    /// insh : /////////////////////////////////
    ////////////////////////////////////////////
    insh_add_cmds();

   {std::string HOME;
    dir::home(HOME);
    m_insh.add_env("HOME",HOME);}
  }
  virtual ~gui_viewer(){
    safe_clear<std::string,base_dumper>(m_dumpers);
    delete m_reset_camera;
    delete m_gesture_begin_camera;
    delete m_scene;
    delete m_gui;
  }
protected:
  gui_viewer(const gui_viewer& a_from)
  :ui(a_from)
  ,alert(a_from)
  ,parent(a_from)

  ,gui_visible(a_from.gui_visible)
  ,cursor_visible(a_from.cursor_visible)
  ,cursor_line_width(a_from.cursor_line_width)
  ,cursor_model(a_from.cursor_model)
  ,params_button_visible(a_from.params_button_visible)
  ,camera_button_visible(a_from.camera_button_visible)

  ,camenu_edit_visible(a_from.camenu_edit_visible)
  ,camenu_90_visible(a_from.camenu_90_visible)
  ,camenu_focal_visible(a_from.camenu_focal_visible)
  ,camenu_viewing_visible(a_from.camenu_viewing_visible)
  ,camenu_view_all_visible(a_from.camenu_view_all_visible)

  ,m_render_manager(a_from.m_render_manager)
  ,m_ttf(a_from.m_ttf)

  ,m_scene(0)

  ,m_scene_camera(0)
  ,m_reset_camera(0)
  ,m_scene_light(0)
  ,m_scene_blend(0)
  ,m_scene_shade_model(0)

  ,m_gui(0)

  ,m_camenu_anim_mode_button(m_ttf)
  ,m_camenu_sshoot_text_button(m_ttf)
  ,m_camenu_90_text_button(m_ttf)
  ,m_camenu_focal_button(m_ttf)
  ,m_camenu_viewing_button(m_ttf)
  ,m_camenu_gsto_text_button(m_ttf)
  ,m_camenu_light_text_button(m_ttf)
  ,m_camenu_blend_text_button(m_ttf)
  ,m_camenu_smooth_text_button(m_ttf)
  ,m_camenu_plane_exam_button(m_ttf)
  ,m_camenu_disable_anim_text_button(m_ttf)
  ,m_console(m_ttf)

  ,m_popup_cbks(a_from.m_popup_cbks)

  ,m_meta_had_been_shown(false)

  ,m_touch_in_motion(false)
  ,m_touch_prev_x(0)
  ,m_touch_prev_y(0)

  ,m_gesture_begin_x(0)
  ,m_gesture_begin_y(0)
  ,m_gesture_begin_camera(0)

  ,m_motion_slider(0)

  //,m_treat_mouse_motion(false)

  ,m_cursor_camera(0)

  ,m_memory_warning(false)

  //,m_action_prots(a_from.m_action_prots)

  //,m_jpeg_data(a_from.m_out)
  ,m_dumpers()
  ,m_opener(a_from.m_opener)
  ,m_image_readers(a_from.m_image_readers)
  ,m_png_writer(a_from.m_png_writer)
  ,m_jpeg_writer(a_from.m_jpeg_writer)
  ,m_vr_mode(a_from.m_vr_mode)
  ,m_argcv(a_from.m_argcv)
  ,m_insh(a_from.m_insh)
  //,m_object_manager(a_from.m_object_manager)
  ,m_object_manager(a_from.m_out)
  {
    //m_scene = safe_cast<node,selection>(*(a_from.m_scene->copy()));
    //m_gui = safe_cast<node,selection>(*(a_from.m_scene->copy()));
    //m_scene->clear();
    //m_gui->clear();

    delete m_reset_camera;
    m_reset_camera = a_from.m_reset_camera?a_from.m_reset_camera->copy():0;

    copy<std::string,base_dumper>(m_dumpers,a_from.m_dumpers);
  }

  gui_viewer& operator=(const gui_viewer& a_from){
    parent::operator=(a_from);

    if(&a_from==this) return *this;

    gui_visible = a_from.gui_visible;
    cursor_visible = a_from.cursor_visible;
    cursor_line_width = a_from.cursor_line_width;
    cursor_model = a_from.cursor_model;
    params_button_visible = a_from.params_button_visible;
    camera_button_visible = a_from.camera_button_visible;

    camenu_edit_visible = a_from.camenu_edit_visible;
    camenu_90_visible = a_from.camenu_90_visible;
    camenu_focal_visible = a_from.camenu_focal_visible;
    camenu_viewing_visible = a_from.camenu_viewing_visible;
    camenu_view_all_visible = a_from.camenu_view_all_visible;

    m_scene_camera = 0;

    delete m_reset_camera;
    m_reset_camera = a_from.m_reset_camera?a_from.m_reset_camera->copy():0;
    m_scene_light = 0;
    m_scene_blend = 0;
    m_scene_shade_model = 0;

    m_popup_cbks = a_from.m_popup_cbks;

    m_meta_had_been_shown = false;

    m_touch_in_motion = false;
    m_touch_prev_x = 0;
    m_touch_prev_y = 0;
    m_touches.clear();

    m_gesture_begin_x = 0;
    m_gesture_begin_y = 0;
    m_gesture_begin_camera = 0;

    m_motion_slider = 0;

    //m_treat_mouse_motion = false;

    m_cursor_camera = 0;

    m_memory_warning = false;

    //m_action_prots = a_from.m_action_prots;

    copy<std::string,base_dumper>(m_dumpers,a_from.m_dumpers);

    m_png_writer = a_from.m_png_writer;
    m_jpeg_writer = a_from.m_jpeg_writer;

    m_vr_mode = a_from.m_vr_mode;
    m_argcv = a_from.m_argcv;
    m_insh = a_from.m_insh;

    return *this;
  }
public:
  const gui_viewer& get_me() const {return *this;}
  gui_viewer& get_me() {return *this;}

  const base_freetype& ttf() const {return m_ttf;}

  sg::zb_manager& zb_manager() {return m_zb_mgr;}
  sg::gl2ps_manager& gl2ps_manager() {return m_gl2ps_mgr;}

  //void set_vr_mode(bool a_value) {
  //  m_vr_mode = a_value;
  //  ask_to_rebuild_gui();
  //}
  //bool vr_mode() const {return m_vr_mode;}
public:
  ///////////////////////////////////////////////////
  /// wall : for communication with sg_client : /////
  ///////////////////////////////////////////////////

  typedef std::map<unsigned int,std::string> action_prots_t;
/*
  const action_prots_t& action_prots() const {return m_action_prots;}
  //action_prots_t& action_prots() {return m_action_prots;}

  bool find_prot_action(const std::string& a_prot,unsigned int& a_action) {
    // used in wall/screen_dispatch :
    std::map<unsigned int,std::string>::const_iterator it;
    for(it=m_action_prots.begin();it!=m_action_prots.end();++it){
      if((*it).second==a_prot) {
        a_action = (*it).first;
        return true;
      }
    }
    a_action = 0;
    return false;
  }
*/
/* previously used in exlib/app/wall_client :
  void set_wall_action_prots() {
    //used by wall_screen and wall data client programs.

    // See wall/screen_dispatch/EVT_USER_COMMAND.
    //IMPORTANT : action id must be the gui_viewer::gui_cbk ones.

    m_action_prots[gui_cbk::action_single_shoot()] = wall::protocol::s_rwc_single_shoot();
    m_action_prots[gui_cbk::action_90()] = wall::protocol::s_rwc_90();
    m_action_prots[gui_cbk::action_anim_shift()] = wall::protocol::s_rwc_anim_shift();
    m_action_prots[gui_cbk::action_anim_around_focal()] = wall::protocol::s_rwc_anim_around_focal();
    m_action_prots[gui_cbk::action_viewing()] = wall::protocol::s_rwc_viewing();

    m_action_prots[gui_cbk::action_reset_camera()] = wall::protocol::s_rwc_reset_camera();

    m_action_prots[gui_cbk::action_left()] = wall::protocol::s_rwc_left();
    m_action_prots[gui_cbk::action_right()] = wall::protocol::s_rwc_right();
    m_action_prots[gui_cbk::action_up()] = wall::protocol::s_rwc_up();
    m_action_prots[gui_cbk::action_down()] = wall::protocol::s_rwc_down();

    m_action_prots[gui_cbk::action_clear_scene()] = wall::protocol::s_rwc_clear_scene();

    m_action_prots[gui_cbk::action_cam_anim_zoom_in_out()] = wall::protocol::s_rwc_cam_anim_zoom_in_out();
    m_action_prots[gui_cbk::action_cam_anim_zoom_in_out_rot()] = wall::protocol::s_rwc_cam_anim_zoom_in_out_rot();
  }
*/

  bool receive_document_buffer(char* a_buffer,unsigned int a_length,const std::string& a_arg_sep) {
    char* copt = str_dup(a_buffer);
    std::string options(copt);
    str_del(copt);

    size_t lopt = options.size();
    size_t ldoc = a_length-(lopt+1);
    char* pdoc = a_buffer+lopt+1;

    if(ldoc==0) {
      m_out << "inlib::sg::gui_viewer::receive_document_buffer :"
            << " WARNING : receive an empty document."
            << std::endl;
      //not fatal
      return true;
    }

    //see inlib/sg/send
    args _args(options,a_arg_sep,false);
    bool done;
    if(!opener().open(ldoc,pdoc,_args,done)){
      m_out << "inlib::sg::gui_viewer::receive_document_buffer :"
            << " open buffer failed."
            << std::endl;
      //not fatal
      win_render();
      return true;
    }

    if(done) {
      win_render();
      return true;
    }

    std::string DOCUMENT;
    if(!tmpname(m_tmp_dir,"gui_viewer_","",DOCUMENT)) {
      m_out << "inlib::sg::gui_viewer::receive_document_buffer :"
            << " can't get tmp file name."
            << std::endl;
      return false;
    }

    if(!file::write_bytes(DOCUMENT,pdoc,ldoc)) {
      m_out << "inlib::sg::gui_viewer::receive_document_buffer :"
            << " can't write file " << inlib::sout(DOCUMENT) << "."
            << std::endl;
      return false;
    }

    if(!opener().open(DOCUMENT,file::s_format_guessed(),_args,done) || !done) {
      m_out << "inlib::sg::gui_viewer::receive_document_buffer :"
            << " open_file failed."
             << std::endl;
      //not fatal
    }
    win_render();

    ::remove(DOCUMENT.c_str());

    return true;
  }

  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////

  virtual void set_event_anim(event_timer* a_timer) { //get ownership. //virtual for WebGL
    add_in_tmp_group<event_timer>(s_event_timer(),a_timer);
    add_work(new cbk::timer(*this,*a_timer));
  }

  void stop_event_anim() { // Used in exlib/[pmx,agora,cbk/lhc1].
    cbk::timer::invalidate_timer_works(*this,event_timer::s_class());
    remove_in_tmp_group<event_timer>(s_event_timer());
  }

  node* create_to_stop_event_anim_holder() { //see exlib/geant4/exas for an example.
    return new holder<to_stop_event_anim>(new to_stop_event_anim(*this));
  }
  ///////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////

  const selection& sg_ui() const {return *m_gui;}
  selection& sg_ui() {return *m_gui;}

  void arm_button(base_button* a_node) {
    add_work(new arm_work(*this,a_node));
    m_arm_buttons.push_back(a_node);
  }
  void trigger_button(base_button* a_node) {
    add_work(new disarm_work(*this,a_node));
    add_work_cbks(a_node->cbks().callbacks(),true);
  }

  selection& scene() {return *m_scene;}
  const selection& scene() const {return *m_scene;}

  bool scene_center(vec3f& a_center) {
    bbox_action action(m_out);
    m_scene->bbox(action);
    if(!action.end()) {
      m_out << "inlib::sg::gui_viewer::scene_center :"
            << " bad bbox_action end."
            << std::endl;
      a_center.set_value(0,0,0);
      return false;
    }
    return action.box().center(a_center);
  }

  ////////////////////////////////////////////
  /// special scene nodes ////////////////////
  ////////////////////////////////////////////
  torche* scene_light() const {return m_scene_light;}
  void set_scene_light(torche* a_light) {
    //we don't get ownership of a_light.
    m_scene_light = a_light;
    if(m_scene_light) m_scene_light->on = m_params.m_light_on;
  }

  bool set_scene_light_on(bool a_value) {
    if(!m_scene_light) return false;
    m_scene_light->on = a_value;
    m_params.m_light_on = a_value; //keep in sync.
    if(a_value) {
      m_camenu_light_image_button.color = colorf_pink();
      m_camenu_light_text_button.back_area::color = colorf_pink();
    } else {
      m_camenu_light_image_button.color = m_params.m_gui_back_color;
      m_camenu_light_text_button.back_area::color = m_params.m_gui_back_color;
    }
    return true;
  }

  blend* scene_blend() const {return m_scene_blend;}
  void set_scene_blend(blend* a_blend) {
    //we don't get ownership of a_blend.
    m_scene_blend = a_blend;
    if(m_scene_blend) m_scene_blend->on = m_params.m_blend_on;
  }
  bool set_scene_blend_on(bool a_value) {
    if(!m_scene_blend) return false;
    m_scene_blend->on = a_value;
    m_params.m_blend_on = a_value; //keep in sync.
    if(a_value) {
      m_camenu_blend_image_button.color = colorf_pink();
      m_camenu_blend_text_button.back_area::color = colorf_pink();
    } else {
      m_camenu_blend_image_button.color = m_params.m_gui_back_color;
      m_camenu_blend_text_button.back_area::color = m_params.m_gui_back_color;
    }
    return true;
  }

  shade_model* scene_shade_model() const {return m_scene_shade_model;}
  void set_scene_shade_model(shade_model* a_shade_model) {
    //we don't get ownership of a_shade_model.
    m_scene_shade_model = a_shade_model;
    if(m_scene_shade_model) {
      if(m_params.m_smooth_on) {
        m_scene_shade_model->model = shade_smooth;
      } else {
        m_scene_shade_model->model = shade_flat;
      }
    }
  }
  bool set_scene_smooth_on(bool a_value) {
    if(!m_scene_shade_model) return false;
    if(a_value) {
      m_scene_shade_model->model = shade_smooth;
    } else {
      m_scene_shade_model->model = shade_flat;
    }
    m_params.m_smooth_on = a_value; //keep in sync.
    if(a_value) {
      m_camenu_smooth_image_button.color = colorf_pink();
      m_camenu_smooth_text_button.back_area::color = colorf_pink();
    } else {
      m_camenu_smooth_image_button.color = m_params.m_gui_back_color;
      m_camenu_smooth_text_button.back_area::color = m_params.m_gui_back_color;
    }
    return true;
  }

  void set_use_gsto(bool a_value) {
    m_use_gsto = a_value;
    m_params.m_use_gsto = a_value; //keep in sync m_params.

   {typedef sg::gsto_mode mode_t;
    mode_t mode;
    if(!s2gsto_mode(m_params.m_gsto_mode,mode)){
      m_out << "inlib::sg::gui_viewer::set_use_gsto :"
            << " unknown gsto mode " << m_params.m_gsto_mode << "."
            << std::endl;
    }
    m_render_manager.set_gsto_mode(mode);
    if(m_render_manager.get_gsto_mode()!=mode) {
      //m_out << "inlib::sg::gui_viewer::set_use_gsto :"
      //      << " gsto mode " << m_params.m_gsto_mode
      //      << " not accepted by the gl manager."
      //      << std::endl;
    }}

    // the gl manager may refuse the given value :
    gsto_mode2s(m_render_manager.get_gsto_mode(),m_params.m_gsto_mode);

    if(m_params.m_use_gsto) {
      m_camenu_gsto_image_button.color = colorf_pink();
      m_camenu_gsto_text_button.back_area::color = colorf_pink();
      //m_params.m_gui_button_active_color;
    } else {
      m_camenu_gsto_image_button.color = m_params.m_gui_back_color;
      m_camenu_gsto_text_button.back_area::color = m_params.m_gui_back_color;
    }

  }

  ////////////////////////////////////////////
  /// camera /////////////////////////////////
  ////////////////////////////////////////////
  base_camera* scene_camera() const {return m_scene_camera;}

  bool camera_height_at_focal(float& a_h) const {
    if(!m_scene_camera) {a_h = 2;return false;}
    return m_scene_camera->height_at_focal(a_h);
  }

  void set_scene_camera(base_camera* a_camera,bool a_set_reset_cam = true) {
    //we don't get ownership of a_camera.
    m_scene_camera = a_camera;
    _set_params_camera();

    if(a_set_reset_cam){
      delete m_reset_camera;
      m_reset_camera = a_camera?a_camera->copy():0;
    }
  }

/*
  float scene_camera_radius() {
    if(!m_scene_camera) return 10000; //10*m A01

    ortho* oc = safe_cast<node,ortho>(*m_scene_camera);
    if(oc) return oc->height;

    perspective* pc = safe_cast<node,perspective>(*m_scene_camera);
    if(pc) {
      //reverse of exlib/opener/exsg_create_camera.
      float pos = pc->position.value().length();
      return pos * ftan(pc->height_angle.value()*0.5f);
    }

    return 10000; //10*m A01
  }
*/

  void start_anim_around_focal() { //for exlib/cbk/anim
    if(!m_params.m_anim_around_focal) {
      bcbk* cbk = new gv_cbk(*this,action_toggle_param_anim_around_focal);
      cbk->action();
      delete cbk;
    }
    bcbk* cbk = new gv_cbk(*this,action_right);
    cbk->action();
    delete cbk;
  }

  bool update_anim_motion(anim_what a_anim,anim_mode a_anim_mode) {
    int move;
    if(!anim2motion(a_anim,a_anim_mode,move)) return false;
    if(!m_scene_camera) return false;
    if(!m_scene_camera->update_motion(move)) return false;
    hide_meta_zone();
    return true;
  }
public:
  ////////////////////////////////////////////
  /// scene operations ///////////////////////
  ////////////////////////////////////////////
/*
  void delete_manips() {
    typedef search_action::path_t path_t;
    typedef search_action::paths_t paths_t;
    typedef cube_manip cm_t;

    search_action sa(m_out);
    const paths_t& paths = find_paths<cm_t>(sa,*m_scene);

    paths_t::const_iterator it;
    for(it=paths.begin();it!=paths.end();++it) {
      const path_t& p = *it;
      group* grp = container<group>(p);
      if(!grp) {
        m_out << "gui_viewer::delete_manips :"
                      << " cube_manip parent group not found."
                      << std::endl;
      } else {
        cm_t* cm = tail<cm_t>(p);
        if(!cm) {
          m_out << "inlib::sg::gui_viewer::delete_manips :"
                        << " cube_manip path with bad tail."
                        << std::endl;
        } else {
          node* parent;
          node* node;
          cm->get_node(parent,node);
          if(!parent||!node) {
            m_out << "inlib::sg::gui_viewer::delete_manips :"
                          << " cube_manip without a maniped node."
                          << std::endl;
          }

          matrix* m = new matrix;
          m->mtx = cm->mtx;
          grp->replace(cm,m,true); // it deletes cm.

          if(parent && node) {
            group* pgrp = safe_cast<node,group>(*parent);
            if(pgrp && pgrp->remove(node)) {
              delete node;
            } else {
              m_out << "inlib::sg::gui_viewer::delete_manips :"
                            << " maniped node not in the expected parent."
                            << std::endl;
            }
          }
        }
      }
    }

  }
*/

  void remove_manips() {
    // but do not delete the working node.

    typedef cube_manip cm_t;

    search_action sa(m_out);
    const paths_t& paths = find_paths<cm_t>(sa,*m_scene);

    paths_t::const_iterator it;
    for(it=paths.begin();it!=paths.end();++it) {
      const path_t& p = *it;
      group* grp = container<group>(p);
      if(!grp) {
        m_out << "inlib::sg::gui_viewer::reset_manips : cube_manip parent group not found." << std::endl;
      } else {
        cm_t* cm = tail<cm_t>(p);
        if(!cm) {
          m_out << "inlib::sg::gui_viewer::reset_manips : cube_manip path with bad tail." << std::endl;
        } else {
          matrix* m = new matrix;
          m->mtx = cm->m_start_matrix;
          grp->replace(cm,m,true); // it deletes cm.
        }
      }
    }
  }

  void count_points() {
    count_action ca(m_out);
    m_scene->bbox(ca);
    //show_console(ca.number_of_points());

    std::string s;
    s += "pts ";
    if(!numas<unsigned int>(ca.number_of_points(),s)){}
    s += ",gsto ";
    if(!numas<uint64>(m_render_manager.gstos_size(),s)) {}
    s += ",tex ";
    if(!numas<uint64>(m_render_manager.used_texture_memory(),s)) {}
    //m_out << s << std::endl;
    show_console(s);

    m_params.m_console_width = 0.6F;
    set_console_layout();
  }

  bool is_cursor_visible() {
    visible_action va(m_out,m_ww,m_wh);
    m_cursor.is_visible(va);
    unsigned int visibles = va.count();
    return visibles?true:false;
  }

  void anim_mode_button_label(std::vector<std::string>& a_v) const {
    //logic must be in sync with the below update_anim_motion.
    a_v.clear();
    if(m_params.m_camera_type.empty()) {a_v.push_back("nil");return;}

    if(m_params.m_plane_viewer) {
      if(m_params.m_anim_mode==anim_mode_0) {
        a_v.push_back("PAN");
      } else {
        a_v.push_back("ZOOM");
        a_v.push_back("PAN");
      }
    } else { //exam viewer.
      if(m_params.m_anim_mode==anim_mode_0) {
        a_v.push_back("ZOOM");
        a_v.push_back("YAW");
      } else if(m_params.m_anim_mode==anim_mode_1) {
        a_v.push_back("PAN");
      } else if(m_params.m_anim_mode==anim_mode_2) {
        a_v.push_back("PITCH");
        a_v.push_back("YAW");
      } else if(m_params.m_anim_mode==anim_mode_3) {
        a_v.push_back("FWD");  //FB = Forward/Backward
        a_v.push_back("YAW");  //FB = Forward/Backward
      } else if(m_params.m_anim_mode==anim_mode_4) {
        a_v.push_back("ROLL");
        a_v.push_back("YAW");
      } else {
        a_v.push_back("nil");
      }
    }
  }

  ////////////////////////////////////////////
  /// gui style //////////////////////////////
  ////////////////////////////////////////////
protected:
  INLIB_CLASS_STRING(gui)

public:
/*
  void list_add(list& a_list,
                const std::string& a_label,
                const std::string& a_img_file,
                bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_res_file(a_img_file,img)) {
        a_list.add(a_label,img,a_cbk);
      } else {
        a_list.add(a_label,a_cbk);
      }
    } else {
      a_list.add(a_label,a_cbk);
    }
  }

  void list_white_add(list& a_list,
                      const std::string& a_label,
                      bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_res_file(s_white_jpg(),img)) {
        a_list.add(a_label,img,a_cbk);
      } else {
        a_list.add(a_label,a_cbk);
      }
    } else {
      a_list.add(a_label,a_cbk);
    }
  }

  void list_add_before(list& a_list,
                       const std::string& a_what,
                       const std::string& a_label,
                       const std::string& a_img_file,
                       bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_res_file(a_img_file,img)) {
        a_list.add_before(a_what,a_label,img,a_cbk);
      } else {
        a_list.add_before(a_what,a_label,a_cbk);
      }
    } else {
      a_list.add_before(a_what,a_label,a_cbk);
    }
  }

  void list_add_after(list& a_list,
                      const std::string& a_what,
                      const std::string& a_label,
                      const std::string& a_img_file,
                      bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_res_file(a_img_file,img)) {
        a_list.add_after(a_what,a_label,img,a_cbk);
      } else {
        a_list.add_after(a_what,a_label,a_cbk);
      }
    } else {
      a_list.add_after(a_what,a_label,a_cbk);
    }
  }
*/

  bool anim2motion(anim_what a_anim,anim_mode a_anim_mode,int& a_move) {
    if(a_anim==anim_left) {
      if(m_params.m_plane_viewer) {
        a_move = move_translate_left;
        return true;
      } else { //exam viewer.
        if((a_anim_mode==anim_mode_0)||(a_anim_mode==anim_mode_2)||(a_anim_mode==anim_mode_3)||(a_anim_mode==anim_mode_4)) {
          if(m_params.m_anim_around_focal) {
            a_move = move_rotate_around_focal_left;
            return true;
          } else {
            a_move = move_rotate_left;
            return true;
          }
        } else if(a_anim_mode==anim_mode_1) {
          a_move = move_translate_left;
          return true;
        }
      }

    } else if(a_anim==anim_right) {
      if(m_params.m_plane_viewer) {
        a_move = move_translate_right;
        return true;
      } else { //exam viewer.
        if((a_anim_mode==anim_mode_0)||(a_anim_mode==anim_mode_2)||(a_anim_mode==anim_mode_3)||(a_anim_mode==anim_mode_4)) {
          if(m_params.m_anim_around_focal) {
            a_move = move_rotate_around_focal_right;
            return true;
          } else {
            a_move = move_rotate_right;
            return true;
          }
        } else if(a_anim_mode==anim_mode_1) {
          a_move = move_translate_right;
          return true;
        }
      }

    } if(a_anim==anim_up) {
      if(m_params.m_plane_viewer) {
        if(a_anim_mode==anim_mode_0) {
          a_move = move_up;
          return true;
        } else {
          a_move = move_zoom_in;
          return true;
        }
      } else { //exam viewer.
        if(a_anim_mode==anim_mode_0) {
          a_move = move_zoom_in;
          return true;
        } else if(a_anim_mode==anim_mode_1) {
          a_move = move_up;
          return true;
        } else if(a_anim_mode==anim_mode_2) {
          if(m_params.m_anim_around_focal) {
            a_move = move_rotate_around_focal_up;
          } else {
            a_move = move_rotate_up;
          }
          return true;
        } else if(a_anim_mode==anim_mode_3) {
          a_move = move_forward;
          return true;
        } else if(a_anim_mode==anim_mode_4) {
          if(m_params.m_anim_around_focal) {
            a_move = move_roll_around_focal_plus;
          } else {
            a_move = move_roll_plus;
          }
          return true;
        }
      }

    } if(a_anim==anim_down) {
      if(m_params.m_plane_viewer) {
        if(a_anim_mode==anim_mode_0) {
          a_move = move_down;
          return true;
        } else {
          a_move = move_zoom_out;
          return true;
        }
      } else { //exam viewer.
        if(a_anim_mode==anim_mode_0) {
          a_move = move_zoom_out;
          return true;
        } else if(a_anim_mode==anim_mode_1) {
          a_move = move_down;
          return true;
        } else if(a_anim_mode==anim_mode_2) {
          if(m_params.m_anim_around_focal) {
            a_move = move_rotate_around_focal_down;
          } else {
            a_move = move_rotate_down;
          }
          return true;
        } else if(a_anim_mode==anim_mode_3) {
          a_move = move_backward;
          return true;
        } else if(a_anim_mode==anim_mode_4) {
          if(m_params.m_anim_around_focal) {
            a_move = move_roll_around_focal_minus;
          } else {
            a_move = move_roll_minus;
          }
          return true;
        }
      }
    }
    a_move = 0;
    return false;
  }

  ////////////////////////////////////////////
  ////////////////////////////////////////////
  ////////////////////////////////////////////

  void set_slider_style(slider& a_node) const {
    a_node.back_area::color = m_params.m_gui_back_color;
    a_node.back_area::border_color = m_params.m_gui_border_color;
    //a_node.color = m_params.m_gui_front_color;
    //a_node.arm_color = m_params.m_gui_arm_color;
    a_node.color = m_params.m_gui_arm_color;
  }
  void set_style(text& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(scroll_text& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(scroll_infos& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(list& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.dir_color = m_params.m_gui_dir_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.label_back_color = m_params.m_gui_label_back_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(entries& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.labels_back_color = m_params.m_gui_label_back_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(entry& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(numeric& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(keyboard& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(edvalop& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(colors& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }

  typedef button_grid<simple_button> sbg_t;
  void set_colors(button_grid<simple_button>& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }

  void set_text_layout(text& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    a_node.width = a_wcw*0.7F;

    float havailable = a_wch-2*a_hbutton;

   {size_t linen = a_node.strings.size();
    float h = linen*a_hbutton*0.8F;
    if(h>=havailable) h = havailable*0.95f;
    a_node.height = h;}

    float y = a_wch*0.5f-havailable*0.5f;
    a_mtx.set_translate(0,y,0);

    a_node.corner_radius = m_params.m_corner_radius;
  //a_node.confine = true;
  }

  void set_back_area_layout(back_area& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    a_node.width = a_wcw*0.5F;

    float havailable = a_wch-2*a_hbutton;

   {float h = a_wch*0.5f;
    if(h>=havailable) h = havailable*0.95f;
    a_node.height = h;}

    float y = a_wch*0.5f-havailable*0.5f;
    a_mtx.set_translate(0,y,0);

    a_node.corner_radius = m_params.m_corner_radius;
  }

  void set_scroll_text_layout(scroll_text& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
  //float wscroll = a_wcw*0.08f;
    float wscroll = a_hbutton;

    // fix margin and get wtext :
    float wmargin = a_wcw*0.01f;
    //We should have : 2*wmargin+wtext+wscroll*1.2 = wcw;
    float wtext = a_wcw-wscroll*1.2f-2.0f*wmargin;

    float hmargin = a_wch*0.01f;
    float hscroll = a_wch-2*a_hbutton-2*hmargin;

    float x = -(a_wcw-wtext)*0.5f+wmargin; //at left+margin.
    float y = a_wch*0.5f-hmargin-hscroll*0.5f;
    a_mtx.set_translate(x,y,0);

    a_node.width = wtext;
    a_node.height = hscroll;
    a_node.scroll_width = wscroll;
    a_node.visible_items = 20;
    a_node.confine = true;
    a_node.wmargin_factor = 0.98f;
    a_node.hmargin_factor = 0.98f;
  }

  void set_base_list_layout(base_list& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    a_node.visible_items = m_params.m_list_visible_items;
    a_node.text_common_height = true;

    a_node.width = a_wcw*0.7F; //round style needs space.
    a_node.scroll_width = a_hbutton;

    float hmargin = 0.05f*a_hbutton;
    float havailable = a_wch-2*a_hbutton-2*hmargin;

    unsigned int nitem = a_node.visible_items;
    float hwanted = nitem*a_hbutton;
    float hlist = mn<float>(hwanted,havailable);

    a_node.height = hlist;

    float y = a_wch*0.5f-havailable*0.5f-hmargin;
    // x center relative to central list (not taking into account right arrows)
    float x = a_node.width*0.5f-a_node.witem()*0.5f;

    a_mtx.set_translate(x,y,0);
  }

  //virtual for ArcheryTune.
  virtual void set_list_layout(list& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    set_base_list_layout(a_node,a_wcw,a_wch,a_hbutton,a_mtx);
    a_node.text_hmargin_factor = 0.5f; //Apple
    s2layout_policy(m_params.m_list_item_layout,a_node.item_layout.value());
    a_node.corner_radius = m_params.m_corner_radius;
  }

  void set_scroll_infos_layout(scroll_infos& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {

  //float wscroll = a_wcw*0.08f;
    float wscroll = a_hbutton;

  //float wtext = wcw*0.8f;
  //float wsctxt = wtext+wscroll*0.2f+wscroll; //scroll_text::update_sg
  //float wmargin = (wcw-wsctxt)*0.2f;

    // fix margin and get wtext :
    float wmargin = a_wcw*0.01f;
    //We should have : 2*wmargin+wtext+wscroll*1.2 = wcw;
    float wtext = a_wcw-wscroll*1.2f-2.0f*wmargin;

    float hmargin = a_wch*0.01f;
    float hscroll = a_wch-2*a_hbutton-2*hmargin;

    float x = -(a_wcw-wtext)*0.5f+wmargin; //at left+margin.
    float y = a_wch*0.5f-hmargin-hscroll*0.5f;
    a_mtx.set_translate(x,y,0);

    a_node.width = wtext;
    a_node.height = hscroll;
    a_node.scroll_width = wscroll;
    a_node.visible_items = 20;
    a_node.confine = true;
    a_node.wmargin_factor = 0.98f;
    a_node.hmargin_factor = 0.98f;

  }

  void set_edvalop_layout(edvalop& a_node,float a_wcw,float a_wch,float a_hbutton,matrix&) const {
    a_node.width = a_wcw*0.7F;
    a_node.height = a_wch*0.5F;

    a_node.text_hmargin_factor = 0.5f; //Apple
    a_node.numeric_width = a_wcw*0.7f;
    a_node.numeric_height = a_wch*0.5f;
    a_node.list_width = a_wcw*0.5f;
    a_node.list_height = a_wch*0.5f;
  //a_node.list_scroll_width = a_wch*0.5f*0.2f;
    a_node.list_scroll_width = a_hbutton;
  }

  //virtual for ArcheryTune.
  virtual void set_entries_layout(entries& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    set_base_list_layout(a_node,a_wcw,a_wch,a_hbutton,a_mtx);

    a_node.text_hmargin_factor = 0.5f; //Apple
    a_node.corner_radius = m_params.m_corner_radius;

    a_node.numeric_width = a_wcw*0.7F;
    a_node.numeric_height = a_wch*0.5f;
    a_node.keyboard_width = a_wcw*0.98F;
    a_node.keyboard_height = a_wch*0.5f;
    a_node.colors_width = a_wcw*0.8F;
    a_node.colors_height = a_wch*0.5f;
    a_node.edvalop_width = a_wcw*0.8F;
    a_node.edvalop_height = a_wch*0.5f;
    a_node.file_chooser_width = a_wcw*0.8F;
    a_node.file_chooser_height = a_wch*0.5f;
    a_node.list_width = a_wcw*0.5F;
    a_node.list_height = a_wch*0.5F;
  //a_node.list_scroll_width = a_wcw*0.5F*0.2F;
    a_node.list_scroll_width = a_hbutton;

    // entries need more space than a list :
    a_node.width = a_wcw*0.9f;
    a_node.buttons_to_arrows_factor = 0.1f;
  //a_node.entry_label_result_factor = 0.7f;

    // x center relative to the whole widget (taking into account right arrows)
    a_mtx.set_translate(0,a_mtx.mtx.value().v13(),a_mtx.mtx.value().v23());

  }

  bool ui_visible() {
    return (m_main_menu_switch.which.value()==SHOWN()?true:false);
  }
  bool camenu_visible() {
    return (m_camenu_switch.which.value()==SHOWN()?true:false);
  }
  bool sliders_visible() {
    return (m_sliders_switch.which.value()==SHOWN()?true:false);
  }
  bool popup_visible() {
    return (m_popup_switch.which.value()==SHOWN()?true:false);
  }

  // two method to hide scene when in rwc.
/*
  void save_scene()    {
    m_backup_scene.transfer(m_scene);

    m_backup_scene.up_cbks().copy(m_scene->up_cbks());
    m_backup_scene.down_cbks().copy(m_scene->down_cbks());
    m_backup_scene.move_cbks().copy(m_scene->move_cbks());
    m_scene->clear_cbks();
  }
  void restore_scene() {
    m_scene->transfer(m_backup_scene);

    m_scene->up_cbks().copy(m_backup_scene.up_cbks());
    m_scene->down_cbks().copy(m_backup_scene.down_cbks());
    m_scene->move_cbks().copy(m_backup_scene.move_cbks());
    m_backup_scene.clear_cbks();
  }
*/

  void set_scene_clear_color(const colorf& a_color) {
    m_params.m_scene_screen_color = a_color;
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      m_clear_color = m_params.m_scene_screen_color;
    }
  }

  void set_scene_clear_color(float a_r,float a_g,float a_b,float a_a = 1) {
    set_scene_clear_color(colorf(a_r,a_g,a_b,a_a));
  }

  void swap_scene_clear_color() {
    if(m_params.m_scene_screen_color==colorf_white()) {
      set_scene_clear_color(colorf_black());
    } else /*if(m_params.m_scene_screen_color==colorf_black())*/ {
      set_scene_clear_color(colorf_white());
    }
  }

  void set_gui_clear_color(const colorf& a_color) {
    m_params.m_gui_screen_color = a_color;
    if(m_main_menu_switch.which.value()==SHOWN()) {
      m_clear_color = m_params.m_gui_screen_color;
    }
  }

  void set_gui_clear_color(float a_r,float a_g,float a_b,float a_a = 1) {
    set_gui_clear_color(colorf(a_r,a_g,a_b,a_a));
  }

  //virtual
  void show_main_menu() {
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      m_main_menu_switch.which = SHOWN();
      m_clear_color = m_params.m_gui_screen_color;
      m_meta_switch.which = HIDDEN();
      if(m_params.m_auto_hide_scene) m_scene_switch.which = HIDDEN();
      m_gui_sliders_switch.which = HIDDEN(); //do not traverse scene sliders
      hide_popup();
    }
    set_default_cursor_shape();
  }

  bool main_menu_shown() {
    return m_main_menu_switch.which.value()==SHOWN()?true:false;
  }

  bool scene_shown() {
    return m_scene_switch.which.value()==SHOWN()?true:false;
  }

  //void show_scene() {m_scene_switch.which = SHOWN();}  //used in wall/scene_dispatch
  //void hide_scene() {m_scene_switch.which = HIDDEN();} //used in wall/scene_dispatch

  void hide_main_menu() {
    if(m_main_menu_switch.which.value()==SHOWN()) {
      m_main_menu_switch.which = HIDDEN();
      m_clear_color = m_params.m_scene_screen_color;
      if(m_params.m_auto_hide_scene) m_scene_switch.which = SHOWN();
      m_gui_sliders_switch.which = SHOWN(); //traverse scene sliders
    }
    if(!m_meta_had_been_shown) {
      m_meta_switch.which = SHOWN();
      m_meta_had_been_shown = true;
    }
    if(m_params.m_viewing){
      set_default_cursor_shape();
    } else {
      set_cursor_shape(cursor_target);
    }
  }

  void hide_meta_zone() {m_meta_switch.which = HIDDEN();}
  void set_meta_zone_had_been_shown() {m_meta_had_been_shown = true;}
  void set_meta_zone_had_not_been_shown() {m_meta_had_been_shown = false;}

  void show_camera_menu() {
    hide_main_menu();
    m_camenu_switch.which = SHOWN();
    set_camera_menu_labels();
  }

  void hide_camera_menu() {m_camenu_switch.which = HIDDEN();}
  bool is_camera_menu_hidden() const {return m_camenu_switch.which==HIDDEN()?true:false;}

  void toggle_camera_menu() {
    if(m_camenu_switch.which==HIDDEN())
      show_camera_menu();
    else
      hide_camera_menu();
  }

  void set_camera_menu_labels() {
   {std::vector<std::string> ss;
    anim_mode_button_label(ss);
    set_arconf(m_params,m_camenu_anim_mode_button,ss);}

    set_arconf(m_params,m_camenu_viewing_button,viewing_button_label());

    set_img_from_res_file(single_shoot_image_button_file(),m_camenu_sshoot_image_button.img.value());
    m_camenu_sshoot_image_button.img.touch();
    set_arconf(m_params,m_camenu_sshoot_text_button,single_shoot_button_label());

    set_img_from_res_file(rot_90_image_button_file(),m_camenu_90_image_button.img.value());
    m_camenu_90_image_button.img.touch();
    set_arconf(m_params,m_camenu_90_text_button,rot_90_button_label());

    set_arconf(m_params,m_camenu_focal_button,around_focal_button_label());
    set_arconf(m_params,m_camenu_plane_exam_button,plane_exam_button_label());
    set_use_gsto(m_use_gsto);
  }

  void toggle_plane_exam() {
    set_plane_viewer(plane_viewer()?false:true);
    set_camera_menu_labels();
  }

  void activate_meta_zone() {
    // some menu exists (mapped or not).
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      // ask to map menu.
      show_main_menu();
      hide_camera_menu();
    } else { // some menu mapped.
      if(m_scene_camera) hide_main_menu();
    }
  }

  //void hide_gui() { //used by rwc.
  //  hide_main_menu();
  //  hide_camera_menu();
  //  hide_meta_zone();
  //}

  void toggle_light() {set_scene_light_on(m_params.m_light_on?false:true);}

  void toggle_blend() {set_scene_blend_on(m_params.m_blend_on?false:true);}

  void toggle_smooth() {set_scene_smooth_on(m_params.m_smooth_on?false:true);}

  void toggle_gsto() {set_use_gsto(m_params.m_use_gsto?false:true);}

  void show_progress() {m_progress_switch.which = SHOWN();}
  void hide_progress() {m_progress_switch.which = HIDDEN();}
  sg::progress& progress() {return m_progress;}

  void hide_sliders() {m_sliders_switch.which = HIDDEN();}
  void show_sliders() {m_sliders_switch.which = SHOWN();}
/*
  void toggle_sliders() {
    m_sliders_switch.which = m_sliders_switch.which==HIDDEN()?SHOWN():HIDDEN();
  }
*/

  slider& slider_1() {return m_slider_1;}
  slider& slider_2() {return m_slider_2;}
  slider& slider_3() {return m_slider_3;}
  slider& slider_4() {return m_slider_4;}

  void show_console() {m_console_switch.which = SHOWN();}
  void hide_console() {m_console_switch.which = HIDDEN();}
  //text_button& console() {return m_console;}

  void set_console_size(float a_width = 0.3F,float a_height = 0.05F,float a_scale = 1) {
    if(a_width!=m_params.m_console_width) {
      m_params.m_console_width = a_width;
      if(m_params.m_console_width<=0) m_params.m_console_width = 0.3F;
      set_console_layout();
    }
    if(a_height!=m_params.m_console_height) {
      m_params.m_console_height = a_height;
      if(m_params.m_console_height<=0) m_params.m_console_height = 0.05F;
      set_console_layout();
    }
    if(a_scale!=m_params.m_console_scale) {
      m_params.m_console_scale = a_scale;
      if(m_params.m_console_scale<=0) m_params.m_console_scale = 1;
      set_console_layout();
    }
  }

  void set_console_scale(float a_scale) {
    if(a_scale!=m_params.m_console_scale) {
      m_params.m_console_scale = a_scale;
      if(m_params.m_console_scale<=0) m_params.m_console_scale = 1;
      set_console_layout();
    }
  }

  void console_mag_two() {set_console_scale(m_params.m_console_scale*2);}

  ///////////////////////////////////////////////////////////////////
  /// popup : ///////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////
  void show_popup() {m_popup_switch.which = SHOWN();}
  void hide_popup() {m_popup_switch.which = HIDDEN();}
  separator& popup_sep() {return m_popup_sep;}
  //matrix& popup_matrix() {return m_popup_matrix;}
  sg::cbks& popup_cbks() {return m_popup_cbks;}
  const sg::cbks& popup_cbks() const {return m_popup_cbks;}

  void place_show_popup(int a_event_x,int a_event_y,float a_w,float a_h) {
    //a_w,a_h is the size of the popuped item.

    float one_wcw,one_wch; //wall : for one screen.

    float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);

    float all_wcw,all_wch; //wall : for all screens.
    get_gui_all_wcw_wch(all_wcw,all_wch);

    float x,y;
    screen_to_gui(a_event_x,a_event_y,x,y);

    // popup at top-left corner on x,y by taking
    // into account window limits.

    float xright = mn<float>(x+a_w,all_wcw*0.5f);
    //float xright = x+list.width;
    float ybot   = mx<float>(y-a_h,-all_wch*0.5f);

    float xpop = xright-a_w*0.5f;
    float ypop = ybot+a_h*0.5f;

    //compensate also the m_gui trans.
    m_popup_matrix.set_translate(xpop-tx,ypop-ty,0);

    show_popup();
  }
protected:
  template <class WIDGET>  //numeric, keyboard, colors
  void set_popup_size_pos(int a_ex,int a_ey,WIDGET& a_node) {
    float one_wcw,one_wch; //wall : for one screen.
   {float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);}

    a_node.width = one_wcw*0.4F;
    a_node.height = one_wch*0.3f;

    place_show_popup(a_ex,a_ey,a_node.width.value(),a_node.height.value());
  }

  void set_popup_size_pos(int a_ex,int a_ey,sg::list& a_node) { //sg::file_chooser too.
    float one_wcw,one_wch; //wall : for one screen.
   {float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);}
    float hbutton = one_wch*0.05f;

  //matrix m;
  //set_list_layout(a_node,one_wcw*0.5F,one_wch,hbutton,m);

  //list.visible_items = m_params.m_list_visible_items;
    a_node.visible_items = 5;
    a_node.text_common_height = true;
    a_node.width = one_wcw*0.5F;
    a_node.scroll_width = one_wcw*(device::small_screen()?0.15f:0.1f);
    a_node.height = a_node.visible_items*hbutton;
  //a_node.corner_radius = m_params.m_corner_radius;

  //a_node.text_hmargin_factor = 0.5f; //Apple
    s2layout_policy(m_params.m_list_item_layout,a_node.item_layout.value());
    a_node.corner_radius = m_params.m_corner_radius;

    place_show_popup(a_ex,a_ey,a_node.width.value(),a_node.height.value());
  }

  void set_popup_size_pos(int a_ex,int a_ey,sg::entries& a_node) {
    float one_wcw,one_wch; //wall : for one screen.
   {float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);}
    float hbutton = one_wch*0.07f;

    matrix m;
    set_entries_layout(a_node,one_wcw*0.6F,one_wch,hbutton,m);

    place_show_popup(a_ex,a_ey,a_node.width.value(),a_node.height.value());
  }

  void set_popup_size_pos(int a_ex,int a_ey,sg::edvalop& a_node) {
    float one_wcw,one_wch; //wall : for one screen.
   {float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);}
    float hbutton = one_wch*0.05f;

    matrix m;
    set_edvalop_layout(a_node,one_wcw*0.6f,one_wch,hbutton,m);

    //set_style(a_node);
    a_node.width = one_wcw*0.4F;
    a_node.height = 6*hbutton;

    place_show_popup(a_ex,a_ey,a_node.width.value(),a_node.height.value());
  }
public:
  void popup_warn(int a_ex,int a_ey,const std::string& a_msg,bool a_warn = true) {
    hide_popup();

    list* _list = new list(ttf());

    if(a_warn) _list->back_color = m_params.m_gui_warn_back_color;
    else       _list->back_color = m_params.m_gui_warn_ok_color;
    _list->front_color = m_params.m_gui_warn_front_color;
    _list->border_color = m_params.m_gui_warn_border_color;

    _list->add(a_msg,new gv_cbk(*this,action_hide_popup));

    sg::separator& psep = popup_sep();
    psep.clear();
    psep.add(_list);

    set_popup_size_pos(a_ex,a_ey,*_list);
  }

  template <class WIDGET>
  void show_widget(WIDGET* a_node,bool a_popup,int a_ex,int a_ey) {
    if(a_popup) {
      sg::separator& psep = popup_sep();
      psep.clear();
      psep.add(a_node);
      set_popup_size_pos(a_ex,a_ey,*a_node);
    } else {
      push_list(a_node);
      show_main_menu();
    }
  }

  template <class WIDGET>
  void show_widget(const pos_data& a_data,WIDGET* a_node) {
    show_widget(a_node,a_data.m_popup,a_data.m_ex,a_data.m_ey);
  }

  void pop_warn(bool a_popup,int a_ex,int a_ey,const std::string& a_msg,bool a_warn = true) {
    if(a_popup) {
      popup_warn(a_ex,a_ey,a_msg,a_warn);
    } else {
      map_warn(a_msg,a_warn);
    }
  }

  void pop_warn(const pos_data& a_data,const std::string& a_msg,bool a_warn = true) {
    pop_warn(a_data.m_popup,a_data.m_ex,a_data.m_ey,a_msg,a_warn);
  }

  void map_warn(const std::string& a_msg,bool a_warn = true) {
    hide_camera_menu();
    show_main_menu();
    list* _list = new list(m_ttf);
    set_style(*_list);
    if(a_warn) _list->back_color = m_params.m_gui_warn_back_color;
    else       _list->back_color = m_params.m_gui_warn_ok_color;
    _list->front_color = m_params.m_gui_warn_front_color;
    _list->border_color = m_params.m_gui_warn_border_color;
    _list->add(a_msg,new gv_cbk(*this,action_pop_list));
    push_list(_list);
  }

  ///////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////

  void do_escape() {activate_meta_zone();}

  bool touch_down(int a_x,int a_y) {
    //a_x,a_y are signed because of wall. (0,0) is bottom left of window.

    if(!m_ww || !m_wh) return false;

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_down :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;
    }

    unsigned int vp_ww = uint32(m_vr_mode?m_ww*0.5:m_ww);
    if(m_vr_mode) {if(a_x>=int(vp_ww)) a_x -= vp_ww;}

    down_event e(a_x,a_y);

    int old_scene_switch_which = m_scene_switch.which;
    int old_cursor_switch_which = m_cursor_switch.which;

    if(m_params.m_viewing) m_scene_switch.which = HIDDEN();
    m_cursor_switch.which = HIDDEN();

    event_action action(m_out,vp_ww,m_wh,e);
    m_sg.swap(0,1); //have m_gui traversed before m_scene_switch.
    m_sg.event(action);
    m_sg.swap(0,1);

    m_scene_switch.which = old_scene_switch_which;
    m_cursor_switch.which = old_cursor_switch_which;

    return action.done();
  }

  bool touch_up(int a_x,int a_y) {
    //a_x,a_y are signed because of wall. (0,0) is bottom left of window.

    if(m_touch_in_motion) {
      m_touch_in_motion = false;
      m_touches.clear();

      if(m_motion_slider) {
        // We may have missed a touch up on the slider thumb.
        // We have to execute the ends callbacks anyway.
        add_work_cbks(m_motion_slider->ends(),true);
        m_motion_slider = 0;
        return false;
      }
    }

    if(!m_ww || !m_wh) return false;

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_up :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;
    }

    unsigned int vp_ww = uint32(m_vr_mode?m_ww*0.5:m_ww);
    if(m_vr_mode) {if(a_x>=int(vp_ww)) a_x -= vp_ww;}

    up_event e(a_x,a_y);

    int old_scene_switch_which = m_scene_switch.which;
    int old_cursor_switch_which = m_cursor_switch.which;

    if(m_params.m_viewing) m_scene_switch.which = HIDDEN(); //do not traverse scene.
    // But in viewing mode we would traverse m_scene before m_gui,
    // we have to swap m_scene_switch and m_gui->
    m_cursor_switch.which = HIDDEN(); //do not traverse cursor.

    event_action action(m_out,vp_ww,m_wh,e);
    m_sg.swap(0,1);
    m_sg.event(action);
    m_sg.swap(0,1);

    m_scene_switch.which = old_scene_switch_which;
    m_cursor_switch.which = old_cursor_switch_which;

    return action.done();
  }

  bool touch_move(int a_x,int a_y) { //could be negative in case of wall.
    unsigned int vp_ww = uint32(m_vr_mode?m_ww*0.5:m_ww);
    if(m_vr_mode) {if(a_x>=int(vp_ww)) a_x -= vp_ww;}

    if(!m_touch_in_motion) {
      m_touch_prev_x = a_x;
      m_touch_prev_y = a_y;
      m_touches.push_back(one_touch(a_x,a_y));
      m_touch_in_motion = true;
      return false;
    }

    if(!m_ww||!m_wh) {
      m_touch_prev_x = a_x;
      m_touch_prev_y = a_y;
      return false;
    }

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_move :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;
    }

    bool to_render = false;

    if(ui_visible()) {

      // for sliders in the gui.
      move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
      event_action action(m_out,vp_ww,m_wh,e);
      m_gui->event(action);
      to_render = false; //Android : "true" may induce double redraw.

    } else { //scene or sliders visible

      bool gui_hit = false; //for ArcheryTune mv animal whilst having sliders.

      if(sliders_visible()) {

        move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
        event_action action(m_out,vp_ww,m_wh,e);
        m_gui->event(action); //on m_sg ?
        hide_meta_zone(); //should have to_render = true ?
        to_render = false; //Android : "true" may induce double redraw.
        if(action.done()) {
          //to_render = true;
          gui_hit = true;
        }

      }

      if(!gui_hit) {
      if(m_params.m_viewing) {

        if(m_scene_camera && m_params.m_touch_move) {
          int dx,dy;
          if(touch_direction(dx,dy) && (
            ((iabs(dx)>=5)&&(iabs(dy)<=2)) ||
            ((iabs(dx)<=2)&&(iabs(dy)>=5))
             )) {
            if(iabs(dx)>iabs(dy)) {  ///left/right
              if(dx>0) {
                update_anim_motion(anim_right,m_params.m_anim_mode);
              } else if(dx<0) {
                update_anim_motion(anim_left,m_params.m_anim_mode);
              }
            } else {
              if(dy>0) {
                update_anim_motion(anim_up,m_params.m_anim_mode);
              } else if(dy<0) {
                update_anim_motion(anim_down,m_params.m_anim_mode);
              }
            }
            hide_meta_zone();
            to_render = true;
          }

        /*if(!m_params.m_plane_viewer && m_params.m_anim_around_focal) {

            float n2f = m_scene_camera->focal-m_scene_camera->znear;
            if(n2f) {
              float wnh = m_scene_camera->near_height();
              float aspect = float(vp_ww)/float(m_wh);
              float wnw = wnh*aspect;

              // x in wc in near plane :
              float wpx = wnw*float(m_touch_prev_x)/float(vp_ww);
              float wx  = wnw*float(a_x)/float(vp_ww);

              float apx = ::atan(wpx/n2f);
              float ax  = ::atan(wx/n2f);

              float da = ax-apx;

              if(m_scene_camera->type()==camera_perspective){
                da *= 10.0f; //cooking
              }

              m_scene_camera->rotate_around_y_at_focal(-da);

              hide_meta_zone();
              to_render = true;
            }
          } else {
            float wch;
            if(m_scene_camera->height_at_focal(wch)){
            //float wch = m_scene_camera->near_height();{

              float aspect = float(vp_ww)/float(m_wh);
              float wcw = wch*aspect;

              int dx = a_x-m_touch_prev_x;
              int dy = a_y-m_touch_prev_y;

              float wc_trans_x = wcw*float(dx)/float(vp_ww);
              float wc_trans_y = wch*float(dy)/float(m_wh);
              m_scene_camera->translate_along_side(-wc_trans_x);
              m_scene_camera->translate_along_up(-wc_trans_y);

              hide_meta_zone();
              to_render = true;
            }
          }*/

        }

      } else { //viewer is in picking mode.

        move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
        event_action action(m_out,vp_ww,m_wh,e);
        m_scene_switch.event(action);
        if(action.done()) {
          //someone did something with this event (an image ?)
          to_render = true; //ioda::main::move_image_cbk uses console.
        }

      }}
    }

    m_touch_prev_x = a_x;
    m_touch_prev_y = a_y;
    m_touches.push_back(one_touch(a_x,a_y));

    return to_render;
  }

/*
  void treat_mouse_motion(bool a_value) {m_treat_mouse_motion = a_value;}

  bool mouse_motion(unsigned int a_x,unsigned int a_y) {
    bool to_render = false;

    if(m_ww && m_wh && m_treat_mouse_motion) {

      move_event e(a_x,a_y,0,0,false);
      event_action action(m_out,m_ww,m_wh,e);
      m_scene_switch.event(action);
      if(action.done()) {
        //someone did something with this event (an image ?)
        to_render = true; //ioda::main::move_image_cbk uses console.
      }

    }

    return to_render;
  }
*/
  /////////////////////////////////////
  /// gesture (mainly iOS) ////////////
  /////////////////////////////////////
  void start_gesture(unsigned int a_x,unsigned int a_y) {
    //keep separate for iPhone gestures.
    delete m_gesture_begin_camera;
    m_gesture_begin_camera = 0;
    if(m_scene_camera) {
      m_gesture_begin_camera = m_scene_camera->copy();
    }
    m_gesture_begin_x = a_x;
    m_gesture_begin_y = a_y;
  }

  base_camera* saved_cursor_and_camera(unsigned int& a_x,unsigned int& a_y) {
    a_x = m_gesture_begin_x;
    a_y = m_gesture_begin_y;
    if(!m_gesture_begin_camera) return 0;
    return safe_cast<node,base_camera>(*m_gesture_begin_camera);
  }

  void reset_camera_with_saved() {
    if(m_scene_camera && m_gesture_begin_camera) {

      ortho* oc = safe_cast<base_camera,ortho>(*m_scene_camera);
      perspective* pc =  safe_cast<base_camera,perspective>(*m_scene_camera);
      ortho* roc = safe_cast<node,ortho>(*m_gesture_begin_camera);
      perspective* rpc = safe_cast<node,perspective>(*m_gesture_begin_camera);

      if(oc && roc) {
        *oc = *roc;
      }
      if(pc && rpc) {
        *pc = *rpc;
      }
    }

    _set_params_camera();
  }
  /////////////////////////////////////
  /////////////////////////////////////
  /////////////////////////////////////

public:
  base_camera* cursor_camera() const {return m_cursor_camera;}

  void set_cursor_position(float a_x,float a_y) {
    m_cursor_matrix.set_translate(a_x,a_y,0);
  }
  void get_cursor_position(float& a_x,float& a_y) const {
    const mat4f& mtx = m_cursor_matrix.mtx.value();
    a_x = mtx[12];
    a_y = mtx[13];
  }

public:
  //void clear_tmp_group() {m_tmp_group.clear();}

  //const group& tmp_group() const {return m_tmp_group;}
  //group& tmp_group() {return m_tmp_group;}

  template <class T>
  void add_in_tmp_group(const std::string& a_name,T* a_obj) {
    m_tmp_group.add(new holder<T>(a_obj,a_name));
  }

  template <class T>
  T* find_in_tmp_group(const std::string& a_name) {
    return find_holder<T>(m_tmp_group.children(),a_name);
  }

  template <class T>
  T* find_first_in_tmp_group() {
    return find_first_holder<T>(m_tmp_group.children());
  }

  template <class T>
  void remove_in_tmp_group(const std::string& a_name) {
    remove_holders<T>(m_tmp_group.children(),a_name);
  }


public:
  const sg::object_manager& object_manager() const {return m_object_manager;}
  sg::object_manager& object_manager() {return m_object_manager;}

public:
  float gui_camera_height() const {return 2;}

  void create_gui() { //public to handle DOCUMENT at startup.
    //NOTE : there is no callback setup here. There are done
    //       in sub virtual methods.

    //m_out << "inlib::sg::gui_viewer::create_gui : " << std::endl;

    int old_menu_switch_which = m_main_menu_switch.which;
    int old_camenu_switch_which = m_camenu_switch.which;
    int old_gui_sliders_switch_which = m_gui_sliders_switch.which;
    int old_sliders_switch_which = m_sliders_switch.which;
    int old_progress_switch_which = m_progress_switch.which;
    //int old_meta_switch_which = m_meta_switch.which;
    int old_console_switch_which = m_console_switch.which;
    int old_popup_switch_which = m_popup_switch.which;

    m_gui->clear();

   {depth_test* node = new depth_test;
    node->on = false;
    m_gui->add(node);}

    bool old_param_cam_tiled = m_params.m_cam_tiled;
    //wall screen app : enforce gui in one screen only.
    m_params.m_cam_tiled = true;

    // NOTE : wall : in this case camera height is mapped
    //               on the whole "wall inside external borders" height.

    float cam_height = gui_camera_height();
    base_camera* camera = create_camera(camera_ortho,cam_height,0.1f);
    if(!camera) return;
    camera->position.value().set_value(0,0,2);
    camera->focal = 2;
    m_gui->add(camera);

    m_params.m_cam_tiled = old_param_cam_tiled;

    float wcw,wch,aspect;

   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);
    matrix* m = new matrix;
    m->set_translate(tx,ty,0);
    m_gui->add(m);}

    float hbutton = wch/float(10);

    float right_offset = 0.001f; //Wt : to see the right border of buttons.

    ///////////////////////////////////////////////////////////////////////
    /// sliders ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    // sliders are in front of the scene but behind all UI things.

    m_gui_sliders_switch.clear();
    m_gui->add(new noderef(m_gui_sliders_switch));

   {m_sliders_switch.clear();
    m_gui_sliders_switch.add(new noderef(m_sliders_switch));
    m_gui_sliders_switch.add(new separator());
    m_gui_sliders_switch.which = old_gui_sliders_switch_which;

    separator* sliders_sep = new separator;
    m_sliders_switch.add(sliders_sep);
    m_sliders_switch.add(new separator());
    m_sliders_switch.which = old_sliders_switch_which;

    create_sliders(aspect,wcw,wch,*sliders_sep);}

    ///////////////////////////////////////////////////////////////////////
    /// main menu /////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_main_menu_switch.clear();
    m_gui->add(new noderef(m_main_menu_switch));

    m_full_sep.clear();

    m_main_menu_switch.add(new noderef(m_full_sep));
    m_main_menu_switch.add(new separator());
    m_main_menu_switch.which = old_menu_switch_which;
    m_clear_color = m_main_menu_switch.which.value()==SHOWN()?
      m_params.m_gui_screen_color:m_params.m_scene_screen_color;

    float wbutton = wcw/float(3);

    create_control_items(wcw,wch,wbutton,hbutton,right_offset);

   {separator* sep = new separator;
    m_full_sep.add(sep);

    matrix* m = new matrix;
    sep->add(m);

    node* _node = current_list();
    if(_node) {
      if(list* _list = safe_cast<node,list>(*_node)) {
        set_list_layout(*_list,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(scroll_text* _stext = safe_cast<node,scroll_text>(*_node)) { //before the below text.
        set_scroll_text_layout(*_stext,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(text* _text = safe_cast<node,text>(*_node)) {
        set_text_layout(*_text,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(scroll_infos* _sinfos = safe_cast<node,scroll_infos>(*_node)) {
        set_scroll_infos_layout(*_sinfos,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(numeric* _numeric = safe_cast<node,numeric>(*_node)){
        _numeric->width = wcw*0.5F;
        _numeric->height = wch*0.5F;
        _numeric->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(edvalop* _edvalop = safe_cast<node,edvalop>(*_node)){
        set_edvalop_layout(*_edvalop,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(colors* _colors = safe_cast<node,colors>(*_node)) {
        _colors->width = wcw*0.8F;
        _colors->height = wch*0.5F;
        _colors->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(/* button_grid<simple_button>* cnode = */
                  safe_cast<node, button_grid<simple_button> >(*_node)) {
        // do not enforce a size. If not see rwc_gui.
        //cnode->width = wcw*0.8F;
        //cnode->height = wch*0.5F;
        sep->add(new noderef(*_node));

      } else if(keyboard* _kb = safe_cast<node,keyboard>(*_node)){
        _kb->width = wcw*0.98F;
        _kb->height = wch*0.5F;
        _kb->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(entry* _entry = safe_cast<node,entry>(*_node)) {
        _entry->width = wcw*0.5F;
        _entry->height = hbutton;
        _entry->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(entries* _entries = safe_cast<node,entries>(*_node)) {
        set_entries_layout(*_entries,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(slider* _slider = safe_cast<node,slider>(*_node)) {
        _slider->width = wcw*0.5F;
        _slider->height = wch*0.05F;
        sep->add(new noderef(*_node));

      } else if(back_area* _ba = safe_cast<node,back_area>(*_node)) {
        set_back_area_layout(*_ba,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      }
    }}

    } //end central menu.

    ///////////////////////////////////////////////////////////////////////
    /// camera menu ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_camenu_switch.clear();
    m_gui->add(new noderef(m_camenu_switch));

    m_camenu_switch.add(new noderef(m_camenu_sep));
    m_camenu_switch.add(new separator());
    m_camenu_switch.which = old_camenu_switch_which;

    unsigned int nbutton = device::small_screen()?15:20;
    float warrow = wcw/float(nbutton);
    float harrow = warrow;

    m_camenu_sep.clear();

    create_camenu_items(nbutton,wcw,wch,warrow,harrow);

    } //end camenu

    ///////////////////////////////////////////////////////////////////////
    /// console ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_console_switch.clear();
    m_gui->add(new noderef(m_console_switch));

    separator* console_sep = new separator;
    m_console_switch.add(console_sep);
    m_console_switch.add(new separator());
    m_console_switch.which = old_console_switch_which;

    console_sep->add(new noderef(m_console_matrix));
    console_sep->add(new noderef(m_console));

    set_button_style(m_params,m_console);
    _set_console_layout(wcw,wch);

    } //end console

    ///////////////////////////////////////////////////////////////////////
    /// progress //////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
   {m_progress_switch.clear();
    m_gui->add(new noderef(m_progress_switch));

    separator* progress_sep = new separator;
    m_progress_switch.add(progress_sep);
    m_progress_switch.add(new separator());
    m_progress_switch.which = old_progress_switch_which;

    float h = wch*0.05f;
    float w = wcw*0.8f;

    m_progress.width = w;
    m_progress.height = h;
    m_progress.color = m_params.m_gui_arm_color;
  //m_progress.corner_radius = m_params.m_corner_radius;
    progress_sep->add(new noderef(m_progress));
    }

    ///////////////////////////////////////////////////////////////////////
    /// popup /////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_popup_switch.clear();
    m_gui->add(new noderef(m_popup_switch));

    separator* _popup_sep = new separator;
    m_popup_switch.add(_popup_sep);
    m_popup_switch.add(new separator());
    m_popup_switch.which = old_popup_switch_which;

    //m_popup_matrix.set_identity();
    _popup_sep->add(new noderef(m_popup_matrix));
    _popup_sep->add(new noderef(m_popup_sep));

    } //end popup

    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    create_meta_zone(wcw,wch,hbutton);

  }

protected:
  // virtual gui methods containing callbacks :
  // For example redefined for the wall data client remote control gui.
  virtual void create_meta_zone(float a_wcw,float a_wch,float a_hzone) {
    sg::create_meta_zone(m_params,m_ttf,*m_gui,m_meta_switch,
                     a_wcw,a_wch,a_hzone,
                     new gv_cbk(*this,action_activate_meta_zone));
  }

  virtual void create_control_items(float a_wcw,float a_wch,
                                    float a_wb,float a_hb,float a_roffset) {
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_full_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,0,"home","home","go_home_large.jpg",
                       new gv_cbk(*this,action_push_home));

    if(params_button_visible.value()) {
      create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                         m_full_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         0,1,"params","params","system_config_boot.jpg",
                         new gv_cbk(*this,action_params_show));
    }

    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_full_sep,a_wcw,a_wch,a_wb,a_hb,a_roffset,
                       2,0,"back","back","turn_around.jpg",
                       new gv_cbk(*this,action_push_back_item));

    if(camera_button_visible.value()) {
      create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                         m_full_sep,a_wcw,a_wch,a_wb,a_hb,a_roffset,
                         2,1,"camera","camera","movie_camera.jpg",
                         new gv_cbk(*this,action_show_camera_menu));
    }
  }

  virtual void create_camenu_items(unsigned int a_nb,float a_wcw,float a_wch,float a_wb,float a_hb) {

    ///////////////////////////////////////////////////////////////////////
    /// camenu right area /////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    // create four arrows :
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-2,2,arrow_up,
                 new gv_cbk(*this,action_up));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-2,0,arrow_down,
                 new gv_cbk(*this,action_down));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-3,1,arrow_left,
                 new gv_cbk(*this,action_left));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-1,1,arrow_right,
                 new gv_cbk(*this,action_right));

    //inside camera mode button :
   {create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-2,1,std::string(),
                       m_camenu_anim_mode_button,
                       new gv_cbk(*this,action_toggle_param_anim_mode));
    std::vector<std::string> ss;
    anim_mode_button_label(ss);
    m_camenu_anim_mode_button.strings = ss;}

    //outside top-left "single shoot" button :
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-3,2,
                       m_camenu_sshoot_image_button,
                       m_camenu_sshoot_text_button,
                       single_shoot_button_label(),
                       single_shoot_image_button_file(),
                       new gv_cbk(*this,action_toggle_param_single_shoot));

    //outside bottom-right hide button :
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-1,0,"hide","","close.jpg",
                       new gv_cbk(*this,action_hide_camera_menu));

    //outside top-right reset camera button :
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-1,2,"reset","","edit_undo.jpg",
                       new gv_cbk(*this,action_reset_camera));

    //outside bottom-left "90" button :
    if(camenu_90_visible.value()) {
      create_main_button(m_out,m_res_dir,m_params,m_image_readers,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-3,0,
                         m_camenu_90_image_button,
                         m_camenu_90_text_button,
                         rot_90_button_label(),
                         rot_90_image_button_file(),
                         new gv_cbk(*this,action_toggle_param_90));
    }

    if(camenu_edit_visible.value()) {
      //outside top-left "edit" button :
      create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-4,2,"edit","","edit.jpg",
                         new gv_cbk(*this,action_cam_choose_type));
    }

    if(camenu_focal_visible.value()) {
      //"aroud focal" button under the edit one :
      create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-4,1,around_focal_button_label(),
                       m_camenu_focal_button,
                       new gv_cbk(*this,action_toggle_param_anim_around_focal));
    }

    if(camenu_viewing_visible.value()) {
      // viewing/picking mode button under the focal one :
      create_main_button(m_params,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-4,0,viewing_button_label(),
                         m_camenu_viewing_button,
                         new gv_cbk(*this,action_toggle_param_viewing));
    }

    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,2,"mv","","",
                       new gv_cbk(*this,action_cam_choose_anim));
/*
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,1,"EA","","object_rotate_left.jpg",
                       new gv_cbk(*this,action_enable_anim));
*/
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,1,"P/O","","",
                       new gv_cbk(*this,action_swap_camera_kind));

    create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,0,plane_exam_button_label(),
                       m_camenu_plane_exam_button,
                       new gv_cbk(*this,action_toggle_plane_exam));

    create_main_button(m_out,m_res_dir,m_params,m_image_readers,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-6,0,
                       m_camenu_disable_anim_image_button,
                       m_camenu_disable_anim_text_button,
                       "DA",
                       "stop_object_rotate_left.jpg",
                       new gv_cbk(*this,action_disable_anim));
    if(m_params.m_anim_on) {
      m_camenu_disable_anim_image_button.color = colorf_pink();
      m_camenu_disable_anim_text_button.back_area::color = colorf_pink();
    } else {
      m_camenu_disable_anim_image_button.color = m_params.m_gui_back_color;
      m_camenu_disable_anim_text_button.back_area::color = m_params.m_gui_back_color;
    }

    ///////////////////////////////////////////////////////////////////////
    /// camenu left area //////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    unsigned int _row = 0;
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,_row++,"W/B","","black_white.jpg",
                       new gv_cbk(*this,action_swap_scene_clear_color));

    create_main_button(m_out,m_res_dir,m_params,m_image_readers,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,_row++,
                       m_camenu_blend_image_button,
                       m_camenu_blend_text_button,
                       "~",
                       "transparency.jpg",
                       new gv_cbk(*this,action_toggle_blend));
    if(m_params.m_blend_on) {
      m_camenu_blend_image_button.color = colorf_pink();
      m_camenu_blend_text_button.back_area::color = colorf_pink();
    } else {
      m_camenu_blend_image_button.color = m_params.m_gui_back_color;
      m_camenu_blend_text_button.back_area::color = m_params.m_gui_back_color;
    }

#ifndef EMSCRIPTEN
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,_row++,
                       m_camenu_smooth_image_button,
                       m_camenu_smooth_text_button,
                       "SMO",
                       "smooth.jpg",
                       new gv_cbk(*this,action_toggle_smooth));
    if(m_params.m_smooth_on) {
      m_camenu_smooth_image_button.back_area::color = colorf_pink();
      m_camenu_smooth_text_button.back_area::color = colorf_pink();
    } else {
      m_camenu_smooth_image_button.back_area::color = m_params.m_gui_back_color;
      m_camenu_smooth_text_button.back_area::color = m_params.m_gui_back_color;
    }
#endif

    if(camenu_view_all_visible.value()) {
      create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         0,_row++,"<)","","eye.jpg",
                         new gv_cbk(*this,action_adapt_camera_to_scene));
    }

    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,_row++,"clear stat","","clear_static.jpg",
                       new gv_data_cbk<std::string>(*this,action_insh_source_script,"scene_clear_static"));
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,_row++,"clear dyn","","clear_event.jpg",
                       new gv_data_cbk<std::string>(*this,action_insh_source_script,"scene_clear_dynamic"));

    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,0,"N","","",
                       new gv_cbk(*this,action_count_points));

    create_main_button(m_out,m_res_dir,m_params,m_image_readers,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,1,
                       m_camenu_light_image_button,
                       m_camenu_light_text_button,
                       "^",
                       "light_bulb.jpg",
                       new gv_cbk(*this,action_toggle_light));
    if(m_params.m_light_on) {
      m_camenu_light_image_button.color = colorf_pink();
      m_camenu_light_text_button.back_area::color = colorf_pink();
    } else {
      m_camenu_light_image_button.color = m_params.m_gui_back_color;
      m_camenu_light_text_button.back_area::color = m_params.m_gui_back_color;
    }

    create_main_button(m_out,m_res_dir,m_params,m_image_readers,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,2,
                       m_camenu_gsto_image_button,
                       m_camenu_gsto_text_button,
                       "gsto",
                       "gpu.jpg",
                       new gv_cbk(*this,action_toggle_gsto));
    set_use_gsto(m_use_gsto); //update back color.

   {std::vector<std::string> args;
    args.push_back("-hide_camera_menu");
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,3,"png","","",
                       new gv_data_cbk< std::vector<std::string> >(*this,action_window_to_png,args));}

   {std::vector<std::string> args;
    args.push_back("-hide_camera_menu");
    create_main_button(m_out,m_res_dir,m_params,m_image_readers,m_ttf,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,4,"jpeg","","",
                       new gv_data_cbk< std::vector<std::string> >(*this,action_window_to_jpeg,args));}

  }
public:
  separator& camenu_sep() {return m_camenu_sep;}

protected:
  void _set_console_layout(float a_wcw,float a_wch) {
    float hconsole = a_wch*m_params.m_console_height*m_params.m_console_scale;
    float wconsole = a_wcw*m_params.m_console_width*m_params.m_console_scale;

    float x = -a_wcw*0.5F+wconsole*0.5F; //right.
    float y = a_wch*0.5F-hconsole*0.5f; //top
    m_console_matrix.set_translate(x,y,0);

    m_console.width = wconsole;
    m_console.height = hconsole;
  }
public:
  void set_console_layout() {
    float wcw,wch;
   {float tx,ty,aspect;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}
    _set_console_layout(wcw,wch);
  }
protected:

  void set_sliders_layout(float a_wcw,float a_wch,float a_aspect) {
    float hslider = a_wch*0.025f; // desktops.
    if(device::small_screen()) {
      if(a_aspect>1) {
        hslider *= 3;
      } else {
        hslider *= 2;
      }
    }

    float whide = hslider;
    float hhide = hslider;
    float whand = 4*whide; //for Archery vertical slider.

    // slider 1 :
   {float wslider,x,y;
    if((m_params.m_sliders_pos==gui_params::s_sliders_2b())    ||
       (m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) ){
      wslider = (a_wcw-whide)*0.5f;
      x = -a_wcw*0.5f+wslider*0.5f; //left
      y = -a_wch*0.5F+hslider*0.5f; //bottom
    } else if(m_params.m_sliders_pos==gui_params::s_sliders_bl()) {
      wslider = a_wcw-whide;
      x = -a_wcw*0.5f+wslider*0.5f; //left
      y = -a_wch*0.5F+hslider*0.5f; //bottom
    } else {
      wslider = 0; //not visible.
      x = 0;
      y = 0;
    }
    m_slider_1_matrix.set_translate(x,y,0);
    m_slider_1.width = wslider;
    m_slider_1.height = hslider;
    m_slider_1.size = whand;}

    // slider 2 :
   {float wslider,x,y;
    if((m_params.m_sliders_pos==gui_params::s_sliders_2b())    ||
       (m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) ){
      wslider = (a_wcw-whide)*0.5f;
      x = -a_wcw*0.5f+wslider*0.5f+wslider; //left+wslider
      y = -a_wch*0.5F+hslider*0.5f;         //bottom
    } else {
      wslider = 0; //not visible.
      x = 0;
      y = 0;
    }
    m_slider_2_matrix.set_translate(x,y,0);
    m_slider_2.width = wslider;
    m_slider_2.height = hslider;
    m_slider_2.size = whand;}

    // slider 3 :
   {float wslider,x,y;
    if(m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) {
      wslider = (a_wch-hhide)*0.5f;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f-wslider;
      m_slider_3_matrix.set_translate(x,y,0);
      m_slider_3_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else if((m_params.m_sliders_pos==gui_params::s_sliders_bl())||
              (m_params.m_sliders_pos==gui_params::s_sliders_l()) ){
      wslider = a_wch-hhide;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f;
      m_slider_3_matrix.set_translate(x,y,0);
      m_slider_3_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else {
      wslider = 0; //not visible
      x = 0;
      y = 0;
      m_slider_3_matrix.set_translate(x,y,0);
    }
    m_slider_3.width = wslider;
    m_slider_3.height = hslider;
    m_slider_3.size = whand;}

    // slider 4 :
   {float wslider,x,y;
    if(m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) {
      wslider = (a_wch-hhide)*0.5f;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f;
      m_slider_4_matrix.set_translate(x,y,0);
      m_slider_4_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else {
      wslider = 0; //not visible
      x = 0;
      y = 0;
      m_slider_4_matrix.set_translate(x,y,0);
    }
    m_slider_4.width = wslider;
    m_slider_4.height = hslider;
    m_slider_4.size = whand;}

    // hide button :
   {float x = a_wcw*0.5F-whide*0.5F; //at right. //2b,2b_2v
    float y = -a_wch*0.5F+hhide*0.5f; //bottom
    m_hide_sliders_matrix.set_translate(x,y,0);}

    if(m_hide_sliders_sep.size()<=0) {
      //m_out << "set_sliders_layout : warning : m_hide_slides_sep empty." << std::endl;
    } else {
      back_area* ba = safe_cast<node,back_area>(*m_hide_sliders_sep[1]);
      if(ba) {
        ba->width = whide;
        ba->height = hhide;
      }
    }
  }
public:
  void set_sliders_layout() {
    float wcw,wch,aspect;
   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}
    set_sliders_layout(wcw,wch,aspect);
  }
  void set_sliders_pos(const std::string& a_v) {
    if(m_params.m_sliders_pos==a_v) return;
    m_params.m_sliders_pos = a_v;
    set_sliders_layout();
  }
protected:
  void create_sliders(float a_aspect,float a_wcw,float a_wch,separator& a_sliders_sep) {
    // slider 1 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_1_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_1));}

    // slider 2 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_2_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_2));}

    // slider 3 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_3_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_3));}

    // slider 4 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_4_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_4));}

    // hide button :
   {m_hide_sliders_sep.clear();
    a_sliders_sep.add(new noderef(m_hide_sliders_sep));

    m_hide_sliders_sep.add(new noderef(m_hide_sliders_matrix)); //0

    if(m_params.m_image_buttons) {
      image_button* b = new image_button;
      set_image_button_style(m_params,*b);
      set_img(*b,"close.jpg");
      b->add_callback
        (new fundata_cbk<gui_viewer,_switch,pos_data>(*this,m_sliders_switch,action_hide,pos_data(false,0,0)));
      m_hide_sliders_sep.add(b); //1
    } else {
      text_button* b = new text_button(m_ttf);
      set_button_style(m_params,*b);
      set_arconf(m_params,*b,"H");
      b->add_callback
        (new fundata_cbk<gui_viewer,_switch,pos_data>(*this,m_sliders_switch,action_hide,pos_data(false,0,0)));
      m_hide_sliders_sep.add(b); //1
    }}

    set_sliders_layout(a_wcw,a_wch,a_aspect);

    set_slider_style(m_slider_1);
    set_slider_style(m_slider_2);
    set_slider_style(m_slider_3);
    set_slider_style(m_slider_4);
  }

protected:
  void _set_params_camera() {

    if(!m_scene_camera) {
      m_params.m_camera_type.clear();

    } else if(safe_cast<base_camera,ortho>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_ortho();
    } else if(safe_cast<base_camera,lrbt>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_ortho();

    } else if(safe_cast<base_camera,perspective>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_perspective();
    } else if(safe_cast<base_camera,frustum>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_perspective();

    } else {
      m_params.m_camera_type.clear();
    }

    // for rwc :
    // one wall screen apps send the m_cam_<xxx> params to the rwc.
    // See wall/SDL_dispatch.
    if(!m_scene_camera) {
      m_params.m_cam_x = 0;
      m_params.m_cam_y = 0;
      m_params.m_cam_z = 0;
      m_params.m_cam_near = 0;
      m_params.m_cam_far = 0;
      m_params.m_cam_focal = 0;
      m_params.m_cam_dx = 0;
      m_params.m_cam_da = 0;
      m_params.m_cam_ds = 0;
      m_params.m_cam_orientation = rotf(vec3f(0,0,1),0);
    } else {
      m_params.m_cam_x = m_scene_camera->position.value().x();
      m_params.m_cam_y = m_scene_camera->position.value().y();
      m_params.m_cam_z = m_scene_camera->position.value().z();
      m_params.m_cam_near = m_scene_camera->znear;
      m_params.m_cam_far = m_scene_camera->zfar;
      m_params.m_cam_focal = m_scene_camera->focal;
      m_params.m_cam_dx = m_scene_camera->dx;
      m_params.m_cam_da = m_scene_camera->da;
      m_params.m_cam_ds = m_scene_camera->ds;
      m_params.m_cam_orientation = m_scene_camera->orientation.value();
    }
    m_params.m_cam_zof = 1;
  }
public:
  void reset_camera() {
    if(m_scene_camera && m_reset_camera) {

      ortho* oc = safe_cast<base_camera,ortho>(*m_scene_camera);
      perspective* pc = safe_cast<base_camera,perspective>(*m_scene_camera);
      lrbt* lc = safe_cast<base_camera,lrbt>(*m_scene_camera);
      frustum* fc = safe_cast<base_camera,frustum>(*m_scene_camera);

      ortho* roc = safe_cast<node,ortho>(*m_reset_camera);
      perspective* rpc = safe_cast<node,perspective>(*m_reset_camera);
      lrbt* rlc = safe_cast<node,lrbt>(*m_reset_camera);
      frustum* rfc = safe_cast<node,frustum>(*m_reset_camera);

      if(oc && roc) {
        *oc = *roc;
      }
      if(pc && rpc) {
        *pc = *rpc;
      }
      if(lc && rlc) {
        *lc = *rlc;
      }
      if(fc && rfc) {
        *fc = *rfc;
      }
    }

    _set_params_camera();
  }

  bool adapt_camera_to_scene() {return adapt_camera(scene());}
  bool view_all() {return adapt_camera(scene());}

  bool adapt_camera(node& a_node) {
    base_camera* cam = scene_camera();
    if(!cam) return false;

    bbox_action _action(m_out);
    a_node.bbox(_action);
    if(!_action.end()) return false;
    vec3f c;
    if(!_action.box().center(c)) return false;
    float dx,dy,dz;
    if(!_action.box().get_cube_size(dx,dy,dz)) return false;

    // at this point, we assume dx, dy and dz are not zero.

    //::printf("debug : gui_viewer::adapt_camera : center = %g %g %g, size = %g %g %g\n",c.x(),c.y(),c.z(),dx,dy,dz);

    group* grp = find_container<group>(m_out,*m_scene,*cam,false);
    if(!grp) return false;

    float radius = ::sqrtf(dx*dx+dy*dy+dz*dz);

    float z = radius*2; // z = 2*dz is not ok for bbox thin in z but large in x,y.
    float znear = 0.01f*z;
    float ortho_cam_height = 0;
    if(dy>=dx) {
      ortho_cam_height = dy*1.2f;

      float aspect = float(m_ww)/float(m_wh);
      float cam_width = ortho_cam_height*aspect;
      if(dx>=cam_width) {
        float factor = dx/cam_width;
        ortho_cam_height *= factor*1.2F;
      }

    } else {
      float cam_width = dx*1.2f;
      float aspect = float(m_ww)/float(m_wh);
      ortho_cam_height = cam_width/aspect;

      if(dy>=ortho_cam_height) {
        float factor = dy/ortho_cam_height;
        ortho_cam_height *= factor*1.2F;
      }
    }

    base_camera* new_cam = 0;

    if( safe_cast<base_camera,ortho>(*cam) || safe_cast<base_camera,lrbt>(*cam)  ){

      new_cam = create_camera(camera_ortho,ortho_cam_height,znear);

    } else if(safe_cast<base_camera,perspective>(*cam) || safe_cast<base_camera,frustum>(*cam) ){

      float angle = 2*fatan((0.5f*ortho_cam_height)/z);

      float near_height = 2*znear*ftan(angle*0.5f);

      new_cam = create_camera(camera_perspective,near_height,znear);

    } else {
      m_out << "inlib::sg::gui_viewer::adapt_camera :"
                    << " camera not ortho and not perspective."
                    << std::endl;
    }

    if(!new_cam) return false;

    new_cam->zfar = 100*z;
    new_cam->position = vec3f(0,0,z);
    new_cam->dx = z*0.003f;
    new_cam->focal = z;

    new_cam->position.value() += c;

    new_cam->da = cam->da;
    new_cam->ds = cam->ds;

    if(!grp->replace(cam,new_cam,true)) {
      delete new_cam;
      return false;
    }

    set_scene_camera(new_cam);

    return true;
  }

  bool cam_anim_is_running() const {
    if(!m_scene_camera) return false;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    return anim?true:false;
  }

  void stop_cam_anim() {
    if(!m_scene_camera) return;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    if(!anim) return; //done

    //restore a not anim camera :
    search_action sa(m_out);
    const path_t& _path = find_path(sa,*m_scene,*m_scene_camera,false);
    if(_path.empty()) {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " path not found for current camera."
                    << std::endl;
      return;
    }
    group* grp = container<group>(_path);
    if(!grp) {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " camera group not found."
                    << std::endl;
      return;
    }

    base_camera* new_cam = 0;
    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){
      new_cam = new perspective(*pc);
    } else if(frustum* fc = safe_cast<node,frustum>(*m_scene_camera)){
      new_cam = new frustum(*fc);
    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
      new_cam = new ortho(*oc);
    } else if(lrbt* lc = safe_cast<node,lrbt>(*m_scene_camera)){
      new_cam = new lrbt(*lc);

    } else {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " camera not ortho and not perspective."
                    << std::endl;
      return;
    }

    grp->replace(m_scene_camera,new_cam,true); // it deletes m_scene_camera.
    set_scene_camera(new_cam,false); //WARNING : false
  }

  void start_cam_anim(anim_what a_anim,anim_mode a_anim_mode,unsigned int a_cycle) {
    int move;
    if(!anim2motion(a_anim,a_anim_mode,move)) {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " unknown anim code " << a_anim
                    << std::endl;
      return;
    }
    start_cam_move(move,a_cycle);
  }

  void start_cam_move(int a_move,unsigned int a_cycle) {
    if(!m_scene_camera) return;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    if(anim) return; //done

    search_action sa(m_out);
    const path_t& _path = find_path(sa,*m_scene,*m_scene_camera,false);
    if(_path.empty()) {
      m_out << "inlib::sg::gui_viewer::start_cam_move :"
                    << " path not found for current camera."
                    << std::endl;
      return;
    }

    group* grp = container<group>(_path);
    if(!grp) {
      m_out << "inlib::sg::gui_viewer::start_cam_move :"
                    << " camera group not found."
                    << std::endl;
      return;
    }

    atime _now(0,0);
    if(!get_time_now(_now)) {}

    base_camera* new_cam = 0;
    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){
      new_cam = new camera_anim<perspective>(*pc,_now,-1,a_move,a_cycle);
    } else if(frustum* fc = safe_cast<node,frustum>(*m_scene_camera)){
      new_cam = new camera_anim<frustum>(*fc,_now,-1,a_move,a_cycle);

    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
      new_cam = new camera_anim<ortho>(*oc,_now,-1,a_move,a_cycle);
    } else if(lrbt* lc = safe_cast<node,lrbt>(*m_scene_camera)){
      new_cam = new camera_anim<lrbt>(*lc,_now,-1,a_move,a_cycle);

    } else {
      m_out << "inlib::sg::gui_viewer::start_cam_move :"
                    << " camera not ortho and not perspective."
                    << std::endl;
      return;
    }

    grp->replace(m_scene_camera,new_cam,true); // it deletes m_scene_camera.
    set_scene_camera(new_cam,false); //WARNING : false

    enable_anim();
  }


public:
  static bool cmp_camera(const node& a_1,const node& a_2) {

    const ortho* oc1 = safe_cast<node,ortho>(a_1);
    const perspective* pc1 = safe_cast<node,perspective>(a_1);
    const lrbt* lc1 = safe_cast<node,lrbt>(a_1);
    const frustum* fc1 = safe_cast<node,frustum>(a_1);

    const ortho* oc2 = safe_cast<node,ortho>(a_2);
    const perspective* pc2 = safe_cast<node,perspective>(a_2);
    const lrbt* lc2 = safe_cast<node,lrbt>(a_2);
    const frustum* fc2 = safe_cast<node,frustum>(a_2);

    if(oc1 && oc2) return (*oc1)==(*oc2);
    if(pc1 && pc2) return (*pc1)==(*pc2);
    if(lc1 && lc2) return (*lc1)==(*lc2);
    if(fc1 && fc2) return (*fc1)==(*fc2);

    return false;
  }

public:
  //_switch& camera_menu_switch() {return m_camenu_switch;}
  //_switch& main_menu_switch() {return m_main_menu_switch;}

  /////////////////////////////////////////////////
  /// m_params ////////////////////////////////////
  /////////////////////////////////////////////////

#include "args2params.icc"

  bool args2camera(const std::vector<arg>& a_args,bool a_warn){
    //WARNING : used in for wall/screen_dispatch rwc_set_camera protocol.
    if(!m_scene_camera) return false;

    bool status = true;

    // first pass to see if we have to swap the camera kind :
   {for(unsigned int index=0;index<a_args.size();index++) {
      const std::string& label = a_args[index].first;
      const std::string& val = a_args[index].second;
      if(rcmp(label,s_camera_type())             ||
         rcmp(label,gui_params::s_camera_kind()) ){ //old wall data clients.

        bool to_swap = false;
        if((m_params.m_camera_type==s_camera_ortho())&&
           ((val==s_camera_perspective())||
            (val==gui_params::s_perspective())) ) //old wall data clients.
          to_swap = true;

        if((m_params.m_camera_type==s_camera_perspective())&&
           ((val==s_camera_ortho())||
            (val==gui_params::s_ortho())) )       //old wall data clients.
          to_swap = true;

        if(to_swap) {
          //if(!swap_scene_camera_kind()) { //FIXME : have to delete old cam !
          if(!swap_camera_kind()) {
            if(a_warn) {
              map_warn("swap camera kind failed");
            } else {
              m_out << "inlib::sg::gui_viewer::args2camera :"
                            << " swap camera kind failed."
                            << std::endl;
            }
            return false;
          }
        }
      }
    }}

    for(unsigned int index=0;index<a_args.size();index++) {
      const std::string& label = a_args[index].first;
      const std::string& val = a_args[index].second;

      if(rcmp(label,gui_params::s_cam_x())) {
        float field = m_scene_camera->position.value()[0];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[0] = field;
        }

      } else if(rcmp(label,gui_params::s_cam_y())) {
        float field = m_scene_camera->position.value()[1];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[1] = field;
        }

      } else if(rcmp(label,gui_params::s_cam_z())) {
        float field = m_scene_camera->position.value()[2];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[2] = field;
        }

      } else if(rcmp(label,gui_params::s_cam_near())) {
        bool changed;
        if(!to<float>(m_scene_camera->znear.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_far())) {
        bool changed;
        if(!to<float>(m_scene_camera->zfar.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_focal())) {
        bool changed;
        if(!to<float>(m_scene_camera->focal.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_dx())) {
        bool changed;
        if(!to<float>(m_scene_camera->dx.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_da())) {
        bool changed;
        if(!to<float>(m_scene_camera->da.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_ds())) {
        bool changed;
        if(!to<float>(m_scene_camera->ds.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_zof())) {
        float v = -1;
        bool changed;
        if(!to<float>(v,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->zoom(v);
        }

      } else if(rcmp(label,gui_params::s_cam_orientation())) {
        if(!sqrot<vec3f,vec4f>(val,m_scene_camera->orientation.value(),::sinf,::cosf)) status = false;

      } else {
        if(a_warn) {
          map_warn(std::string("unknown param ")+label);
          return false;
        } else {
          m_out << "inlib::sg::gui_viewer::args2camera : unknown param " << label << std::endl;
          status = false; //not fatal.
        }
      }
    }
    return status;
  }

  //bool anim_mode() const {return m_params.m_anim_mode;}

  void set_params_camenu(const gui_params& a_params) {
    m_params = a_params;
    set_param_single_shoot(a_params.m_single_shoot);
    set_param_90(a_params.m_90);
    set_param_anim_mode(a_params.m_anim_mode);
    set_param_anim_around_focal(a_params.m_anim_around_focal);
    set_param_viewing(a_params.m_viewing);
  }

  void set_param_anim_mode(anim_mode a_anim_mode) {
    m_params.m_anim_mode = a_anim_mode;
    std::vector<std::string> ss;
    anim_mode_button_label(ss);
    m_camenu_anim_mode_button.strings = ss;
  }
  void toggle_param_anim_mode() {
    unsigned int mode = m_params.m_anim_mode;
    if(m_params.m_plane_viewer) {
      if(mode==anim_mode_0) {
        set_param_anim_mode(anim_mode_1);
      } else if(mode==anim_mode_1) {
        set_param_anim_mode(anim_mode_0);
      } else if(mode==anim_mode_2) {
        set_param_anim_mode(anim_mode_0);
      } else if(mode==anim_mode_3) {
        set_param_anim_mode(anim_mode_0);
      } else if(mode==anim_mode_4) {
        set_param_anim_mode(anim_mode_0);
      }
    } else { //exam viewer.
      if(mode==anim_mode_0) {
        set_param_anim_mode(anim_mode_2);
      } else if(mode==anim_mode_2) {
        set_param_anim_mode(anim_mode_3);
      } else if(mode==anim_mode_3) {
        set_param_anim_mode(anim_mode_4);
      } else if(mode==anim_mode_4) {
        set_param_anim_mode(anim_mode_1);
      } else if(mode==anim_mode_1) {
        set_param_anim_mode(anim_mode_0);
      }
    }
  }

  void set_param_anim_around_focal(bool a_value) {
    m_params.m_anim_around_focal = a_value;
    if(m_params.m_plane_viewer) m_params.m_anim_around_focal = false;
    m_camenu_focal_button.set_label(around_focal_button_label());
  }
  void toggle_param_anim_around_focal() {
    set_param_anim_around_focal(m_params.m_anim_around_focal?false:true);
  }

  void set_param_viewing(bool a_value) {
    m_params.m_viewing = a_value;
    m_camenu_viewing_button.set_label(viewing_button_label());
    if(m_params.m_viewing){
      set_default_cursor_shape();
    } else {
      set_cursor_shape(cursor_target);
    }
  }
  void toggle_param_viewing() {
    set_param_viewing(m_params.m_viewing?false:true);
  }

  void set_param_90(bool a_value) {
    m_params.m_90 = a_value;
    if(m_params.m_plane_viewer) m_params.m_90 = false;
    if(m_params.m_image_buttons) {
      set_img(m_camenu_90_image_button,rot_90_image_button_file());
    } else {
      m_camenu_90_text_button.set_label(rot_90_button_label());
    }
  }
  void toggle_param_90() {set_param_90(m_params.m_90?false:true);}

  void set_param_single_shoot(bool a_value) {
    stop_cam_anim();

    m_params.m_single_shoot = a_value;
    if(m_params.m_single_shoot) stop_cam_anim();

    if(m_params.m_image_buttons) {
      set_img(m_camenu_sshoot_image_button,single_shoot_image_button_file());
    } else {
      m_camenu_sshoot_text_button.set_label(single_shoot_button_label());
    }
  }
  void toggle_param_single_shoot() {
    set_param_single_shoot(m_params.m_single_shoot?false:true);
  }

  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  void create_cursor() {
    //m_out << "inlib::sg::gui_viewer::create_cursor : " << std::endl;

    //mat4f old_mtx = m_cursor_matrix.mtx.value();

    m_cursor.clear();

   {depth_test* node = new depth_test;
    node->on = false;
    m_cursor.add(node);}

    // cam pos(0,0,1) near 0.1 far 10, menu pos in xy plan.
    float cam_height = 2;
    base_camera* camera = create_camera(camera_ortho,cam_height,0.1f);
    if(!camera) return;
    m_cursor_camera = camera;
    m_cursor.add(camera);

   {m_cursor_switch.clear();
    m_cursor.add(new noderef(m_cursor_switch));

    separator* full_sep = new separator;
    m_cursor_switch.add(full_sep);
    m_cursor_switch.add(new separator());
    m_cursor_switch.which = cursor_visible.value()?SHOWN():HIDDEN();

    rgba* mat = new rgba();
    mat->color = colorf_red();
    full_sep->add(mat);

    draw_style* ds = new draw_style;
    ds->style = draw_lines;
    ds->line_width = cursor_line_width;
    full_sep->add(ds);

    //m_cursor_matrix.mtx.value(old_mtx);
    full_sep->add(new noderef(m_cursor_matrix));

    vertices* vtcs = new vertices;

    vtcs->mode = gl::lines();

    if(cursor_model.value()==cursor_target) {

      float size = 0.1f;

      vtcs->add(-size, size,0);
      vtcs->add( size,-size,0);

      vtcs->add(-size,-size,0);
      vtcs->add( size, size,0);

    } else {

      float size = 0.2f;

      vtcs->add(0,-size,0);
      vtcs->add(0, size,0);

      vtcs->add(-size,0,0);
      vtcs->add( size,0,0);

/* various tentative definitly uglies.
    } else {

      float hsq = 0.05f;

      // square :
      vtcs->add(-hsq,-hsq,0);
      vtcs->add( hsq,-hsq,0);

      vtcs->add( hsq,-hsq,0);
      vtcs->add( hsq, hsq,0);

      vtcs->add( hsq, hsq,0);
      vtcs->add(-hsq, hsq,0);

      vtcs->add(-hsq, hsq,0);
      vtcs->add(-hsq,-hsq,0);

      // lines to square :
      float end = 3*hsq;
      vtcs->add(-end,0,0);
      vtcs->add(-hsq,0,0);

      vtcs->add(end,0,0);
      vtcs->add(hsq,0,0);

      vtcs->add(0,end,0);
      vtcs->add(0,hsq,0);

      vtcs->add(0,-end,0);
      vtcs->add(0,-hsq,0);

    } else { //up_right_arrow

      float size = 0.2f;
      vtcs->add(   0,    0,0);
      vtcs->add(size,-size,0);

      vtcs->add(        0,0,0);
      vtcs->add(size*0.5f,0,0);

      vtcs->add(0,         0,0);
      vtcs->add(0,-size*0.5f,0);
*/
    }
    full_sep->add(vtcs);}

  }

public:
  bool find_exec_menu_item(const std::string& a_label) const {
    node* _node = current_list();
    if(!_node) return false;
    if(list* _list = safe_cast<node,list>(*_node)) {
      if(_list->find_exec_item(a_label)) return true;
    } else if(entries* _entries = safe_cast<node,entries>(*_node)) {
      if(_entries->cancel_label.value()!=a_label) return false;
      _entries->cbks().do_actions();
      return true;
    }
    return false;
  }
public:
  void set_memory_warning(bool a_value) {m_memory_warning = a_value;}
  bool has_memory_warning() {return m_memory_warning;}

  //bool add_jpeg_read_work(const std::string& a_file) {
  //  if(!m_jpeg_data.open(a_file)) return false;
  //  add_work(new jpeg_read_work(*this,m_jpeg_data));
  //  return true;
  //}
  ////////////////////////////////////////////
  /// menu tab navigation system /////////////
  ////////////////////////////////////////////
protected:
  ptrs_t base_buttons() {
    search_action action(m_out);
    action.set_class(base_button::s_class());
    m_gui->search(action);
    return action.objs();
  }
  base_button* get_tab_current() {
    ptrs_t btns = base_buttons();
    if(m_tab_current<0) return 0;
    if(m_tab_current>=(int)btns.size()) return 0;
    return (base_button*)btns[m_tab_current];
  }
public:
  bool do_tab(bool a_shift) {
    ptrs_t btns = base_buttons();
    size_t btnn = btns.size();
    if((m_tab_current>=0)&&(m_tab_current<(int)btnn)) {
      base_button* btn = (base_button*)btns[m_tab_current];
      btn->disarm();
    }

    //::printf("debug : do_tab : btnn %d current %d\n",btnn,m_tab_current);

    if(a_shift) { // go back.
      m_tab_current--;
      if(m_tab_current<0) m_tab_current = int(btnn)-1;
    } else {
      m_tab_current++;
      if(m_tab_current>=(int)btnn) m_tab_current = 0;
    }

    bool to_render = false;
    if((m_tab_current>=0)&&(m_tab_current<(int)btnn)) {
      base_button* btn = (base_button*)btns[m_tab_current];
      btn->arm();
      btn->arm_color.touch();
      to_render = true;
    }
    return to_render;
  }
  void do_return() {
    base_button* btn = get_tab_current();
    if(!btn) return;

    // ask to execute cbks by using the highly
    // protected ui::do_works.

    btn->disarm();

    add_work_cbks(btn->cbks().callbacks(),true);

    m_tab_current--; //so that next tab be at same button position.
  }

  void add_work_check_arm_buttons() {
    add_work(new check_arms_work(*this));
  }

public:
  ////////////////////////////////////////////
  /// common scenes //////////////////////////
  ////////////////////////////////////////////
  void visualize_text(const std::vector<std::string>& a_text,
    const std::vector<std::string>& a_rtext = std::vector<std::string>()) {

    hide_main_menu();
    clear_scene();
    if(!m_ww) return;
    if(!m_wh) return;
    if(a_text.empty()) return;

    // cam pos(0,0,1) near 0.1 far 10, primitives in xy plan.
    float cam_height = 2;
    float znear = 0.1f;
    base_camera* camera = create_camera(camera_ortho,cam_height,znear);
    if(!camera) return;

    separator* sep = new separator;
    m_scene->add(sep);

    camera->dx = cam_height/50.0f; //for 50 see touch_move.

    sep->add(camera);

    set_scene_camera(camera);

    rgba* mat = new rgba();
    mat->color = colorf_black();
    sep->add(mat);

    sep->add(new normal);

    matrix* m = new matrix;
    sep->add(m);

    float wcw,wch,aspect;
   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}

    infos_box* text = new infos_box(m_ttf);
    text->width = wcw;
    text->back_visible = false;
    //text->hmargin_factor = 1.0f;
    //text->rhjust = left;
    text->font = m_params.m_gui_font;
    text->font_modeling = m_params.m_gui_font_modeling;
    sep->add(text);

   {std::vector<std::string>::const_iterator it;
    for(it=a_text.begin();it!=a_text.end();++it) {
      text->lstrings.add(*it);
    }}

   {std::vector<std::string>::const_iterator it;
    for(it=a_rtext.begin();it!=a_rtext.end();++it) {
      text->rstrings.add(*it);
    }}

    text->update_sg(); //it sets text->height.

    mat4f& mtx = m->mtx.value();
    mtx.mul_translate(0,-text->height*0.5f+wch*0.5f,0);
  }

  void gui_text(const std::vector<std::string>& a_data) {
    sg::text* text = new sg::text(m_ttf);
    set_style(*text);
    text->strings = a_data;
    text->confine = true;
    text->hjust = sg::center;
    push_list(text);
  }

  void gui_scroll_text(const std::vector<std::string>& a_text){
    if(a_text.empty()) {
      map_warn_empty();
      return;
    }
    scroll_text* text = new scroll_text(m_ttf);
    set_style(*text);
    inlib_vforcit(std::string,a_text,it) text->text.add(*it);
    push_list(text);
  }

  void gui_scroll_infos(const std::vector<std::string>& a_ltext,const std::vector<std::string>& a_rtext) {
    if(a_ltext.empty()) {
      map_warn_empty();
      return;
    }
    if(a_ltext.size()!=a_rtext.size()) {
      map_warn("size mismatch");
      return;
    }
    scroll_infos* text = new scroll_infos(m_ttf);
    set_style(*text);
    inlib_vforcit(std::string,a_ltext,it) text->ltext.add(*it);
    inlib_vforcit(std::string,a_rtext,it) text->rtext.add(*it);
    push_list(text);
  }

  base_camera* create_3D_camera(float a_radius){
    float cam_pos = 2*a_radius;
    float znear = 0.1f*a_radius;
    float near_height = 2 * znear * (a_radius/cam_pos);

    base_camera* camera = create_camera(camera_perspective,near_height,znear);
    if(!camera) {
      m_out << "inlib::sg::gui_viewer::create_3D_camera :"
            << " create_camera failed."
            << std::endl;
      return 0;
    }

    camera->zfar = 10*a_radius;
    camera->position = vec3f(0,0,cam_pos);
    camera->focal = cam_pos;

    camera->dx = 2.0f*a_radius/100.0f;
    //camera->da = camera->da.value()/2;

    return camera;
  }

  base_camera* create_2D_camera(float a_height) { //for image, plots
    float z = 10*a_height;
    float znear = 0.1f*z;
    base_camera* cam = create_camera(camera_ortho,a_height,znear);
    if(!cam) {
      m_out << "inlib::sg::gui_viewer::create_2D_camera :"
            << " create_camera failed."
            << std::endl;
      return 0;
    }
    cam->zfar = 10*z;
    cam->position = vec3f(0,0,z);
    cam->orientation = rotf(vec3f(0,0,1),0);
    cam->focal = z;
    cam->dx = a_height/100.0f;
    return cam;
  }
  base_camera* create_camera(base_camera& a_cam){
    base_camera* camera = 0;
    if(safe_cast<node,ortho>(a_cam)) {
      camera = create_camera(camera_ortho,a_cam.near_height(),a_cam.znear);
    } else if(safe_cast<node,perspective>(a_cam)){
      camera = create_camera(camera_perspective,a_cam.near_height(),a_cam.znear);
    }
    if(!camera) return 0;

    camera->zfar = a_cam.zfar;
    camera->position = a_cam.position;
    camera->orientation = a_cam.orientation;

    camera->dx = a_cam.dx;
    camera->da = a_cam.da;
    camera->ds = a_cam.ds;
    camera->focal = a_cam.focal;

    return camera;
  }

public:
  bool do_key(key_move a_key,bool a_shift,bool a_ctrl) {
    if(a_ctrl) {

      if(cam_anim_is_running()) {
        stop_cam_anim();

      } else {

        anim_what anim = anim_left;
        if(a_key==key_left)
          anim = anim_left;
        else if(a_key==key_right)
          anim = anim_right;
        else if(a_key==key_up)
          anim = anim_up;
        else if(a_key==key_down)
          anim = anim_down;

        // do we want to change things in the cam panel ?
        // Huum, yes as long as m_params.m_anim_mode
        // belongs to gui_viewer.
        set_param_anim_mode(a_shift?anim_mode_1:anim_mode_0);

        start_cam_anim(anim,a_shift?anim_mode_1:anim_mode_0,m_params.m_cycle_secs);
      }
      return false; //do not render.

    } else {
      if(a_key==key_left)
        update_anim_motion(anim_left,a_shift?anim_mode_1:anim_mode_0);
      else if(a_key==key_right)
        update_anim_motion(anim_right,a_shift?anim_mode_1:anim_mode_0);
      else if(a_key==key_up)
        update_anim_motion(anim_up,a_shift?anim_mode_1:anim_mode_0);
      else if(a_key==key_down)
        update_anim_motion(anim_down,a_shift?anim_mode_1:anim_mode_0);

      return true; //to render.
    }
  }

public:
  image::readers& image_readers() {return m_image_readers;}

  bool set_img(image_button& a_button,const std::string& a_file) {
    bool status = set_img_from_res_file(a_file,a_button.img.value());
    a_button.img.touch();
    return status;
  }

  void set_png_writer(png_writer a_writer) {m_png_writer = a_writer;}
  void set_jpeg_writer(jpeg_writer a_writer) {m_jpeg_writer = a_writer;}

  virtual bool write_scene_to_paper(const std::string& a_path,const std::string& a_format,unsigned int a_scale) {
    const inlib::colorf& bg = parent::m_clear_color;
    inlib::sg::node& _node = parent::m_sg;
    return write_paper(m_out,m_gl2ps_mgr,m_zb_mgr,m_png_writer,m_jpeg_writer,
                       bg.r(),bg.g(),bg.b(),bg.a(),_node,a_scale*m_ww,a_scale*m_wh,a_path,a_format);
  }

  virtual unsigned char* get_pixels(unsigned int a_w,unsigned int a_h,bool a_rgbas = true) = 0;

  void after_render() {
    //WARNING : it does OpenGL. Under Android it should be executed in the OpenGL thread.
    //WARNING : if having more m_produce_xxx, look exlib/app/iOS/GLView_mm.
    std::ostream& _out = parent::m_out;

    std::string path;
    if(parent::m_produce_out_jpeg || parent::m_produce_out_png) {
      if(parent::m_produce_out_file.empty()) {
        const std::string& _out_dir = parent::out_dir();
        if(_out_dir.size()) {
          if(!inlib::check_dir(_out,_out_dir)) {parent::map_warn_failed();return;}
          path = _out_dir+inlib::sep();
        }
        if(parent::m_produce_out_jpeg) path += "out.jpeg";
        else path += "out.png";
      } else {
        path = parent::m_produce_out_file;
        parent::m_produce_out_file.clear();
      }
    }

    if(parent::m_produce_out_jpeg) {
      parent::m_produce_out_jpeg = false;
      if(!m_jpeg_writer) {
        _out << "inlib::sg::gui_viewer::after_render() : no jpeg writer." << std::endl;
        parent::map_warn_failed();
        return;
      }
      unsigned char* buffer = get_pixels(parent::m_ww,parent::m_wh,false); //NOTE : jpeg wants bpp=3.
      if(!buffer) {
        _out << "inlib::sg::gui_viewer::after_render() : can't get image." << std::endl;
        parent::map_warn_failed();
        return;
      }
      unsigned int bpp = 3;
      if(!m_jpeg_writer(_out,path,buffer,parent::m_ww,parent::m_wh,bpp,100)) parent::map_warn_failed();
      delete [] buffer;
    }

    if(parent::m_produce_out_png) {
      parent::m_produce_out_png = false;
      if(!m_png_writer) {
        _out << "inlib::sg::gui_viewer::after_render() : no png writer." << std::endl;
        parent::map_warn_failed();
        return;
      }
      unsigned char* buffer = 0;
      if(parent::m_produce_out_bpp==4) {
        buffer = get_pixels(parent::m_ww,parent::m_wh);
      } else if(parent::m_produce_out_bpp==3) {
        buffer = get_pixels(parent::m_ww,parent::m_wh,false);
      } else {
        _out << "inlib::sg::gui_viewer::after_render() :"
             << " bad bpp " << parent::m_produce_out_bpp << "." << std::endl;
        parent::map_warn_failed();
        return;
      }
      if(!buffer) {
        _out << "inlib::sg::gui_viewer::after_render() : can't get image." << std::endl;
        parent::map_warn_failed();
        return;
      }
      unsigned int bpp = parent::m_produce_out_bpp;
      if(!m_png_writer(_out,path,buffer,parent::m_ww,parent::m_wh,bpp)) parent::map_warn_failed();
      delete [] buffer;
    }
  }
public:
  // actions :
  static return_action action_insh_source_script(gui_viewer& a_gv,const std::string& a_script) {
    std::vector<std::string> lines;
    get_lines(a_script,lines);
    a_gv.insh().exec_lines_reset_to_stop(lines);
    return sg::return_to_render;
  }

  static return_action action_none(gui_viewer&) {return return_none;}

  static return_action action_hide(gui_viewer&,_switch& a_widget) {
    if(a_widget.which==1) return return_none;
    a_widget.which = 1;
    return return_to_render;
  }

  static return_action action_touch_down(gui_viewer& a_gv,const ecbk& a_cbk) {
    if(!a_cbk.m_node) return return_none;
    if(base_button* btn = safe_cast<node,base_button>(*a_cbk.m_node)){
      a_gv.arm_button(btn);
      a_cbk.m_event_action->set_done(true);
    } else if(slider* sd = safe_cast<node,slider>(*a_cbk.m_node)){
      a_gv.add_work_cbks(sd->begs(),true);
      a_cbk.m_event_action->set_done(true);
    }
    return return_none;
  }

  static return_action action_touch_up(gui_viewer& a_gv,const ecbk& a_cbk) {
    if(!a_cbk.m_node) return return_none;
    if(base_button* btn = safe_cast<node,base_button>(*a_cbk.m_node)){
      a_gv.trigger_button(btn);
      a_cbk.m_event_action->set_done(true);
    } else if(slider* sd = safe_cast<node,slider>(*a_cbk.m_node)){
      a_gv.add_work_cbks(sd->ends(),true);
      a_cbk.m_event_action->set_done(true);
    } else if(ghost* gh = safe_cast<node,ghost>(*a_cbk.m_node)){
      //m_out << "inlib::sg::gui_viewer::touch_up :"
      //      << " pick ghost."
      //      << std::endl;
      a_gv.add_work_cbks(gh->cbks().callbacks(),true);
      a_cbk.m_event_action->set_done(true);
    }
    return return_none;
  }
  static return_action action_touch_move(gui_viewer& a_gv,const ecbk& a_cbk) {
    if(!a_cbk.m_node) return return_none;
    if(slider* sd = safe_cast<node,slider>(*a_cbk.m_node)){
      // we have to update the slider pos :
      if(move_event* mevt = event_cast<event,move_event>(*a_cbk.m_event)){
        sd->set_value(a_cbk.m_event_action->saved_state(),*mevt);
      }
      a_gv.add_work_cbks(sd->drags(),true);
      a_gv.m_motion_slider = sd;
      a_cbk.m_event_action->set_done(true);
    }
    return return_none;
  }

  static return_action action_window_to_png(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
    a_gv.hide_popup();
    a_gv.hide_main_menu();
    a_gv.hide_meta_zone();
    args _args(a_args);
    if(_args.is_arg("-hide_camera_menu")) a_gv.hide_camera_menu();
    unsigned int bpp;
    _args.find("-bpp",bpp,a_gv.produce_out_bpp());
    std::string path;
    if(_args.first_not_hyphen(path)) a_gv.set_produce_out_file(path);
    a_gv.set_produce_out_png(true);
    a_gv.set_produce_out_bpp(bpp);
    a_gv.win_render();  //it should trigger after_render().
    return return_to_render;
  }
  static const std::string& _window_to_png_help() {
    static const std::string s_help("\
window_to_png: window_to_png [-hide_camera_menu] [-bpp] [path]\n\
  Produce a png file from the displayed window contents.\n\
  If no path is given, a out.png file is produced in the output directory of the application.\n\
  -hide_camera_menu permits to hide the camera menu panel before writing.\n\
  -bpp permits to choose to produce three or four bytes per pixel (rgb or rgba).\n\
  It is four by default. It permits to save transparency/blending in the png.\n\
  Example:\n\
    window_to_png -bpp=3 out.png  # to produce an out.png in the current directory\n\
  See also:\n\
    app_out_dir\n\
");
    return s_help;
  }

  static return_action action_window_to_jpeg(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
    a_gv.hide_popup();
    a_gv.hide_main_menu();
    a_gv.hide_meta_zone();
    args _args(a_args);
    if(_args.is_arg("-hide_camera_menu")) a_gv.hide_camera_menu();
    std::string path;
    if(_args.first_not_hyphen(path)) a_gv.set_produce_out_file(path);
    a_gv.set_produce_out_jpeg(true);
    a_gv.win_render();  //it should trigger after_render().
    return return_to_render;
  }
  static const std::string& _window_to_jpeg_help() {
    static const std::string s_help("\
window_to_jpeg: window_to_jpeg [-hide_camera_menu] [path]\n\
  Produce a jpeg file from the displayed window contents.\n\
  If no path is given, a out.jpeg file is produced in the output directory of the application.\n\
  -hide_camera_menu permits to hide the camera menu panel before writing.\n\
  Note that no alpha channel is written in the jpeg, if you want it, use the window_to_png command.\n\
  Example:\n\
    window_to_jpeg out.jpeg  # to produce an out.jpeg in the current directory\n\
  See also:\n\
    app_out_dir\n\
    window_to_png\n\
");
    return s_help;
  }


#define ACTION_GUI_RENDER(a__method) \
  static return_action action_##a__method(gui_viewer& a_gv) {a_gv.a__method();return return_to_render;}

  ACTION_GUI_RENDER(push_home)           //home
  ACTION_GUI_RENDER(push_back_item)      //back
  ACTION_GUI_RENDER(pop_list)            //last

  ACTION_GUI_RENDER(activate_meta_zone)
  ACTION_GUI_RENDER(hide_popup)

  ACTION_GUI_RENDER(adapt_camera_to_scene)
  ACTION_GUI_RENDER(reset_camera)
  ACTION_GUI_RENDER(clear_scene)

  ACTION_GUI_RENDER(toggle_param_single_shoot)      //action_single_shoot
  ACTION_GUI_RENDER(toggle_param_90)                //action_90
  ACTION_GUI_RENDER(toggle_param_anim_mode)         //action_anim_mode
  ACTION_GUI_RENDER(toggle_param_anim_around_focal) //action_anim_around_focal
  ACTION_GUI_RENDER(toggle_param_viewing)           //action_viewing
  ACTION_GUI_RENDER(hide_camera_menu)               //action_hide_camenu
  ACTION_GUI_RENDER(show_camera_menu)               //action_show_camenu

  ACTION_GUI_RENDER(count_points)
  ACTION_GUI_RENDER(toggle_light)
  ACTION_GUI_RENDER(toggle_blend)
  ACTION_GUI_RENDER(toggle_smooth)
  ACTION_GUI_RENDER(toggle_gsto)
  ACTION_GUI_RENDER(toggle_plane_exam)
  ACTION_GUI_RENDER(swap_scene_clear_color)
  ACTION_GUI_RENDER(swap_camera_kind)
  ACTION_GUI_RENDER(enable_anim)
  ACTION_GUI_RENDER(disable_anim)

#undef ACTION_GUI_RENDER

  INLIB_CLASS_STRING(ui_style)

  static return_action action_params_ok(gui_viewer& a_gv,entries& a_widget) {
    std::string ui_style;

    const std::vector<std::string>& labels = a_widget.labels.values();
    const std::vector<std::string>& vals = a_widget.values.values();

    std::vector<arg> args;
    for(unsigned int index=0;index<labels.size();index++) {
      const std::string& label = labels[index];
      const std::string& val = vals[index];
      if(label==s_ui_style()) {
        ui_style = val;
      } else {
        args.push_back(arg(label,val));
      }
    }

    if(!a_gv.args2params(args,true)) return return_to_render;

    if(ui_style.size()&&(ui_style!=a_gv.m_gui_style)) {
      // if style changed, it override m_params.m_image_buttons.
      if(ui_style==s_default()) {
        a_gv.m_params.set_gui_default();
      } else {
        a_gv.set_gui_style(ui_style);
      }
      a_gv.push_home(); //to reset style of central menu.
    }
    return return_to_render;
  }

  static return_action action_params_show(gui_viewer& a_gv) {
    entries* node = new entries(a_gv.m_ttf);
    node->entry_label_result_factor = 0.7f;

    std::vector<std::string> modes;
    a_gv.m_render_manager.available_gsto_modes(modes);
    params2entries(a_gv.m_params,*node,a_gv.is_wall_screen_app(),modes);

   {std::vector<std::string> opts;
    opts.push_back(s_camera_ortho());
    a_gv.m_styles.find_styles("gui_*",opts);
    opts.push_back(s_default());
    node->add_opts(s_ui_style(),a_gv.m_gui_style,opts);}

    add_callback(a_gv,*node,action_params_ok,pos_data(false,0,0));

    a_gv.set_style(*node);
    a_gv.push_list(node);

    return return_to_render;
  }

  static return_action action_move_camera(gui_viewer& a_gv,anim_what a_action) {
    //a_gv.stop_cam_anim(); //???

    if(a_gv.m_params.m_90 && !a_gv.m_params.m_plane_viewer) {

           if(a_action==anim_left)  a_gv.m_scene_camera->rotate_around_y_at_focal(-fhalf_pi());
      else if(a_action==anim_right) a_gv.m_scene_camera->rotate_around_y_at_focal(fhalf_pi());
      else if(a_action==anim_up)    a_gv.m_scene_camera->rotate_around_x_at_focal(-fhalf_pi());
      else if(a_action==anim_down)  a_gv.m_scene_camera->rotate_around_x_at_focal(fhalf_pi());

      return return_to_render;
    }

    if(a_gv.m_params.m_single_shoot) {

      a_gv.update_anim_motion(a_action,a_gv.m_params.m_anim_mode);

    } else {
      if(a_gv.cam_anim_is_running()) {
        a_gv.stop_cam_anim();
      } else {
        a_gv.start_cam_anim(a_action,a_gv.m_params.m_anim_mode,a_gv.m_params.m_cycle_secs);
      }
    }
    return return_to_render;
  }

  static return_action action_left(gui_viewer& a_gv)  {return action_move_camera(a_gv,anim_left);}
  static return_action action_right(gui_viewer& a_gv) {return action_move_camera(a_gv,anim_right);}
  static return_action action_up(gui_viewer& a_gv)    {return action_move_camera(a_gv,anim_up);}
  static return_action action_down(gui_viewer& a_gv)  {return action_move_camera(a_gv,anim_down);}

  ///////////////////////////////////////////
  /// camed : ///////////////////////////////
  ///////////////////////////////////////////
  static return_action action_cam_set_params(gui_viewer& a_gv,entries& a_widget) {
    base_camera* cam = a_gv.scene_camera();
    if(!cam) {
      a_gv.map_warn("no camera found.");
      return return_to_render;
    }

   {float x;
    if(!a_gv.tow<float>(a_widget.values[0],x)) return return_to_render;
    float y;
    if(!a_gv.tow<float>(a_widget.values[1],y)) return return_to_render;
    float z;
    if(!a_gv.tow<float>(a_widget.values[2],z)) return return_to_render;
    cam->position.value().set_value(x,y,z);}

    if(!sqrot<vec3f,vec4f>(a_widget.values[3],cam->orientation.value(),::sinf,::cosf)) return return_to_render;

   {float v;
    if(!a_gv.tow<float>(a_widget.values[4],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;
    }
    cam->znear = v;}

   {float v;
    if(!a_gv.tow<float>(a_widget.values[5],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;
    }
    if(v<=cam->znear.value()) {
      a_gv.map_warn("far must be > near");
      return return_to_render;
    }
    cam->zfar = v;}

   {float v;
    if(!a_gv.tow<float>(a_widget.values[6],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;
    }
    cam->focal = v;}

   {float v;
    if(!a_gv.tow<float>(a_widget.values[7],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;
    }
    cam->dx = v;}

   {float v;
    if(!a_gv.tow<float>(a_widget.values[8],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;
    }
    cam->da = v*fdeg2rad();}

   {float v;
    if(!a_gv.tow<float>(a_widget.values[9],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;
    }
    cam->ds = v;}

    if(a_gv.is_wall_screen_app()) {
      float v;
      if(!a_gv.tow<float>(a_widget.values[10],v)) return return_to_render;
      if(v<=0) {
        a_gv.map_warn("must be >0");
        return return_to_render;
      }
      cam->zoom(v);
    } else {
      float v;
      if(!a_gv.tow<float>(a_widget.values[10],v)) return return_to_render;
      if(v<=0) {
        a_gv.map_warn("must be >0");
        return return_to_render;
      }
      if(ortho* oc = safe_cast<node,ortho>(*cam)) {
        oc->height = v;
      } else if(perspective* pc = safe_cast<node,perspective>(*cam)) {
        pc->height_angle = v*fdeg2rad();
      }
    }

    a_gv.set_scene_camera(cam); //to set m_reset_camera and m_params.m_cam_<>

    a_gv.hide_main_menu();
    return return_to_render;
  }

  static return_action action_cam_set_type(gui_viewer& a_gv,entries& a_widget) {
    //change cam class if needed and present entries for params.

    std::string skind = a_widget.values[0];
    //a_gv.out() << "choosen class " << scls << std::endl;
    if(skind.size() && a_gv.m_params.m_camera_type.size() && (skind!=a_gv.m_params.m_camera_type)) {
      if(!a_gv.swap_camera_kind()) {
        a_gv.map_warn("swap_camera_kind() failed.");
        return return_to_render;
      }
    }

    base_camera* new_cam = a_gv.scene_camera();
    if(!new_cam) {
      a_gv.map_warn("no camera found.");
      return return_to_render;
    }

    entries* _entries = new entries(a_gv.m_ttf);
    _entries->label = "camera";
    a_gv.set_style(*_entries);

    _entries->add_float("x",new_cam->position.value().x());    //0
    _entries->add_float("y",new_cam->position.value().y());    //1
    _entries->add_float("z",new_cam->position.value().z());    //2
   {std::string s;
    if(!tos(new_cam->orientation.value(),s)) s = "0 1 0 0";
    _entries->add_string("orientation",s);}                    //3
    _entries->add_float("near",new_cam->znear.value());        //4
    _entries->add_float("far",new_cam->zfar.value());          //5
    _entries->add_float("focal",new_cam->focal.value());       //6
    _entries->add_float("dx",new_cam->dx.value());             //7
    _entries->add_float("da (deg)",new_cam->da.value()*frad2deg()); //8
    _entries->add_float("ds (for zoom)",new_cam->ds.value());  //9
    if(a_gv.is_wall_screen_app()) {
      _entries->add_float("zoom out",1);     //10
    } else {
      if(ortho* oc =
         safe_cast<node,ortho>(*new_cam)){
        _entries->add_float("height",oc->height.value()); //10
      } else if(perspective* pc =
         safe_cast<node,perspective>(*new_cam)){
        _entries->add_float("height angle (deg)",pc->height_angle.value()*frad2deg()); //10
      } else {
        a_gv.map_warn("unhandled camera type");
        return return_to_render;
      }
    }

    add_callback(a_gv,*_entries,action_cam_set_params,pos_data(false,0,0));

    a_gv.push_list(_entries);

    return return_to_render;
  }

  static return_action action_cam_choose_type(gui_viewer& a_gv) {
    if(a_gv.m_params.m_camera_type.empty()) {
      a_gv.map_warn("no camera");
      return return_to_render;
    }

    entries* _entries = new entries(a_gv.m_ttf);
    _entries->label = "camera";
    a_gv.set_style(*_entries);

    std::vector<std::string> opts;
    opts.push_back(s_camera_ortho());
    opts.push_back(s_camera_perspective());
    _entries->add_opts("kind",a_gv.m_params.m_camera_type,opts);

    add_callback(a_gv,*_entries,action_cam_set_type,pos_data(false,0,0));

    a_gv.push_list(_entries);

    a_gv.show_main_menu(); //needed if triggered from cam panel.

    return return_to_render;
  }

  static return_action action_cam_set_anim(gui_viewer& a_gv,entries& a_widget) {
    base_camera* cam = a_gv.scene_camera();
    if(!cam) {
      a_gv.map_warn("no camera found.");
      return return_to_render;
    }

    std::string sanim = a_widget.values[0];

    unsigned int cycle;
    if(!a_gv.tow<unsigned int>(a_widget.values[1],cycle)) return return_to_render;

    if(sanim==s_zoom_in_out()) {
      a_gv.start_cam_move(move_zoom_in_out,cycle);
      a_gv.hide_main_menu();
    } else if(sanim==s_zoom_in_out_rot()) {
      a_gv.start_cam_move(move_zoom_in_out_rot,cycle);
      a_gv.hide_main_menu();
    } else {
      a_gv.map_warn("unknown anim.");
    }

    return return_to_render;
  }

  static return_action action_cam_choose_anim(gui_viewer& a_gv) {
    if(a_gv.m_params.m_camera_type.empty()) {
      a_gv.map_warn("no camera");
      return return_to_render;
    }

    entries* _entries = new entries(a_gv.m_ttf);
    _entries->label = "camera anim";
    a_gv.set_style(*_entries);

    std::vector<std::string> opts;
    opts.push_back(s_zoom_in_out());
    opts.push_back(s_zoom_in_out_rot());
    _entries->add_opts("anim",s_zoom_in_out(),opts);

    _entries->add_uint("cycle (secs)",10);

    add_callback(a_gv,*_entries,action_cam_set_anim,pos_data(false,0,0));

    a_gv.push_list(_entries);

    a_gv.show_main_menu(); //needed if triggered from cam panel.

    return return_to_render;
  }

  // old rwc_gui actions id :
/*
    static unsigned int action_reset_camera() {return 9;}
    static unsigned int action_single_shoot()      {return 4;}
    static unsigned int action_90()                {return 5;}
    static unsigned int action_anim_mode()         {return 6;}
    static unsigned int action_anim_around_focal() {return 7;}
    static unsigned int action_viewing()           {return 8;}
    static unsigned int action_clear_scene()             {return 21;}
    static unsigned int action_cam_anim_zoom_in_out()     {return 40;}
    static unsigned int action_cam_anim_zoom_in_out_rot() {return 41;}

      } else if(m_action==action_cam_anim_zoom_in_out()) {     //from rwc.
        m_gv.start_cam_move(move_zoom_in_out,m_gv.m_params.m_cycle_secs);
        m_gv.hide_main_menu();
      } else if(m_action==action_cam_anim_zoom_in_out_rot()) { //from rwc.
        m_gv.start_cam_move(move_zoom_in_out_rot,m_gv.m_params.m_cycle_secs);
        m_gv.hide_main_menu();
*/

protected:

  ////////////////////////////////////////////////////
  /// works //////////////////////////////////////////
  ////////////////////////////////////////////////////

  class check_arms_work : public bcbk {
  public:
    virtual return_action action() {
      std::vector<base_button*>::iterator it;
      for(it=m_gv.m_arm_buttons.begin();it!=m_gv.m_arm_buttons.end();++it) {
        if(m_gv.search_button(*it)){
          (*it)->disarm();
          (*it)->arm_color.touch(); //touch something.
        }
      }
      m_gv.m_arm_buttons.clear();
      return return_to_render;
    }
    virtual bcbk* copy() const {return new check_arms_work(*this);}
  public:
    check_arms_work(gui_viewer& a_gv):bcbk(),m_gv(a_gv) {
      m_single_shoot = true;
    }
    virtual ~check_arms_work(){}
  public:
    check_arms_work(const check_arms_work& a_from)
    :bcbk(a_from),m_gv(a_from.m_gv){}
    check_arms_work& operator=(const check_arms_work& a_from){
      bcbk::operator=(a_from);
      return *this;
    }
  protected:
    gui_viewer& m_gv;
  };

  class arm_work : public bcbk {
    INLIB_HEADER_COPY(arm_work,inlib::sg::gui_viewer::arm_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //WARNING : m_button could have been deleted by some cbk.
      //          (Case of a timer work that would do an indirect gui_visible.touch()
      //           which would induce a delete of buttons in the win_render() -> render()
      //           and then check_gui_curosr()).
      //if(m_gv.search_button(m_button)){
        m_button->arm();
        m_button->arm_color.touch(); //touch something.
      //} else {
      //  m_gv.out() << "arm_work : warning : anomaly : button does not exist." << std::endl;
      //}
      return return_to_render;
    }
  public:
    arm_work(gui_viewer& a_gv,base_button* a_button)
    :parent()
    ,m_gv(a_gv)
    ,m_button(a_button)
    {
      m_single_shoot = true;
    }
    virtual ~arm_work(){}
  public:
    arm_work(const arm_work& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    ,m_button(a_from.m_button)
    {}
    arm_work& operator=(const arm_work& a_from){
      parent::operator=(a_from);
      m_button = a_from.m_button;
      return *this;
    }
  protected:
    gui_viewer& m_gv;
    base_button* m_button;
  };

  class disarm_work : public bcbk {
    INLIB_HEADER_COPY(disarm_work,inlib::sg::gui_viewer::disarm_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //WARNING : m_button could have be deleted by some cbk.
      //if(m_gv.search_button(m_button)){
        m_button->disarm();
        m_button->arm_color.touch(); //touch something.
      //} else {
      //  m_gv.out() << "disarm_work : warning : anomaly : button does not exist." << std::endl;
      //}
      return return_to_render;
    }
  public:
    disarm_work(gui_viewer& a_gv,base_button* a_button)
    :parent()
    ,m_gv(a_gv)
    ,m_button(a_button)
    {
      m_single_shoot = true;
    }
    virtual ~disarm_work(){}
  public:
    disarm_work(const disarm_work& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    ,m_button(a_from.m_button)
    {}
    disarm_work& operator=(const disarm_work& a_from){
      parent::operator=(a_from);
      m_button = a_from.m_button;
      return *this;
    }
  protected:
    gui_viewer& m_gv;
    base_button* m_button;
  };


  class anim_work : public bcbk {
    INLIB_HEADER_COPY(anim_work,inlib::sg::gui_viewer::anim_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //m_gv.out() << "debug : anim_work::action" << std::endl;
      if(m_gv.treat_anim(atime::now())) return return_to_render;
      //return return_none;
      // no anim consumer, we stop the anim_work.
      m_gv.disable_anim();
      return return_to_render;
    }
  public:
    anim_work(gui_viewer& a_gv)
    :parent()
    ,m_gv(a_gv)
    {}
    virtual ~anim_work(){}
  public:
    anim_work(const anim_work& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    {}
    anim_work& operator=(const anim_work& a_from){
      parent::operator=(a_from);
      return *this;
    }
  protected:
    gui_viewer& m_gv;
  };

  class to_stop_event_anim { //used with holder<>.
  public:
    INLIB_SCLASS(inlib::sg::gui_viewer::to_stop_event_anim)
  public:
    to_stop_event_anim(gui_viewer& a_gv):m_gv(a_gv) {}
    virtual ~to_stop_event_anim() {m_gv.stop_event_anim();}
  protected:
    to_stop_event_anim(const to_stop_event_anim& a_from):m_gv(a_from.m_gv) {}
    to_stop_event_anim& operator=(const to_stop_event_anim&){return *this;}
  protected:
    gui_viewer& m_gv;
  };

protected:
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  typedef std::map<std::string,base_dumper*> dumpers_t;
public:
  void set_argcv(const args& a_args) {m_argcv = a_args;}
  const args& argcv() const {return m_argcv;}
  args& argcv() {return m_argcv;}

//const dumpers_t& dumpers() const {return m_dumpers;}
  dumpers_t& dumpers() {return m_dumpers;}             //used in nemoview.

  void add_dumper(const std::string& a_key,base_dumper* a_dumper) { //take ownership of a_dumper.
    add_unique(m_dumpers,a_key,a_dumper,true); //true=delete existing dumper on a_key.
  }
  bool exec_dumper(list& a_list,const std::string& a_name,const std::string& a_tag) {
    dumpers_t::const_iterator itd = m_dumpers.find(a_name);
    if(itd==m_dumpers.end()) return false;
    std::vector<std::string> infos;
    (*itd).second->get_infos(a_tag,infos);
    inlib_vforcit(std::string,infos,it)
      a_list.add(*it,new fundata_cbk<gui_viewer,list,pos_data>(*this,a_list,action_none,pos_data(false,0,0)));
    return true;
  }
/*
  bool add_popup_dumper(const std::string& a_name,const std::vector<std::string>& a_v) {
    dumpers_t::const_iterator it = m_dumpers.find(a_name);
    if(it!=m_dumpers.end()) return false; //done
    m_dumpers[a_name] = new popup_dumper(*this,a_v);
    return true;
  }
*/
public:
  //void set_arconf(text& a_text,const std::string& a_s){
  //  sg::set_arconf(m_params,a_text,a_s);
  //}

  bool set_img_from_res_file(const std::string& a_file,img_byte& a_img) {
    return sg::set_img_from_res_file(m_out,m_res_dir,m_image_readers,a_file,a_img);
  }

  void separator_to_vertices(separator& a_sep) {
    atb_vertices* pts = new atb_vertices;
    atb_vertices* lns = new atb_vertices;
    atb_vertices* trs = new atb_vertices;
    mem_action action(m_mem_mgr,m_out,*pts,*lns,*trs);
    a_sep.render(action);
    a_sep.clear();
    a_sep.add(pts);
    a_sep.add(lns);
    a_sep.add(trs);
  }

public: //insh:
  const inlib::insh& insh() const {return m_insh;}
  inlib::insh& insh() {return m_insh;}

  void source_dot_insh() {
    // home/.insh :
    std::string home_path;
    dir::home(home_path);
    home_path += sep()+".insh";
    if(file::exists(home_path)) m_insh.exec_line_reset_to_stop(". "+home_path); //sourced.
    // doc_dir/.insh :
    std::string doc_path = doc_dir()+sep()+".insh";
    if( (doc_path!=home_path) && file::exists(doc_path) ) m_insh.exec_line_reset_to_stop(". "+doc_path); //sourced.
  }
  void source_startup_insh() {
    // a sourced startup file :
    if(is_doc_res_file("startup.insh")) {  //for app without a startup.insh in doc_res.
      m_insh.exec_line_reset_to_stop(". startup.insh");
    }
  }
  void exec_insh_startup() {
    // a not sourced startup file :
    if(is_doc_res_file("insh_startup")) {  //for app without a insh_startup in doc_res.
      m_insh.exec_line_reset_to_stop("insh_startup");
    }
  }
protected:
  INLIB_INSH_VOID_ARGS_CMD(gui_viewer)
  INLIB_INSH_BOOL_VOID_CMD(gui_viewer)
  INLIB_INSH_VOID_VOID_CMD(gui_viewer)

#define INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(a__name,a__method,a__help)\
   m_insh.add_command(#a__name,new gui_viewer_void_args_cmd(*this,&gui_viewer::a__method,a__help));

#define INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD_HELP(a__name,a__method,a__help_text)\
   m_insh.add_command(#a__name,new gui_viewer_void_args_cmd(*this,&gui_viewer::a__method,a__help_text));

#define INLIB_GUI_VIEWER_ADD_BOOL_VOID_CMD(a__name,a__method,a__help)\
   m_insh.add_command(#a__name,new gui_viewer_bool_void_cmd(*this,&gui_viewer::a__method,a__help));

#define INLIB_GUI_VIEWER_ADD_BOOL_VOID_CMD_HELP(a__name,a__method,a__help_text)\
   m_insh.add_command(#a__name,new gui_viewer_bool_void_cmd(*this,&gui_viewer::a__method,a__help_text));

#define INLIB_GUI_VIEWER_ADD_VOID_VOID_CMD(a__name,a__method,a__help)\
   m_insh.add_command(#a__name,new gui_viewer_void_void_cmd(*this,&gui_viewer::a__method,a__help));

#define INLIB_GUI_VIEWER_ADD_VOID_VOID_CMD_HELP(a__name,a__method,a__help_text)\
   m_insh.add_command(#a__name,new gui_viewer_void_void_cmd(*this,&gui_viewer::a__method,a__help_text));

  void _exec_menu_item(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      m_insh.warn("inlib::sg::gui_viewer::_exec_menu_item : one argument expected.");
      return;
    }
    if(!find_exec_menu_item(a_args[0])) {
      m_insh.warn("inlib::sg::gui_viewer::_exec_menu_item : menu item "+sout(a_args[0])+" not found. Stop.");
      return;
    }
  }
  static const std::string& _exec_menu_item_help() {
    static const std::string s_help("\
gui_exec_main_menu_item: gui_exec_main_menu_item menu_item_label\n\
  Given its label, find a menu item in the\n\
  current main menu and execute its callback.\n\
  Example:\n\
    gui_exec_main_menu_item exit\n\
");
    return s_help;
  }

  void _scene_set_clear_color(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_scene_set_clear_color :");
    if(a_args.size()==1) {
      inlib::colorf _value;
      if(!inlib::sg::find_color(styles().cmaps(),a_args[0],_value)) {
        m_insh.warn(s_header+" "+sout(a_args[0])+" is not a known color.");
        return;
      }
      set_scene_clear_color(_value);
      return;
    }
    if(a_args.size()==3) {
      float r;
      if(!insh().get_arg_float_color(s_header,a_args[0],r)) return;
      float g;
      if(!insh().get_arg_float_color(s_header,a_args[1],g)) return;
      float b;
      if(!insh().get_arg_float_color(s_header,a_args[2],b)) return;
      set_scene_clear_color(r,g,b,1);
      return;
    }
    if(a_args.size()==4) {
      float r;
      if(!insh().get_arg_float_color(s_header,a_args[0],r)) return;
      float g;
      if(!insh().get_arg_float_color(s_header,a_args[1],g)) return;
      float b;
      if(!insh().get_arg_float_color(s_header,a_args[2],b)) return;
      float a;
      if(!insh().get_arg_float_color(s_header,a_args[3],a)) return;
      set_scene_clear_color(r,g,b,a);
      return;
    }
    m_insh.warn(s_header+" one, three or four arguments expected");
  }

  static const std::string& _scene_set_clear_color_help() {
    static const std::string s_help("\
scene_set_clear_color: scene_set_clear_color [color name] [colormap/color name] [#rrggbb] [r g b] [r g b a]\n\
  Set the color of the background of the scene.\n\
  It can be given by a common color name in the default colormap,\n\
  by giving the name of a color in a known colormap, by giving an hexa encoding or by giving\n\
  the three or four r,g,b,a (in [0,1]) of the color.\n\
  See style_print_colormaps to print the known colormaps with their colors.\n\
  Example:\n\
    scene_set_clear_color lightgrey\n\
    scene_set_clear_color ROOT/kMagenta+3\n\
    scene_set_clear_color '#FFFF00'\n\
    scene_set_clear_color 0.2 0.1 0.2\n\
");
    return s_help;
  }

  void _scene_bounding_box(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_scene_bounding_box :");
    bbox_action action(m_out);
    m_scene->bbox(action);
    if(!action.end()) {
      m_insh.warn(s_header+" bbox_action.end() failed.");
      return;
    }
    const box3f& _box = action.box();
    if(_box.is_empty()) {
      m_insh.out("empty");
      return;
    }
    vec3f center;
    if(!_box.center(center)) {}
    float dx,dy,dz;
    if(!_box.get_size(dx,dy,dz)) {}

    std::vector<std::string> ss;
   {std::string _s;
    numas(center.x(),_s);
    _s += " ";
    numas(center.y(),_s);
    _s += " ";
    numas(center.z(),_s);
    ss.push_back(_s);}

   {std::string _s;
    numas(dx,_s);
    _s += " ";
    numas(dy,_s);
    _s += " ";
    numas(dz,_s);
    ss.push_back(_s);}

    m_insh.out_begin();
    m_insh.out(ss);
  }

  static const std::string& _scene_bounding_box_help() {
    static const std::string s_help("\
scene_bounding_box: scene_bounding_box\n\
  Print the center and size of the scene bounding box.\n\
  Example:\n\
    scene_bounding_box\n\
");
    return s_help;
  }

  void _scene_remove_nodes(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_scene_remove_nodes :");
    args _args(a_args);
    std::string sclass;
    if(_args.find("-class",sclass)) {
      search_action sa(m_out);
      const paths_t& paths = find_paths(sa,*m_scene,sclass);
      paths_t::const_iterator it;
      for(it=paths.begin();it!=paths.end();++it) {
        const path_t& p = *it;
        group* grp = container<group>(p);
        if(!grp) {
          m_insh.warn(s_header+" node parent group not found.");
        } else {
          node* _node = p.size()?p[p.size()-1]:0;
          if(!_node) {
            m_insh.warn(s_header+" node path with bad tail.");
          } else {
            if(!grp->remove(_node)) {
              m_insh.warn(s_header+" remove in group failed");
              return;
            }
            //::printf("debug : delete node of class %s\n",sclass.c_str());
            delete _node;
          }
        }
      }
      return;
    }
  }
  static const std::string& _scene_remove_nodes_help() {
    static const std::string s_help("\
scene_remove_nodes: scene_remove_nodes [-class]\n\
  If -class=string, remove nodes of the given class name in the scene.\n\
  Example:\n\
    scene_remove_nodes -class=inlib::sg::cube\n\
");
    return s_help;
  }

  void _style_print_colormaps(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_style_print_colormaps :");
    // first round trip to get item string sizes :
    size_t sindex_size = 0;
    size_t sname_size = 0;
  //size_t scolor_size = 0;
    std::string _s;
   {inlib_mforcit(std::string,style_colormap,styles().cmaps(),it) {
      inlib_mforcit(unsigned int,style_color,(*it).second,itc) {
        unsigned int index = (*itc).first;
        num2s(index,_s);
        sindex_size = mx(sindex_size,_s.size());

        const std::string& name = (*itc).second.first;
        sname_size = mx(sname_size,name.size());
        /*
        const colorf& _color = (*itc).second.second;
        _s .clear();
        numas(_color.r(),_s);
        _s += " ";
        numas(_color.g(),_s);
        _s += " ";
        numas(_color.b(),_s);
        _s += " ";
        numas(_color.a(),_s);
        scolor_size = mx(scolor_size,_s.size());
        */
      }
    }}
    // print :
    m_insh.out_begin();
   {inlib_mforcit(std::string,style_colormap,styles().cmaps(),it) {
      m_insh.out((*it).first+" :",true);
      inlib_mforcit(unsigned int,style_color,(*it).second,itc) {
        unsigned int index = (*itc).first;
        num2s(index,_s);
        justify(_s,sindex_size,side_left);
        m_insh.out("  "+_s,true,false);

        std::string name = (*itc).second.first;
        justify(name,sname_size,side_left);
        m_insh.out(" "+name,true,false);

        const colorf& _color = (*itc).second.second;
        _s .clear();
        numas(_color.r(),_s);
        _s += " ";
        numas(_color.g(),_s);
        _s += " ";
        numas(_color.b(),_s);
        _s += " ";
        numas(_color.a(),_s);
        m_insh.out(" "+_s,true,true);
      }
    }}
  }

  static const std::string& _style_print_colormaps_help() {
    static const std::string s_help("\
style_print_colormaps: style_print_colormaps\n\
  Print the known colormaps.\n\
");
    return s_help;
  }


  void _open(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_open :");
    args _args(a_args);
    std::string file;
    if(!_args.first_not_hyphen(file)) {
      m_insh.warn(s_header+" no output file given.");
      return;
    }
    _args.remove(file);
    if(_args.is_arg("-doc_res")) {
      std::string path;
      if(!find_doc_res_file(file,path)) {
        m_insh.warn(s_header+" file "+inlib::sout(file)+" not found in doc and res dirs.");
        return;
      }
      file = path;
      _args.remove("-doc_res");
    } else if(_args.is_arg("-doc")) {
      std::string path;
      if(!find_doc_file(file,path)) {
        m_insh.warn(s_header+" file "+inlib::sout(file)+" not found in doc dir.");
        return;
      }
      file = path;
      _args.remove("-doc");
    } else if(_args.is_arg("-res")) {
      std::string path;
      if(!find_res_file(file,path)) {
        m_insh.warn(s_header+" file "+inlib::sout(file)+" not found in res dir.");
        return;
      }
      file = path;
      _args.remove("-res");
    }
    bool done;
    if(!opener().open(file,file::s_format_guessed(),_args,done)) {
      m_insh.warn(s_header+" opener.open() failed for "+inlib::sout(file)+".");
      return;
    }
    if(!done) {
      //gui_text(const std::vector<std::string>& a_data);
      m_insh.warn(s_header+" app opener can't open "+inlib::sout(file)+".");
      return;
    }
  }
  static const std::string& _open_help() {
    static const std::string s_help("\
open: open [-doc,-res,-doc_res] path\n\
  Attempt to open a file. The known file types depend of the \"openers\" declared to the app.\n\
  If no directory is given in path, the -doc_res option permits to search a file first\n\
  in the document directory declared to the app, and then in the app (internal) resource directory.\n\
  -res for the resource directory only, -doc for the document directory only.\n\
  See also:\n\
    app_dir -res\n\
    app_dir -doc.\n\
");
    return s_help;
  }

  void _openers(const std::vector<std::string>& a_args) {
    args _args(a_args);
    std::vector<std::string> vs;
    if(_args.is_arg("-exts")) {
      inlib_vforcit(std::string,m_opener.exts(),it) {vs.push_back(*it);}
    } else {
      inlib_vforcit(opener::named_opener_t,m_opener.openers(),it) {vs.push_back((*it).first);}
    }
    m_insh.out_begin();
    m_insh.out(vs,true);
  }
  static const std::string& _openers_help() {
    static const std::string s_help("\
openers: openers [-exts]\n\
  List operners known by the application. -exts permits to list the known file extensions.\n\
");
    return s_help;
  }

  bool _camera_yaw(const std::vector<std::string>& a_args) {
    if((a_args.size()!=1)&&(a_args.size()!=2)) {
      m_insh.warn("inlib::sg::gui_viewer::_camera_yaw : one or two argument expected");
      return true;
    }
    float angle;
    if((a_args.size()==1)) {
      if(!m_insh.get_arg_float("inlib::sg;:gui_viewer::_camera_yaw",a_args[0],angle)) return true;
    } else { //two args.
      if(!m_insh.get_arg_float("inlib::sg;:gui_viewer::_camera_yaw",a_args[1],angle)) return true;
      if((a_args[0]!="-deg")&&(a_args[0]!="-degree")) {
        m_insh.warn("inlib::sg::gui_viewer::_camera_yaw : -deg or -degree exepected for first argument.");
        return false;
      }
      angle *= fdeg2rad();
    }
    if(!m_scene_camera) return false;
    m_scene_camera->rotate_around_up(angle);
    _set_params_camera();
  //m_scene_camera->rotate_around_x(da);
  //m_scene_camera->translate_along_side(dx);
  //m_scene_camera->translate_along_up(dx);
  //m_scene_camera->translate_along_dir(dx);
  //m_scene_camera->rotate_around_y_at_focal(-da);
  //m_scene_camera->rotate_around_x_at_focal(-da);
    return true;
  }
  bool _camera_pitch(const std::vector<std::string>& a_args) {
    if((a_args.size()!=1)&&(a_args.size()!=2)) {
      m_insh.warn("inlib::sg::gui_viewer::_camera_pitch : one or two argument expected");
      return true;
    }
    float angle;
    if((a_args.size()==1)) {
      if(!m_insh.get_arg_float("inlib::sg;:gui_viewer::_camera_pitch",a_args[0],angle)) return true;
    } else { //two args.
      if(!m_insh.get_arg_float("inlib::sg;:gui_viewer::_camera_pitch",a_args[1],angle)) return true;
      if((a_args[0]!="-deg")&&(a_args[0]!="-degree")) {
        m_insh.warn("inlib::sg::gui_viewer::_camera_pitch : -deg or -degree exepected for first argument.");
        return false;
      }
      angle *= fdeg2rad();
    }
    if(!m_scene_camera) return false;
    m_scene_camera->rotate_around_x(angle);
    _set_params_camera();
    return true;
  }
  bool _camera_roll(const std::vector<std::string>& a_args) {
    if((a_args.size()!=1)&&(a_args.size()!=2)) {
      m_insh.warn("inlib::sg::gui_viewer::_camera_roll : one or two argument expected");
      return true;
    }
    float angle;
    if((a_args.size()==1)) {
      if(!m_insh.get_arg_float("inlib::sg;:gui_viewer::_camera_roll",a_args[0],angle)) return true;
    } else { //two args.
      if(!m_insh.get_arg_float("inlib::sg;:gui_viewer::_camera_roll",a_args[1],angle)) return true;
      if((a_args[0]!="-deg")&&(a_args[0]!="-degree")) {
        m_insh.warn("inlib::sg::gui_viewer::_camera_roll : -deg or -degree exepected for first argument.");
        return false;
      }
      angle *= fdeg2rad();
    }
    if(!m_scene_camera) return false;
    m_scene_camera->rotate_around_direction(-angle);
    _set_params_camera();
    return true;
  }

  bool _camera_rotate(const std::vector<std::string>& a_args) {
    base_camera* _cam = scene_camera();
    if(!_cam) return false;
    inlib::args args(a_args);
    float angle;
    args.find("-angle",angle,0.0f);
    if(args.is_arg("-deg")||args.is_arg("-degree")) angle *= fdeg2rad();
    bool at_focal = args.is_arg("-at_focal");
    if(args.is_arg("-x")) {
      if(at_focal) {
        _cam->rotate_around_x_at_focal(angle);
      } else {
        _cam->rotate_around_x(angle);
      }
    } else if(args.is_arg("-y")) {
      if(at_focal) {
        _cam->rotate_around_y_at_focal(angle);
      } else {
        _cam->rotate_around_up(angle);
      }
    } else if(args.is_arg("-z")) {
      if(at_focal) {
        _cam->rotate_around_z_at_focal(angle);
      } else {
        _cam->rotate_around_z(angle);
      }
    } else {
      m_insh.warn("inlib::sg::gui_viewer::_camera_rotate : -x or -y or -z expected.");
      return false;
    }
    set_scene_camera(_cam);
    return true;
  }
  static const std::string& _camera_rotate_help() {
    static const std::string s_help("\
camera_rotate: camera_rotate [-x,-y,-z] [-at_focal] [-deg,-degree] [-angle=angle]\n\
  Rotate the camera around an axis of the given angle.\n\
  If -deg or -degree is specified, the angle is in degree (default is then radian).\n\
  If -at_focal is given, the center of rotation if the focal point, else\n\
  it is the current camera position.\n\
  -x or -y or -z specifies the axis of rotation (one must be specified).\n\
  The frame follows the usual OpenGL convention : x axis points to the right,\n\
  y axis points to the up direction and the z axis is pointing off the screen.\n\
  Example:\n\
    camera_rotate -z -deg -angle=-20  # to roll by -20 degrees.\n\
");
    return s_help;
  }

  void _count_points() {
    count_action ca(m_out);
    m_scene->bbox(ca);
    m_insh.out_begin();
    std::string _s;
    num2s(ca.number_of_points(),_s);
    m_insh.out(_s);
  }


#define INLIB_INSH_CAMERA_SET(a__field)\
  void _camera_set_##a__field(const std::vector<std::string>& a_args) {\
    static const std::string s_header("inlib::sg::gui_viewer::_camera_set_"+std::string(#a__field)+" :");\
    if(a_args.size()!=1) {\
      m_insh.warn(s_header+" one argument expected");\
      return;\
    }\
    float _value;\
    if(!insh().get_arg_float(s_header,a_args[0],_value)) return;\
    base_camera* _cam = scene_camera();\
    if(!_cam) return;\
    _cam->a__field = _value;\
    set_scene_camera(_cam);\
  }
  INLIB_INSH_CAMERA_SET(znear)
  INLIB_INSH_CAMERA_SET(zfar)
  INLIB_INSH_CAMERA_SET(focal)
  INLIB_INSH_CAMERA_SET(da)
  INLIB_INSH_CAMERA_SET(dx)
  INLIB_INSH_CAMERA_SET(ds)

#undef INLIB_INSH_CAMERA_SET

  void _camera_set_orientation(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_camera_set_orientation :");
    base_camera* _cam = scene_camera();
    if(!_cam) return;
    if(a_args.size()!=4) {
      m_insh.warn(s_header+" three argument expected");
      return;
    }
    float x;
    if(!insh().get_arg_float(s_header,a_args[0],x)) return;
    float y;
    if(!insh().get_arg_float(s_header,a_args[1],y)) return;
    float z;
    if(!insh().get_arg_float(s_header,a_args[2],z)) return;
    float angle;
    if(!insh().get_arg_float(s_header,a_args[3],angle)) return;
    _cam->orientation = rotf(vec3f(x,y,z),angle);
    set_scene_camera(_cam);
  }
  static const std::string& _camera_set_orientation_help() {
    static const std::string s_help("\
camera_set_orientation: camera_set_orientation x y z angle\n\
  Set camera.orientation = rotf(vec3f(x,y,z),angle).\n\
");
    return s_help;
  }

  void _camera_set_position(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_camera_set_position :");
    if(a_args.size()!=3) {
      m_insh.warn(s_header+" three argument expected");
      return;
    }
    float tx;
    if(!insh().get_arg_float(s_header,a_args[0],tx)) return;
    float ty;
    if(!insh().get_arg_float(s_header,a_args[1],ty)) return;
    float tz;
    if(!insh().get_arg_float(s_header,a_args[2],tz)) return;
    base_camera* _cam = scene_camera();
    if(!_cam) return;
    _cam->position = vec3f(tx,ty,tz);
    set_scene_camera(_cam);
  }
  static const std::string& _camera_set_position_help() {
    static const std::string s_help("\
camera_set_position: camera_set_position x y z\n\
  Set camera.position to be x,y,z.\n\
  Example:\n\
    camera_set_position 0 0 10\n\
");
    return s_help;
  }

  void _camera_translate_position(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_camera_translate_position :");
    if(a_args.size()!=3) {
      m_insh.warn(s_header+" three argument expected");
      return;
    }
    float tx;
    if(!insh().get_arg_float(s_header,a_args[0],tx)) return;
    float ty;
    if(!insh().get_arg_float(s_header,a_args[1],ty)) return;
    float tz;
    if(!insh().get_arg_float(s_header,a_args[2],tz)) return;
    base_camera* _cam = scene_camera();
    if(!_cam) return;
    _cam->position += vec3f(tx,ty,tz);
    set_scene_camera(_cam);
  }
  static const std::string& _camera_translate_position_help() {
    static const std::string s_help("\
camera_translate_position: camera_translate_position x y z\n\
  Translate the camera.position by x,y,z.\n\
  Example:\n\
    camera_translate_position 10 20 30\n\
");
    return s_help;
  }

  void _camera_zoom(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_camera_zoom :");
    if(a_args.size()!=1) {
      m_insh.warn(s_header+" one argument expected");
      return;
    }
    float factor;
    if(!insh().get_arg_float(s_header,a_args[0],factor)) return;
    if(factor<=0) {
      m_insh.warn(s_header+" first argument "+sout(a_args[0])+" must be >0.");
      return;
    }
    //  factor = 0.99f is a zoom in
    //  factor = 1.01f is a zoom out
    base_camera* _cam = scene_camera();
    if(!_cam) return;
    _cam->zoom(factor);
    set_scene_camera(_cam);
  }
  static const std::string& _camera_zoom_help() {
    static const std::string s_help("\
camera_zoom: camera_zoom factor\n\
  Zoom in or out camera.\n\
  Example:\n\
    camera_zoom 0.99  # is a zoom in.\n\
    camera_zoom 1.01  # is a zoom out.\n\
");
    return s_help;
  }

  void _camera_start_anim(const std::vector<std::string>& a_args) {
    if((a_args.size()!=1)&&(a_args.size()!=2)) {
      m_insh.warn("inlib::sg::gui_viewer::_camera_start_anim : one or two argument expected");
      return;
    }
    std::string smove = a_args[0];
    if(a_args.size()==2) smove = a_args[1];
    move_type _move;
    if(!smove_type(smove,_move)) {
      m_insh.warn("inlib::sg::gui_viewer::_camera_start_anim : "+sout(smove)+" is not a move_type.");
      return;
    }
    unsigned int cycle_secs = 10; //idem m_params.m_cycle_secs default.
    if(a_args.size()==2) {
      std::string opt,value;
      if(!cmd_arg(a_args[0],opt,value)) {
        m_insh.warn("inlib::sg::gui_viewer::_camera_start_anim : "+sout(a_args[0])+" is not -<string>=<string>.");
        return;
      }
      if(opt!="cycle_secs") {
        m_insh.warn("inlib::sg::gui_viewer::_camera_start_anim : "+sout(opt)+" is an unknow option.");
        return;
      }
      if(!m_insh.get_arg_uint("inlib::sg;:gui_viewer::_camera_start_anim",value,cycle_secs)) return;
    }
    start_cam_move(_move,cycle_secs);
  }
  static const std::string& _camera_start_anim_help() {
    static const std::string s_help("\
camera_start_anim: camera_start_anim [-cycle_secs=secs] anim\n\
  Start a camera animation. The anim argument could be :\n\
    move_rotate_right\n\
    move_rotate_left\n\
    move_rotate_up\n\
    move_rotate_down\n\
    move_roll_plus\n\
    move_roll_minus\n\
    move_translate_right\n\
    move_translate_left\n\
    move_up\n\
    move_down\n\
    move_forward\n\
    move_backward\n\
    move_zoom_in\n\
    move_zoom_out\n\
    move_rotate_around_focal_right\n\
    move_rotate_around_focal_left\n\
    move_rotate_around_focal_up\n\
    move_rotate_around_focal_down\n\
    move_roll_around_focal_plus\n\
    move_roll_around_focal_minus\n\
    move_zoom_in_out\n\
    move_zoom_in_out_rot\n\
    move_curve\n\
  For move_zoom_in_out, move_zoom_in_out_rot and move_curve, the -cycle_secs option\n\
  permits to set the cycle time in seconds (it is 10 secs by default).\n\
  Use camera_stop_anim to stop the animation.\n\
");
    return s_help;
  }

  void _show_console(const std::vector<std::string>& a_args) {
    std::string sa;
    conc(a_args," ",sa);
    show_console(sa);
  }

  void _set_console_layout(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      set_console_size();
      return;
    }
    args _args(a_args);
    bool changed = false;
   {float value;
    if(_args.find("-width",value)) {
      if(value!=m_params.m_console_width) {
        m_params.m_console_width = value;
        if(m_params.m_console_width<=0) m_params.m_console_width = 0.3F;
        changed = true;
      }
    }}
   {float value;
    if(_args.find("-height",value)) {
      if(value!=m_params.m_console_height) {
        m_params.m_console_height = value;
        if(m_params.m_console_height<=0) m_params.m_console_height = 0.05F;
        changed = true;
      }
    }}
   {float value;
    if(_args.find("-scale",value)) {
      if(value!=m_params.m_console_scale) {
        m_params.m_console_scale = value;
        if(m_params.m_console_scale<=0) m_params.m_console_scale = 1;
        changed = true;
      }
    }}
    if(changed) set_console_layout();
  }
  static const std::string& _set_console_layout_help() {
    static const std::string s_help("\
gui_set_console_layout: gui_set_console_layout [width] [height] [scale]\n\
  Set the console width and/or height. -scale can set an extra scaling factor.\n\
  Width and height are in normal window coordinates (in [0,1]).\n\
  Example:\n\
    gui_set_console_layout -width=0.5 -height=0.06 -scale=1.2\n\
    gui_set_console_layout -width=0.5  # half window width.\n\
    gui_set_console_layout -scale=2\n\
    gui_set_console_layout  # reset default layout (width=0.3, height=0.05, scale=1) \n\
");
    return s_help;
  }

  void _app_dir(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_app_dir :");
    if(a_args.empty()) {
      m_insh.out_begin();
      m_insh.out(m_res_dir,true);
      m_insh.out(m_doc_dir,true);
      m_insh.out(m_out_dir,true);
      m_insh.out(m_start_dir,true);
      m_insh.out(m_tmp_dir,true);
      return;
    }
    const std::string& arg0 = a_args[0];
    if(arg0=="-res") {
      m_insh.out(m_res_dir);
      return;
    }
    if(arg0=="-doc") {
      m_insh.out(m_doc_dir);
      return;
    }
    if(arg0=="-out") {
      m_insh.out(m_out_dir);
      return;
    }
    if(arg0=="-start") {
      m_insh.out(m_start_dir);
      return;
    }
    if(arg0=="-tmp") {
      m_insh.out(m_tmp_dir);
      return;
    }
    m_insh.warn(s_header+" unknown option "+sout(arg0)+".");
  }
  static const std::string& _app_dir_help() {
    static const std::string s_help("\
app_dir: app_dir [-res,-doc,-out,-tmp,-start]\n\
  Print the application [resource,document,output,startup,temporary] directory.\n\
  If no option given, print all of them in this order.\n\
  Example:\n\
    app_dir\n\
    app_dir -res.\n\
");
    return s_help;
  }

  void _app_color_value(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_app_color_value :");
    inlib::args _args(a_args);
    std::string scolor;
    if(!_args.first_not_hyphen(scolor)) {
      m_insh.warn(s_header+" no color given.");
      return;
    }
    colorf _value;
    if(!find_color(m_styles.cmaps(),scolor,_value)) {
      m_insh.warn(s_header+" "+sout(scolor)+" is not a color.");
      return;
    }
    if(_args.is_arg("-r")) {
      std::string _s;
      num2s(_value.r(),_s);
      m_insh.out(_s);
      return;
    }
    if(_args.is_arg("-g")) {
      std::string _s;
      num2s(_value.g(),_s);
      m_insh.out(_s);
      return;
    }
    if(_args.is_arg("-b")) {
      std::string _s;
      num2s(_value.b(),_s);
      m_insh.out(_s);
      return;
    }
    if(_args.is_arg("-a")) {
      std::string _s;
      num2s(_value.a(),_s);
      m_insh.out(_s);
      return;
    }
    if(_args.is_arg("-rgb")) {
      std::string _s;
      numas(_value.r(),_s);
      _s += " ";
      numas(_value.g(),_s);
      _s += " ";
      numas(_value.b(),_s);
      m_insh.out(_s);
      return;
    }
    std::string _s;
    numas(_value.r(),_s);
    _s += " ";
    numas(_value.g(),_s);
    _s += " ";
    numas(_value.b(),_s);
    _s += " ";
    numas(_value.a(),_s);
    m_insh.out(_s);
  }
  static const std::string& _app_color_value_help() {
    static const std::string s_help("\
app_color_value: app_color_value [-r,-g,-b,-a,-rgba] colorname\n\
  Print the rgba of a color given its name.\n\
  -r to print only the red value (in [0,1]).\n\
  -g to print only the green value (in [0,1]).\n\
  -b to print only the blue value (in [0,1]).\n\
  -a to print only the alpha value (in [0,1]).\n\
  -rgb to print only red, green, blue.\n\
  Example:\n\
    app_color_value red\n\
    app_color_value -r red\n\
    app_color_value -rgb red\n\
");
    return s_help;
  }

public:
  static bool _write_scene_to_paper(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::_write_scene_to_paper :");
    inlib::args _args(a_args);
    std::string path;
    if(_args.is_arg("-out_dir")) {
      if(a_gv.out_dir().empty()) {
        a_gv.insh().warn(s_header+" out_dir() is empty.");
        return false;
      }
      if(!check_dir(a_gv.out(),a_gv.out_dir())) {
        a_gv.insh().warn(s_header+" can't get out_dir.");
        return false;
      }
      path = a_gv.out_dir()+sep();
    }
    std::string file;
    if(!_args.first_not_hyphen(file)) {
      a_gv.insh().warn(s_header+" no output file given.");
      return false;
    }
    path += file;
    std::string format;
    _args.find("-format",format,"guessed");
    if(format=="guessed") {
      if(!inlib::file::extension_paper_format(path,format)) {
        a_gv.insh().warn(s_header+" can't guess format from extension of "+inlib::sout(path)+".");
        return false;
      }
    } else {
      if(!inlib::file::is_paper_format(format)) {
        a_gv.insh().warn(s_header+" unknown format "+inlib::sout(format)+".");
        return false;
      }
    }
    unsigned int scale;
    _args.find<unsigned int>("-scale",scale,1);
    if(!a_gv.write_scene_to_paper(path,format,scale)) {
      a_gv.insh().warn(s_header+" write_scene_to_paper() failed for format "+inlib::sout(format)+".");
      return false;
    }
    if(_args.is_arg("-show_console")) a_gv.show_console(path+" produced.");
    return true;
  }
  static const std::string& _scene_write_to_paper_help() {
    static const std::string s_help("\
scene_write_to_paper: scene_write_to_paper [-out_dir] [-scale] [-format] [-show_console] file\n\
  Produce an output file from the current scene.\n\
  -out_dir permits to write the file in the output directory of the application.\n\
  -scale permits to scale the viewport; it allows to have a better rendering for freetype fonts.\n\
  -show_console prints the name of the output file in the console.\n\
  -format permits to choose the output format and the tool to produce the file.\n\
  If 'guessed', which is the default, the format is choosen/deduced from the file extension.\n\
  For example for out.png, the format will be inzb_png.\n\
  The known formats are:\n\
    inzb_[ps,png,jpeg] : pixmap of the scene is put in a PostScript, png or jpeg file\n\
  by using the inlib::sg::zb_action.\n\
    gl2ps_[eps,ps,pdf,svg,tex,pdg] : primitives of the scene (vector graphices) is put in an\n\
  encapsulated PostScript, PostScript, PDF, SVG, LaTeX or PDG file by using gl2ps.\n\
  If 'guessed' is used as format, then according to the file extension, the tool used is:\n\
    .ps, .eps: inzb_ps\n\
    .png : inzb_png\n\
    .jpg, .jpeg: inzb_jpeg\n\
    .pdf, .svg, .pgf, .tex: gl2ps_[pdf,svg,pgf,tex]\n\
  Example:\n\
    scene_write_to_paper out.jpeg  # produce a out.jpeg file in current directory by using inzb_jpeg.\n\
    scene_write_to_paper -out_dir -format=inzb_png -scale=2 out.png\n\
    scene_write_to_paper -format=gl2ps_pdf out.pdf\n\
    scene_write_to_paper -format=guessed -show_console out.pgf\n\
  See also:\n\
    app_out_dir\n\
");
    return s_help;
  }

  static bool _node_to_bsg(gui_viewer& a_gv,const std::vector<std::string>& a_args,node& a_node) { //used also in exlib/cbk/out.
    static const std::string s_header("inlib::sg::gui_viewer::_node_to_bsg :");
    inlib::args _args(a_args);
    std::string path;
    if(_args.is_arg("-out_dir")) {
      if(a_gv.out_dir().empty()) {
        a_gv.insh().warn(s_header+" out_dir() is empty.");
        return false;
      }
      if(!check_dir(a_gv.out(),a_gv.out_dir())) {
        a_gv.insh().warn(s_header+" can't get out_dir.");
        return false;
      }
      path = a_gv.out_dir()+sep();
    }
    std::string file;
    if(!_args.first_not_hyphen(file)) {
      a_gv.insh().warn(s_header+" no output file given.");
      return false;
    }
    path += file;
  //if(_args.is_arg("-exsg")) write_exsg _action(a_gv.out());
    write_bsg _action(a_gv.out());
    if(!_action.open_buffer()) {
      a_gv.insh().warn(s_header+" open_buffer() failed.");
      return false;
    }
    if(!a_node.write(_action)) {
      a_gv.insh().warn(s_header+" write() failed.");
      return false;
    }
    if(!_action.close_buffer()) {
      a_gv.insh().warn(s_header+" close_buffer() failed.");
      return false;
    }
    if(!_action.write_file(path)) {
      a_gv.insh().warn(s_header+" write_file() failed.");
      return false;
    }
    a_gv.show_console(path+" produced.");
    return true;
  }
  static const std::string& _scene_write_to_bsg_help() {
    static const std::string s_help("\
scene_write_to_bsg: scene_write_to_bsg [-out_dir] file\n\
  Write the scene scene graph to a bsg (binary file format) file.\n\
  If no directory is given in file, the -out_dir option permits to prepend the\n\
  application output directory to file.\n\
  See also: app_dir -out_dir\n\
  Example:\n\
    scene_write_to_bsg -out_dir my_scene.bsg\n\
");
    return s_help;
  }

  static void setup_anims(std::ostream& a_out,node& a_from,float a_time_min,float a_time_max,float a_delay,bool a_end_begin) {
    search_action sa(a_out);
    typedef search_action::path_t path_t;
    const std::vector<path_t>& paths = find_paths(sa,a_from,slice_anim::s_class());
    inlib_vforcit(path_t,paths,it) {
      const path_t& p = *it;
      node* _node = p.size()?p[p.size()-1]:0;
      if(!_node) continue;
      slice_anim* _anim = safe_cast<node,slice_anim>(*_node);
      if(!_anim) continue;
      _anim->time_min = a_time_min;
      _anim->time_max = a_time_max;
      _anim->delay = a_delay;
      _anim->end_begin = a_end_begin;
      _anim->set_start(atime::now());
      //::printf("debug : start anim %lu\n",_anim);
    }
  }

#define INLIB_GUI_VIEWER__GET_ARG_FLOAT(a__variable)\
   {std::string svalue;\
    if(_args.find(std::string("-")+#a__variable,svalue)) {\
      float _value;\
      if(!inlib::to<float>(svalue,_value)) {\
        m_insh.warn(s_header+" : "+svalue+" is not a float.");\
        return;\
      }\
      a__variable  = _value;\
    }}

//#define INLIB_GUI_VIEWER__GET_ARG_DOUBLE(a__variable)\
//   {std::string svalue;\
//    if(_args.find(std::string("-")+#a__variable,svalue)) {\
//      double _value;\
//      if(!inlib::to<double>(svalue,_value)) {\
//        m_insh.warn(s_header+" : "+svalue+" is not a double.");\
//        return;\
//      }\
//      a__variable  = _value;\
//    }}

#define INLIB_GUI_VIEWER__GET_ARG_BOOL(a__variable)\
   {std::string svalue;\
    if(_args.find(std::string("-")+#a__variable,svalue)) {\
      bool _value;\
      if(!inlib::to(svalue,_value)) {\
        m_insh.warn(s_header+" : "+svalue+" is not a bool.");\
        return;\
      }\
      a__variable  = _value;\
    }}

  void scene_start_anim(const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::gui_viewer::scene_start_anim :");
    args _args(a_args);
    float time_min = FLT_MAX;
    INLIB_GUI_VIEWER__GET_ARG_FLOAT(time_min)
    float time_max = FLT_MIN;
    INLIB_GUI_VIEWER__GET_ARG_FLOAT(time_max)
    float delay = 0;
    INLIB_GUI_VIEWER__GET_ARG_FLOAT(delay)
    bool end_begin = false;
    INLIB_GUI_VIEWER__GET_ARG_BOOL(end_begin)
    setup_anims(m_out,scene(),time_min,time_max,delay,end_begin);
    enable_anim();
  }
#undef INLIB_GUI_VIEWER__GET_ARG_DOUBLE
#undef INLIB_GUI_VIEWER__GET_ARG_BOOL

  static const std::string& scene_start_anim_help() {
    static const std::string s_help("\
scene_start_anim: scene_start_anim [-tim_min,-time_max,-delay,-end_begin]\n\
  Start scene animation. It operates on all nodes in the scene inheriting sg::slice_anim\n\
  as xyzt_anim, cone_anim, show_time_anim.\n\
  -time_min=real event time start (in app specific unit).\n\
  -time_max=real event time end (in app specific unit).\n\
  -delay=real user elapsed time of the anim in secs.\n\
  -end_begin=bool if true, start again at end (default is false).\n\
  Example:\n\
    scene_start_anim -tim_min=0 -time_max=20 -delay=10\n\
");
    return s_help;
  }

private:
  INLIB_INSH_CLASS_CMD(gui_viewer,camera_rotate,m_holder._camera_rotate(a_args),_camera_rotate_help())
  INLIB_INSH_CLASS_CMD(gui_viewer,camera_yaw,m_holder._camera_yaw(a_args),"camera_yaw: camera_yaw [-deg,-degree] value\n  Rotate the camera around the up axis.\n  If specifying -deg or -degree, the value is taken in degrees.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,camera_pitch,m_holder._camera_pitch(a_args),"camera_pitch: camera_pitch [-deg,-degree] value\n  Rotate the camera around the left-right/x axis.\n  If specifying -deg or -degree, the value is taken in degrees.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,camera_roll,m_holder._camera_roll(a_args),"camera_roll: camera_roll [-deg,-degree] value\n  Rotate the camera around the direction of view axis.\n  If specifying -deg or -degree, the value is taken in degrees.\n")

  INLIB_INSH_CLASS_CMD(gui_viewer,scene_write_to_paper,_write_scene_to_paper(m_holder,a_args),_scene_write_to_paper_help())
  INLIB_INSH_CLASS_CMD(gui_viewer,scene_write_to_bsg,_node_to_bsg(m_holder,a_args,m_holder.scene()),_scene_write_to_bsg_help())
  INLIB_INSH_CLASS_CMD(gui_viewer,scene_count_points,m_holder._count_points(),"scene_count_points: scene_count_points\n Count number of points in the scene.\n")
//INLIB_INSH_CLASS_CMD(gui_viewer,scene_clear,m_holder.clear_scene(),insh::no_help())

  INLIB_INSH_CLASS_CMD(gui_viewer,event_stop_anim,m_holder.stop_event_anim(),"event_stop_anim: event_stop_anim\n  Stop the looping on events animation.\n")

  INLIB_INSH_CLASS_CMD(gui_viewer,scene_light_on,m_holder.set_scene_light_on(true),"scene_light_on: scene_light_on\n  Switch on the overall light.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,scene_light_off,m_holder.set_scene_light_on(false),"scene_light_off: scene_light_off\n  Switch off the overall light.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,scene_blend_on,m_holder.set_scene_blend_on(true),"scene_blend_on: scene_blend_on\n  Switch on the overall blending (and then transparency).\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,scene_blend_off,m_holder.set_scene_blend_on(false),"scene_blend_off: scene_blend_off\n  Switch off the overall blending (and then transparency).\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,scene_smooth_on,m_holder.set_scene_smooth_on(true),"scene_smooth_on: scene_smooth_on\n  Switch the overall shade model to smooth.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,scene_smooth_off,m_holder.set_scene_smooth_on(false),"scene_smooth_off: scene_smooth_off\n  Switch the overall shade model to flat.\n")

  INLIB_INSH_CLASS_CMD(gui_viewer,window_render,m_holder.win_render(),"window_render: window_render\n  Enforce an immediate rendering of the window.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,window_to_png,action_window_to_png(m_holder,a_args),_window_to_png_help())
  INLIB_INSH_CLASS_CMD(gui_viewer,window_to_jpeg,action_window_to_jpeg(m_holder,a_args),_window_to_jpeg_help())

  INLIB_INSH_CLASS_CMD(gui_viewer,gui_hide_console,m_holder.hide_console(),"gui_hide_console: gui_hide_console\n  Hide the upper left console text.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_hide_main_menu,m_holder.hide_main_menu(),"gui_hide_main_menu: gui_hide_main_menu\n  Hide the main menu and show the scene.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_show_main_menu,m_holder.show_main_menu(),"gui_show_main_menu: gui_show_main_menu\n  Show the main menu.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_hide_camera_menu,m_holder.hide_camera_menu(),"gui_hide_camera_menu: gui_hide_camera_menu\n  Hide the camera menu items.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_show_camera_menu,m_holder.show_camera_menu(),"gui_show_camera_menu: gui_show_camera_menu\n  Show the camera menu items.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_push_home,m_holder.push_home(),"gui_push_home: gui_push_home\n  Show the top list items in the main menu.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_push_back_item,m_holder.push_back_item(),"gui_push_back_item: gui_push_back_item\n  If being in a submenu of the main menu, return to the parent menu.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_hide_meta_zone,m_holder.hide_meta_zone(),"gui_hide_meta_zone: gui_hide_meta_zone\n  Hide the light blue area at the bottom of the window that permits to switch between scene mode and main menu mode.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_set_viewing_mode,m_holder.set_param_viewing(true),"gui_set_viewing_mode: gui_set_viewing_mode\n  When in scene mode, pass the cursor/touching in viewing mode.\n  It permits to move the camera with the mouse/touches.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_set_picking_mode,m_holder.set_param_viewing(false),"gui_set_picking_mode: gui_set_picking_mode\n  When in scene mode, pass the cursor/touching in picking mode.\n  It permits to pick an object and have a contextual popup on it.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_set_to_exit,m_holder.set_to_exit(),"gui_set_to_exit: gui_set_to_exit\n  Raise the application exit flag.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_text,m_holder.gui_text(a_args),"gui_text: gui_text [strings]\n  Show strings in a text widget.\n  gui_text line_1 line_2 line_3\n  gui_show_main_menu\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_scroll_text,m_holder.gui_scroll_text(a_args),"gui_scroll_text: gui_scroll_text [strings]\n  Show strings in a scrolling text widget.\n  gui_scroll_text line_1 line_2 line_3 line_4 line_5 line_6\n  gui_show_main_menu\n")

  INLIB_INSH_CLASS_CMD(gui_viewer,gui_enable_anim,m_holder.enable_anim(),"gui_enable_anim: gui_enable_anim\n  Enable animations.\n")
  INLIB_INSH_CLASS_CMD(gui_viewer,gui_disable_anim,m_holder.disable_anim(),"gui_disable_anim: gui_disable_anim\n  Disable animations.\n")

  INLIB_INSH_CLASS_CMD(gui_viewer,sys_home_dir,{std::string s;dir::home(s);m_holder.insh().out(s);},sys_home_dir_help())
  INLIB_INSH_CLASS_CMD(gui_viewer,sys_file_sep,m_holder.insh().out(sep()),sys_file_sep_help())
  INLIB_INSH_CLASS_CMD(gui_viewer,sys_path_sep,m_holder.insh().out(psep()),sys_path_sep_help())
  INLIB_INSH_CLASS_CMD(gui_viewer,ls,inlib::insh_ls(m_holder.insh(),a_args),inlib::insh_ls_help())
  INLIB_INSH_CLASS_CMD(gui_viewer,tput,inlib::insh_tput(m_holder.m_insh,a_args),inlib::insh_tput_help())

  void insh_add_cmds() {
  //INLIB_GUI_VIEWER_ADD_BOOL_VOID_CMD(camera_adapt_to_scene,adapt_camera_to_scene,insh::no_help)
    INLIB_GUI_VIEWER_ADD_BOOL_VOID_CMD_HELP(camera_view_all,adapt_camera_to_scene,"camera_view_all: camera_view_all\n  Arrange the camera so that all the scene elements are viewed.\n")
    INLIB_GUI_VIEWER_ADD_VOID_VOID_CMD_HELP(camera_reset,reset_camera,"camera_reset: camera_reset\n  Reset camera parameters.\n  It is usefull if being lost in space.\n")
    INLIB_GUI_VIEWER_ADD_BOOL_VOID_CMD_HELP(camera_swap_kind,swap_camera_kind,"camera_swap_kind: camera_swap_kind\n  Swap camera between ortho and perspective.\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_start_anim,_camera_start_anim,_camera_start_anim_help)
    INLIB_GUI_VIEWER_ADD_VOID_VOID_CMD_HELP(camera_stop_anim,stop_cam_anim,"camera_stop_anim: camera_stop_anim,\n  If any on, stop a camera animation.\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_translate_position,_camera_translate_position,_camera_translate_position_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_set_position,_camera_set_position,_camera_set_position_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_set_orientation,_camera_set_orientation,_camera_set_orientation_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_zoom,_camera_zoom,_camera_zoom_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_set_znear,_camera_set_znear,"camera_set_znear: camera_set_znear value\n  Set the camera znear (default 1).\n  znear is the distance toward the forward cut plan.\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_set_zfar,_camera_set_zfar,"camera_set_zfar: camera_set_zfar value\n  Set the camera zfar (default 10).\n  zfar is the distance toward the backward cut plan.\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_set_focal,_camera_set_focal,"camera_set_focal: camera_set_focal value\n  Set the camera focal length (default 1).\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_set_da,_camera_set_da,"camera_set_da: camera_set_da value\n  Set the rotation step factor in radians (default 0.017).\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(camera_set_dx,_camera_set_dx,"camera_set_dx: camera_set_dx value\n  Set the translation step factor (default 0.01).\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD_HELP(camera_set_ds,_camera_set_ds,"camera_set_ds: camera_set_ds value\n  Set the zoom step factor (default 0.99).\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(gui_set_console_layout,_set_console_layout,_set_console_layout_help)

    INLIB_INSH_ADD_CMD(m_insh,*this,camera_rotate)
    INLIB_INSH_ADD_CMD(m_insh,*this,camera_yaw)
    INLIB_INSH_ADD_CMD(m_insh,*this,camera_pitch)
    INLIB_INSH_ADD_CMD(m_insh,*this,camera_roll)

    INLIB_INSH_ADD_CMD(m_insh,*this,window_render)
    INLIB_INSH_ADD_CMD(m_insh,*this,window_to_png)
    INLIB_INSH_ADD_CMD(m_insh,*this,window_to_jpeg)

    INLIB_INSH_ADD_CMD(m_insh,*this,scene_light_on)
    INLIB_INSH_ADD_CMD(m_insh,*this,scene_light_off)
    INLIB_INSH_ADD_CMD(m_insh,*this,scene_blend_on)
    INLIB_INSH_ADD_CMD(m_insh,*this,scene_blend_off)
    INLIB_INSH_ADD_CMD(m_insh,*this,scene_smooth_on)
    INLIB_INSH_ADD_CMD(m_insh,*this,scene_smooth_off)
    INLIB_INSH_ADD_CMD(m_insh,*this,scene_write_to_paper)
    INLIB_INSH_ADD_CMD(m_insh,*this,scene_write_to_bsg)
  //INLIB_INSH_ADD_CMD(m_insh,*this,clear_scene)
    INLIB_INSH_ADD_CMD(m_insh,*this,scene_count_points)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(scene_set_clear_color,_scene_set_clear_color,_scene_set_clear_color_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(scene_bounding_box,_scene_bounding_box,_scene_bounding_box_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(scene_remove_nodes,_scene_remove_nodes,_scene_remove_nodes_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(scene_start_anim,scene_start_anim,scene_start_anim_help)

    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(style_print_colormaps,_style_print_colormaps,_style_print_colormaps_help)

    INLIB_INSH_ADD_CMD(m_insh,*this,event_stop_anim)

    INLIB_INSH_ADD_CMD(m_insh,*this,gui_hide_console)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_hide_main_menu)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_show_main_menu)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_hide_camera_menu)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_show_camera_menu)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_push_home)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_push_back_item)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_hide_meta_zone)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_text)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_scroll_text)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_set_viewing_mode)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_set_picking_mode)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_set_to_exit)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(gui_show_console,_show_console,"gui_show_console: gui_show_console\n  Show the upper left console text.\n")
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(gui_exec_main_menu_item,_exec_menu_item,_exec_menu_item_help)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_enable_anim)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_disable_anim)

    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(app_open,_open,_open_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(app_openers,_openers,_openers_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(app_dir,_app_dir,_app_dir_help)
    INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD(app_color_value,_app_color_value,_app_color_value_help)

    INLIB_INSH_ADD_CMD(m_insh,*this,sys_home_dir)
    INLIB_INSH_ADD_CMD(m_insh,*this,sys_file_sep)
    INLIB_INSH_ADD_CMD(m_insh,*this,sys_path_sep)
    INLIB_INSH_ADD_CMD(m_insh,*this,ls)
    INLIB_INSH_ADD_CMD(m_insh,*this,tput)
  }

#undef INLIB_GUI_VIEWER_ADD_VOID_ARGS_CMD
#undef INLIB_GUI_VIEWER_ADD_BOOL_VOID_CMD
#undef INLIB_GUI_VIEWER_ADD_VOID_VOID_CMD

protected:
  class gui_insh : public insh {
    typedef insh parent;
  public:
    virtual void map_warn(const std::string& a_msg,bool a_warn = true) {m_gv.map_warn(a_msg,a_warn);}
  public:
    gui_insh(gui_viewer& a_gv):parent(a_gv.out()),m_gv(a_gv) {}
    virtual ~gui_insh() {}
  public:
    gui_insh(const gui_insh& a_from):parent(a_from),m_gv(a_from.m_gv) {}
    gui_insh& operator=(const gui_insh& a_from) {parent::operator=(a_from);return *this;}
  protected:
    gui_viewer& m_gv;
  };

protected:

  void check_gui_cursor() {
    if(gui_visible.touched()){
      create_gui();
      gui_visible.reset_touched();
    }

    if( cursor_visible.touched()    ||
        cursor_line_width.touched() ||
        cursor_model.touched()      ){
      //m_out << "debug : inlib::sg::gui_viewer::render : create_cursor."
      //      << std::endl;
      create_cursor();
      cursor_visible.reset_touched();
      cursor_line_width.reset_touched();
      cursor_model.reset_touched();
    }
  }
protected:
  bool search_button(base_button* a_node) {
    search_action action(m_out);
    action.set_class(base_button::s_class());
    m_gui->search(action);
    const ptrs_t& objs = action.objs();
    ptrs_t::const_iterator it;
    for(it=objs.begin();it!=objs.end();++it) {
      if(a_node==(*it)) return true;
    }
    return false;
  }
protected:
  bool touch_direction(int& a_x,int& a_y) {
    size_t num_touch = 4;
    if(m_touches.size()<num_touch) {a_x = 0;a_y = 0;return false;}
    size_t ibeg = m_touches.size()-num_touch;
    size_t iend = m_touches.size()-1;
    int beg_x = m_touches[ibeg].first;
    int beg_y = m_touches[ibeg].second;
    int end_x = m_touches[iend].first;
    int end_y = m_touches[iend].second;
    a_x = end_x-beg_x;
    a_y = end_y-beg_y;
    return true;
  }
protected:
  render_manager& m_render_manager;
  const base_freetype& m_ttf;
  sg::zb_manager m_zb_mgr; //sg is needed.
  sg::gl2ps_manager m_gl2ps_mgr;
  mem_manager m_mem_mgr;

private:
  selection* m_scene;
protected:
  //selection m_backup_scene;

  base_camera* m_scene_camera;
  node* m_reset_camera;
  torche* m_scene_light;
  blend* m_scene_blend;
  shade_model* m_scene_shade_model;

private:
  selection* m_gui;
protected:
  separator m_full_sep;

  _switch m_scene_switch;
  _switch m_main_menu_switch;
  _switch m_camenu_switch;
  separator m_camenu_sep;

  text_button m_camenu_anim_mode_button;
  image_button m_camenu_sshoot_image_button;
  text_button m_camenu_sshoot_text_button;
  image_button m_camenu_90_image_button;
  text_button m_camenu_90_text_button;
  text_button m_camenu_focal_button;
  text_button m_camenu_viewing_button;
  text_button m_camenu_plane_exam_button;

  image_button m_camenu_gsto_image_button;
  text_button m_camenu_gsto_text_button;

  image_button m_camenu_light_image_button;
  text_button m_camenu_light_text_button;

  image_button m_camenu_blend_image_button;
  text_button m_camenu_blend_text_button;

  image_button m_camenu_smooth_image_button;
  text_button m_camenu_smooth_text_button;

  image_button m_camenu_disable_anim_image_button;
  text_button m_camenu_disable_anim_text_button;

  _switch m_gui_sliders_switch;
  _switch m_sliders_switch;
  matrix m_slider_1_matrix;
  matrix m_slider_2_matrix;
  matrix m_slider_3_matrix;
  matrix m_slider_4_matrix;
  slider m_slider_1;
  slider m_slider_2;
  slider m_slider_3;
  slider m_slider_4;
  separator m_hide_sliders_sep;
  matrix m_hide_sliders_matrix;

  _switch m_console_switch;
  matrix m_console_matrix;
  text_button m_console;

  _switch m_popup_switch;
  separator m_popup_sep;
  matrix m_popup_matrix;
  sg::cbks m_popup_cbks;

  _switch m_progress_switch;
  sg::progress m_progress;

  bool m_meta_had_been_shown;
  _switch m_meta_switch;

  std::vector<base_button*> m_tab_buttons;
  int m_tab_current; //could be (-1)

  std::vector<base_button*> m_arm_buttons;

  bool m_touch_in_motion; // X11, Android :
  int m_touch_prev_x;
  int m_touch_prev_y;
  typedef std::pair<int,int> one_touch;
  std::vector<one_touch> m_touches;

  unsigned int m_gesture_begin_x;
  unsigned int m_gesture_begin_y;
  node* m_gesture_begin_camera;

  slider* m_motion_slider;

  //bool m_treat_mouse_motion;

  //wall :
  separator m_cursor;
  _switch m_cursor_switch;
  base_camera* m_cursor_camera;
  matrix m_cursor_matrix;

  bool m_memory_warning;
  group m_tmp_group; //to deposit sg::holder to data.

  //action_prots_t m_action_prots;
  //end wall.

  dumpers_t m_dumpers;
  inlib::opener m_opener; //inlib:: needed.
  image::readers m_image_readers;
  png_writer m_png_writer;
  jpeg_writer m_jpeg_writer;

  bool m_vr_mode;
  args m_argcv;

  gui_insh m_insh;
  sg::object_manager m_object_manager; //for histos created with insh commands.
};

inline gui_viewer* cast_gui_viewer(viewer& a_viewer) {
  return safe_cast<viewer,gui_viewer>(a_viewer);
}

/////////////////////////////////////////////////////////////////////////////
/// list and action : ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

template <class FUNC,class DATA>
inline void add_item(gui_viewer& a_gv,ilist& a_widget,const std::string& a_label,FUNC a_func,const DATA& a_data) {
  a_widget.add(a_label,new fundata_cbk<gui_viewer,ilist,DATA>(a_gv,a_widget,a_func,a_data));
}

template <class FUNC>
inline void add_item(gui_viewer& a_gv,ilist& a_widget,const std::string& a_label,FUNC a_func) {
  a_widget.add(a_label,new fundata_cbk<gui_viewer,ilist,pos_data>(a_gv,a_widget,a_func,pos_data(false,0,0)));
}

template <class FUNC,class DATA>
inline void add_item_at_top(gui_viewer& a_gv,list& a_widget,const std::string& a_label,FUNC a_func,const DATA& a_data) {
  a_widget.add_at_top(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
}

template <class FUNC>
inline void add_item_at_top(gui_viewer& a_gv,list& a_widget,const std::string& a_label,FUNC a_func) {
  a_widget.add_at_top(a_label,new fundata_cbk<gui_viewer,list,pos_data>(a_gv,a_widget,a_func,pos_data(false,0,0)));
}

template <class FUNC,class DATA>
inline void add_item_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,const std::string& a_label,FUNC a_func,const DATA& a_data) {
  a_widget.add_before(a_before,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
}

template <class FUNC>
inline void add_item_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,const std::string& a_label,FUNC a_func) {
  a_widget.add_before(a_before,a_label,new fundata_cbk<gui_viewer,list,pos_data>(a_gv,a_widget,a_func,pos_data(false,0,0)));
}

template <class FUNC,class DATA>
inline void add_image_item(gui_viewer& a_gv,list& a_widget,const std::string& a_label,const std::string& a_img_file,
                           FUNC a_func,const DATA& a_data) {
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_res_file(a_img_file,img)) {
      a_widget.add(a_label,img,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    } else {
      a_widget.add(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    }
  } else {
    a_widget.add(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
  }
}

template <class FUNC,class DATA>
inline void add_image_item_after(gui_viewer& a_gv,list& a_widget,const std::string& a_after,
                                 const std::string& a_label,const std::string& a_img_file,
                                 FUNC a_func,const DATA& a_data) {
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_res_file(a_img_file,img)) {
      a_widget.add_after(a_after,a_label,img,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    } else {
      a_widget.add_after(a_after,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    }
  } else {
    a_widget.add_after(a_after,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
  }
}

template <class FUNC,class DATA>
inline void add_image_item_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                 const std::string& a_label,const std::string& a_img_file,
                                 FUNC a_func,const DATA& a_data) {
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_res_file(a_img_file,img)) {
      a_widget.add_before(a_before,a_label,img,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    } else {
      a_widget.add_before(a_before,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    }
  } else {
    a_widget.add_before(a_before,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
  }
}

template <class FUNC>
inline void add_image_item_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                  const std::string& a_label,const std::string& a_img_file,FUNC a_func) {
  add_image_item_before<FUNC,pos_data>(a_gv,a_widget,a_before,a_label,a_img_file,a_func,pos_data(false,0,0));
}

template <class FUNC>
inline void add_image_item_after(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                 const std::string& a_label,const std::string& a_img_file,FUNC a_func) {
  add_image_item_after<FUNC,pos_data>(a_gv,a_widget,a_before,a_label,a_img_file,a_func,pos_data(false,0,0));
}

template <class FUNC,class DATA>
inline void add_image_item_at_top(gui_viewer& a_gv,list& a_widget,
                                  const std::string& a_label,const std::string& a_img_file,
                                  FUNC a_func,const DATA& a_data) {
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_res_file(a_img_file,img)) {
      a_widget.add_at_top(a_label,img,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    } else {
      a_widget.add_at_top(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    }
  } else {
    a_widget.add_at_top(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
  }
}

template <class FUNC>
inline void add_image_item_at_top(gui_viewer& a_gv,list& a_widget,
                                  const std::string& a_label,const std::string& a_img_file,FUNC a_func) {
  add_image_item_at_top<FUNC,pos_data>(a_gv,a_widget,a_label,a_img_file,a_func,pos_data(false,0,0));
}

template <class FUNC>
inline void add_image_item(gui_viewer& a_gv,list& a_widget,const std::string& a_label,const std::string& a_img_file,FUNC a_func) {
  add_image_item<FUNC,pos_data>(a_gv,a_widget,a_label,a_img_file,a_func,pos_data(false,0,0));
}

template <class FUNC,class DATA>
inline void add_white_item(gui_viewer& a_gv,list& a_widget,const std::string& a_label,FUNC a_func,const DATA& a_data) {
  add_image_item<FUNC,DATA>(a_gv,a_widget,a_label,s_white_jpg(),a_func,a_data);
}

template <class FUNC>
inline void add_white_item(gui_viewer& a_gv,list& a_widget,const std::string& a_label,FUNC a_func) {
  add_white_item<FUNC,pos_data>(a_gv,a_widget,a_label,a_func,pos_data(false,0,0));
}

/////////////////////////////////////////////////////////////////////////////
/// insh : //////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline void add_item_insh(gui_viewer& a_gv,ilist& a_widget,const std::string& a_label,const std::string& a_script) {
  add_item(a_gv,a_widget,a_label,gui_viewer::action_insh_source_script,a_script);
}
inline void add_image_item_insh(gui_viewer& a_gv,list& a_widget,const std::string& a_label,const std::string& a_img_file,const std::string& a_script) {
  add_image_item(a_gv,a_widget,a_label,a_img_file,gui_viewer::action_insh_source_script,a_script);
}

inline void add_white_item_insh(gui_viewer& a_gv,list& a_widget,const std::string& a_label,const std::string& a_script) {
  add_image_item_insh(a_gv,a_widget,a_label,s_white_jpg(),a_script);
}

inline void add_image_item_insh_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                  const std::string& a_label,const std::string& a_img_file,const std::string& a_script) {
  add_image_item_before(a_gv,a_widget,a_before,a_label,a_img_file,gui_viewer::action_insh_source_script,a_script);
}

inline void add_image_item_insh_after(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                  const std::string& a_label,const std::string& a_img_file,const std::string& a_script) {
  add_image_item_after(a_gv,a_widget,a_before,a_label,a_img_file,gui_viewer::action_insh_source_script,a_script);
}
inline void add_image_item_insh_at_top(gui_viewer& a_gv,list& a_widget,
                                  const std::string& a_label,const std::string& a_img_file,const std::string& a_script) {
  add_image_item_at_top(a_gv,a_widget,a_label,a_img_file,gui_viewer::action_insh_source_script,a_script);
}


inline void create_main_button_insh(gui_viewer& a_gv,
                                    float a_wcw,float a_wch,float a_wb,float a_hb,float a_roffset,
                                    unsigned int a_col,unsigned int a_row,
                                    const std::string& a_label,const std::string& a_img_label,const std::string& a_img,
                                    const std::string& a_script) {
  create_main_button(a_gv.out(),a_gv.res_dir(),a_gv.m_params,a_gv.image_readers(),a_gv.ttf(),
                     a_gv.camenu_sep(),a_wcw,a_wch,a_wb,a_hb,a_roffset,a_col,a_row,
                     a_label,a_img_label,a_img,
                     new gv_data_cbk<std::string>(a_gv,gui_viewer::action_insh_source_script,a_script));
}

inline void create_main_button_insh(gui_viewer& a_gv,
                                    float a_wcw,float a_wch,float a_wb,float a_hb,float a_roffset,
                                    unsigned int a_col,unsigned int a_row,
                                    image_button& a_img_button,text_button& a_button,
                                    const std::string& a_label,const std::string& a_img,
                                    const std::string& a_script) {
  create_main_button(a_gv.out(),a_gv.res_dir(),a_gv.m_params,a_gv.image_readers(),
                     a_gv.camenu_sep(),a_wcw,a_wch,a_wb,a_hb,a_roffset,a_col,a_row,
                     a_img_button,a_button,a_label,a_img,
                     new gv_data_cbk<std::string>(a_gv,gui_viewer::action_insh_source_script,a_script));
}

inline void gui_push_list_insh(gui_viewer& a_gv,const std::vector<std::string>& a_text){
  if(a_text.empty()) {
    a_gv.map_warn_empty();
    return;
  }
  size_t nitem = a_text.size()/2;
  if(nitem*2!=a_text.size()) {
    a_gv.map_warn("even number of arguments expected.");
    return;
  }
  list* _list = new list(a_gv.ttf());
  a_gv.set_style(*_list);
  for(size_t index=0;index<nitem;index++) {
    add_white_item_insh(a_gv,*_list,a_text[2*index+0],a_text[2*index+1]);
  }
  a_gv.push_list(_list);
}

}}

/////////////////////////////////////////////////////////////////////////////
/// actions : ///////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#include <sys/types.h> //off_t

namespace inlib {
namespace sg {

inline return_action action_none(gui_viewer&) {return return_none;}

#define ACTION_GV_NONE(a__method) \
inline return_action action_##a__method(gui_viewer& a_gv) {\
  a_gv.a__method();\
  return return_none;\
}

#define ACTION_GV_RENDER(a__method) \
inline return_action action_##a__method(gui_viewer& a_gv) {\
  a_gv.a__method();\
  return return_to_render;\
}

#define ACTION_GV_HIDE_MAIN_MENU(a__method) \
inline return_action action_##a__method(gui_viewer& a_gv) {\
  a_gv.a__method();\
  a_gv.hide_main_menu();\
  return return_to_render;\
}

ACTION_GV_NONE(set_to_exit)
ACTION_GV_NONE(clear_caches)
ACTION_GV_NONE(clear_doc_dir)
ACTION_GV_NONE(stop_event_anim)

ACTION_GV_RENDER(clear_scene)
ACTION_GV_RENDER(console_mag_two)
ACTION_GV_RENDER(adapt_camera_to_scene)
ACTION_GV_RENDER(toggle_gsto)
ACTION_GV_RENDER(toggle_light)
ACTION_GV_RENDER(toggle_blend)

ACTION_GV_HIDE_MAIN_MENU(reset_camera)
ACTION_GV_HIDE_MAIN_MENU(start_anim_around_focal)
ACTION_GV_HIDE_MAIN_MENU(remove_manips)
ACTION_GV_HIDE_MAIN_MENU(enable_anim)
ACTION_GV_HIDE_MAIN_MENU(disable_anim)

#undef ACTION_GV_NONE
#undef ACTION_GV_RENDER
#undef ACTION_GV_HIDE_MAIN_MENU

inline return_action action_about(gui_viewer& a_gv,const std::vector<std::string>& a_data) {
  a_gv.gui_text(a_data);
  return return_to_render;
}

inline return_action action_infos(gui_viewer& a_gv) {
/*
  std::vector<std::string> text;

  text.push_back(" ");
  text.push_back("data_dirs :");
  append(text,a_gv.data_dirs());

  text.push_back(" ");
  text.push_back("res_dir :");
  text.push_back(a_gv.res_dir());

  text.push_back(" ");
  text.push_back("out_dir :");
  text.push_back(a_gv.out_dir());

  text.push_back(" ");
  text.push_back("tmp_dir :");
  text.push_back(a_gv.tmp_dir());

  text.push_back(" ");
  text.push_back("start dir :");
  text.push_back(a_gv.start_dir());

  text.push_back(" ");
  text.push_back("home :");
  text.push_back(dir::home());

  text.push_back(" ");
  text.push_back("sizeof(void*) :");
  text.push_back(to(int(sizeof(void*))));

  text.push_back(" ");
  text.push_back("sizeof(long long) :");
  text.push_back(to(int(sizeof(long long))));

  text.push_back(" ");
  text.push_back("little endian :");
  text.push_back(to(is_little_endian()));

  a_gv.gui_text(text);
*/

  sg::list* list = new sg::list(a_gv.ttf());
  a_gv.set_style(*list);

 {std::string _s("doc : ");
  _s += a_gv.doc_dir();
  add_item(a_gv,*list,_s,action_none);}

// too long !
//   {std::string _s("res : ");
//    _s += a_gv.res_dir();
//    add_item(a_gv,*list,_s,action_none);}

 {std::string _s("out : ");
  _s += a_gv.out_dir();
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("tmp : ");
  _s += a_gv.tmp_dir();
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("start : ");
  _s += a_gv.start_dir();
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("home : ");
  std::string sh;
  dir::home(sh);
  _s += sh;
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("void* : ");
  if(!numas<uint32>(sizeof(void*),_s)){}
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("long long : ");
  if(!numas<uint32>(sizeof(long long),_s)){}
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("off_t : ");
  if(!numas<uint32>(sizeof(off_t),_s)){}
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("LI : ");
  bas(is_little_endian(),_s);
  add_item(a_gv,*list,_s,action_none);}

 {std::vector<std::string> _v;
  a_gv.gl_infos(_v);
  inlib_vforcit(std::string,_v,it) add_item(a_gv,*list,*it,action_none);}

  a_gv.push_list(list);

  return return_to_render;
}

inline return_action action_set_console(gui_viewer& a_gv,keyboard& a_widget) {
  a_gv.hide_main_menu();
  a_gv.show_console(a_widget.value.value());
  return return_to_render;
}

inline return_action action_console(gui_viewer& a_gv) {
  keyboard* node = new keyboard(a_gv.ttf());
  a_gv.set_style(*node);
  add_callback(a_gv,*node,action_set_console);
  a_gv.push_list(node);
  return return_to_render;
}

inline return_action action_show_styles(gui_viewer& a_gv) {
  std::vector<std::string> ltext;
  std::vector<std::string> rtext;

 {typedef xml::styles::style_t style_t;
  typedef xml::styles::named_style_t named_style_t;
  const std::vector<named_style_t>& nstys = a_gv.styles().named_styles();
  std::vector<named_style_t>::const_iterator it;
  for(it=nstys.begin();it!=nstys.end();++it) {
    ltext.push_back("//////////////////////////////////////////////////////////////////////////////");
    rtext.push_back(" ");

    ltext.push_back((*it).first+" :");
    rtext.push_back(" ");

    ltext.push_back("//////////////////////////////////////////////////////////////////////////////");
    rtext.push_back(" ");

    const style_t& sty = (*it).second;
    style_t::const_iterator vit;
    for(vit=sty.begin();vit!=sty.end();++vit) {
      //text->lstrings.add((*vit).first);
      //text->rstrings.add((*vit).second);
      ltext.push_back((*vit).first);
      rtext.push_back((*vit).second);
    }
  }}

  a_gv.gui_scroll_infos(ltext,rtext);
  return return_to_render;
}

inline return_action action_utils(gui_viewer& a_gv) {
  sg::list* list = new sg::list(a_gv.ttf());
  a_gv.set_style(*list);

  sg::add_white_item(a_gv,*list,"clear cache",action_clear_caches);
  sg::add_white_item(a_gv,*list,"remove manips",action_remove_manips);
  sg::add_white_item(a_gv,*list,"disable anim",action_disable_anim);
  sg::add_white_item(a_gv,*list,"enable anim",action_enable_anim);
  sg::add_white_item(a_gv,*list,"clear scene",action_clear_scene);
  sg::add_image_item(a_gv,*list,"set console","console.jpg",action_console);
  sg::add_image_item(a_gv,*list,"infos","routing_step.jpg",action_infos);
  sg::add_white_item(a_gv,*list,"styles",action_show_styles);
  sg::add_white_item(a_gv,*list,"clear doc dir",action_clear_doc_dir);

  a_gv.push_list(list);

  return return_to_render;
}

inline return_action action_open_open_panel(gui_viewer& a_gv,const pos_data& a_data) {
  std::string path;
  if(a_gv.open_panel(path)) {
    args _args;
   {std::string sv;b2s(a_data.m_popup,sv);
    _args.add(s_popup(),sv);
    num2s(a_data.m_ex,sv);
    _args.add(sg::s_ex(),sv);
    num2s(a_data.m_ey,sv);
    _args.add(sg::s_ey(),sv);}

    bool done;
    if(a_gv.opener().open(path,file::s_format_guessed(),_args,done)) {
      if(!done) {
        a_gv.warn("don't know how to open "+path);
      }
    }
  }
  return return_to_render;
}

inline return_action action_toggle_camera_menu_at_pos(gui_viewer& a_gv,const pos_data& a_data) {
  a_gv.toggle_camera_menu_at_pos(a_data.m_ex,a_data.m_ey);
  return return_to_render;
}

// some common menu item names :
INLIB_GLOBAL_STRING(files)
INLIB_GLOBAL_STRING(export)
INLIB_GLOBAL_STRING(ftp)
//INLIB_GLOBAL_STRING(wall)
INLIB_GLOBAL_STRING(to_serv)
INLIB_GLOBAL_STRING(sg_serv)

}}

#include "infos"

namespace inlib {
namespace sg {

inline return_action action_infos_in_console(gui_viewer& a_gv,const pos_data&) {
  search_action sa(a_gv.out());
  const paths_t& paths = find_paths<infos>(sa,a_gv.scene());
  inlib_vforcit(path_t,paths,it) {
    infos* _node = tail<infos>(*it);
    if(_node) {
      std::string _s;
      if(_node->find_keyval(infos::s_title(),_s)) {
        a_gv.show_console(_s);
        return return_to_render;
      }
    }
  }
  return return_none;
}

inline base_camera* astro_pimg_camera(gui_viewer& a_gv,double a_sky_radius) {
  float znear = 1.0f;
  //float angle = fpi()/4.0f;
  //float near_height = 2 * znear * ftan(angle*0.5F);
  float near_height = 5;
  base_camera* camera = a_gv.create_camera(camera_ortho,near_height,znear);
  if(!camera) return 0;
  camera->zfar = float(10*a_sky_radius);
  //camera->position = vec3f(0,0,-20); //at center of the sphere
  camera->position = vec3f(0,0,0); //at center of the sphere
  //camera->orientation = rotf(vec3f(0,1,0),-fhalf_pi());
  //camera->orientation.value() *= rotf(vec3f(1,0,0),-fhalf_pi());
  //camera->orientation.value(camera->orientation.value()*rotf(vec3f(1,0,0),-fhalf_pi()));
  camera->focal = float(a_sky_radius);
  camera->dx = 0.1f;
  camera->da = 0.002f*fdeg2rad();
  return camera;
}

#define INLIB_GUI_VIEWER_GET_ARG_STRING(a__variable)\
  INLIB_ISHELL_GET_ARG_STRING(_args,a__variable)

#define INLIB_GUI_VIEWER_GET_ARG_FLOAT(a__where,a__variable,a__return)\
  INLIB_ISHELL_GET_ARG_FLOAT(a_gv.insh(),_args,a__where,a__variable,a__return)

#define INLIB_GUI_VIEWER_GET_ARG_DOUBLE(a__where,a__variable,a__return)\
  INLIB_ISHELL_GET_ARG_DOUBLE(a_gv.insh(),_args,a__where,a__variable,a__return)

#define INLIB_GUI_VIEWER_GET_ARG_UINT(a__where,a__variable,a__return)\
  INLIB_ISHELL_GET_ARG_UINT(a_gv.insh(),_args,a__where,a__variable,a__return)

#define INLIB_GUI_VIEWER_GET_ARG_BOOL(a__where,a__variable,a__return)\
  INLIB_ISHELL_GET_ARG_BOOL(a_gv.insh(),_args,a__where,a__variable,a__return)

#define INLIB_GUI_VIEWER_GET_ARG_COLOR(a__where,a__variable,a__return)\
   {std::string svalue;\
    std::string _key = std::string("-")+#a__variable;\
    if(_args.find(_key,svalue)) {\
      inlib::colorf _value;\
      if(!inlib::sg::find_color(a_gv.styles().cmaps(),svalue,_value)) {\
        a_gv.insh().warn(std::string(#a__where)+" : "+svalue+" is not a color.");\
        return a__return;\
      }\
      a__variable  = _value;\
      _args.remove(_key);\
    }}

#define INLIB_GUI_VIEWER_GET_ARG_GL_PRIM(a__where,a__variable,a__return)\
   {std::string svalue;\
    std::string _key = std::string("-")+#a__variable;\
    if(_args.find(_key,svalue)) {\
      inlib::gl::mode_t _value;\
      if(!inlib::gl::s2glprim(svalue,_value)) {\
        a_gv.insh().warn(std::string(#a__where)+" : "+svalue+" is not a gl primitive mode.");\
        return a__return;\
      }\
      a__variable  = _value;\
      _args.remove(_key);\
    }}

#define INLIB_GUI_VIEWER_GET_ARG_VEC3F(a__where,a__variable,a__return)\
   {std::string svalue;\
    std::string _key = std::string("-")+#a__variable;\
    if(_args.find(_key,svalue)) {\
      float x,y,z;\
      if(!inlib::to_3(svalue,x,y,z)) {\
        a_gv.insh().warn(std::string(#a__where)+" : "+svalue+" is not three floats.");\
        return a__return;\
      }\
      a__variable.set_value(x,y,z);\
      _args.remove(_key);\
    }}

#define INLIB_GUI_VIEWER_GET_ARG_VEC4F(a__where,a__variable,a__return)\
   {std::string svalue;\
    std::string _key = std::string("-")+#a__variable;\
    if(_args.find(_key,svalue)) {\
      float x,y,z,t;\
      if(!inlib::to_4(svalue,x,y,z,t)) {\
        a_gv.insh().warn(std::string(#a__where)+" : "+svalue+" is not four floats.");\
        return a__return;\
      }\
      a__variable.set_value(x,y,z,t);\
      _args.remove(_key);\
    }}

#define INLIB_GUI_VIEWER_GET_WIDGET_UINT(a__header,a__index,a__variable)\
   {const std::string& svalue = a_widget.values[a__index];\
    if(!inlib::to<unsigned int>(svalue,a__variable)) {\
      a_gv.insh().warn(std::string(#a__header)+" : "+svalue+" is not a uint.");\
      return inlib::sg::return_to_render;\
    }}
#define INLIB_GUI_VIEWER_GET_WIDGET_FLOAT(a__header,a__index,a__variable)\
   {const std::string& svalue = a_widget.values[a__index];\
    if(!inlib::to<float>(svalue,a__variable)) {\
      a_gv.insh().warn(std::string(#a__header)+" : "+svalue+" is not a float.");\
      return inlib::sg::return_to_render;\
    }}
#define INLIB_GUI_VIEWER_GET_WIDGET_DOUBLE(a__header,a__index,a__variable)\
   {const std::string& svalue = a_widget.values[a__index];\
    if(!inlib::to<double>(svalue,a__variable)) {\
      a_gv.insh().warn(std::string(#a__header)+" : "+svalue+" is not a double.");\
      return inlib::sg::return_to_render;\
    }}
#define INLIB_GUI_VIEWER_GET_WIDGET_BOOL(a__header,a__index,a__variable)\
   {const std::string& svalue = a_widget.values[a__index];\
    if(!inlib::to(svalue,a__variable)) {\
      a_gv.insh().warn(std::string(#a__header)+" : "+svalue+" is not a bool.");\
      return inlib::sg::return_to_render;\
    }}

}}

//inlib_build_use kernel

#endif
