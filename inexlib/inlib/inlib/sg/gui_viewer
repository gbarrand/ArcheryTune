// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_gui_viewer
#define inlib_sg_gui_viewer

#include "../platform"

#include "guiv"
#include "noderef"
#include "acbk"
#include "holder" //for m_tmp_group
#include "draw_style"
#include "_switch"
#include "ghost"
#include "style_parser"
#include "style"
#include "text_style"
#include "selection"
#include "torche"
#include "progress"
#include "slider"
#include "matrix"
#include "depth_test"
#include "ortho"
#include "perspective"
#include "frustum"
#include "lrbt"
#include "vertices"
#include "simple_button"
#include "button_grid"
#include "cube_manip"
#include "search"
#include "camera_anim"
#include "count_action"

#include "list"
#include "infos_box"
#include "scroll_text"
#include "scroll_infos"
#include "numeric"
#include "edvalop"
#include "entry"
#include "entries"
#include "colors"
#include "image_text_button"
#include "params2entries"
#include "enum2s"
#include "opener"

#include "../zfunc"

#include "../cbk/hide"
#include "../cbk/timer"
#include "../cbk/tag"
#include "../cbk/none"

#include "../event_timer"
#include "../vpair"
#include "../mapmanip"

#include "../wall/protocol" //fo set_wall_action_prots()

namespace inlib {
namespace sg {

INLIB_GLOBAL_STRING(files)
INLIB_GLOBAL_STRING(zoom_in_out)
INLIB_GLOBAL_STRING(zoom_in_out_rot)

class gui_viewer : public guiv {
  INLIB_HEADER(gui_viewer,inlib::sg::gui_viewer,guiv)
private:
  INLIB_CLASS_STRING(event_timer)
protected:  
  typedef std::vector<void*> ptrs_t;
public:
  static int SHOWN() {return 0;}
  static int HIDDEN() {return 1;}
public:
  virtual bool set_img_from_file(std::ostream&,
                                 const std::string& /*a_res_dir*/,
                                 const std::string& /*a_file*/,
                                 img_byte&) = 0;

public: //Android, iPhone.
  virtual void set_size(unsigned int a_w,unsigned int a_h) {
    //m_out << "debug : inlib::sg::gui_viewer::set_size :"
    //      << " ww " << a_w
    //      << " wh " << a_h
    //      << std::endl;
    parent::set_size(a_w,a_h);
    ask_to_rebuild_gui(); //should have a set_gui_layout().
    cursor_visible.touch();
  }

public: //alert
  virtual void warn(const std::string& a_msg,bool a_warn = true) {
    // if needed we could secure the execution in a work.
    map_warn(a_msg,a_warn);
  }
  virtual std::ostream& out_stream() const {return m_out;}
  virtual void show_console(const std::string& a_v) {
    m_console.set_label(a_v);
    show_console();
  }
public: //guib
  virtual void ask_to_rebuild_gui() {
    // invalidate cbks that contain pointer to buttons that are going to be deleted.
    invalidate_works(arm_work::s_class());
    invalidate_works(disarm_work::s_class());
    gui_visible.touch();
  }

public:
  virtual bool has_mail_panel() {return false;}
  virtual bool mail_panel(const std::string& /*a_to*/,
                          const std::string& /*a_subject*/,
                          const std::string& /*a_msg*/,
                          const std::string& /*a_path*/,
                          const std::string& /*a_mime*/){
    return false;
  }
  virtual bool has_open_panel() {return false;}
  virtual bool open_panel(std::string& a_path) {a_path.clear();return false;}
public:
  template <class T>
  void show_console(const T& a_v) {
    m_console.set_label(to<T>(a_v));
    show_console();
  }
public:
  virtual void clear_scene() {
    m_scene.clear();
    m_scene.clear_cbks();
    set_scene_camera(0);
    m_params.m_plane_viewer = true;
    m_params.m_cam_tiled = true;
    m_scene_light = 0;
    hide_sliders();    
    //stop_cam_anim();  //any cam_anim node are now deleted.
    //NOTE : we do not stop the event anim here. Someone may want to
    //       clear the scene for one event but continue to vis
    //       further events.
    //stop_event_anim();
  }

  // cursor :  
  virtual bool set_cursor_shape(cursor_shape a_shape) {
    cursor_model = a_shape;
    return true;
  }

  ///////////////////////////////////////////////////
  /// virtual for wall/common_main : ////////////////
  ///////////////////////////////////////////////////

  virtual base_camera* create_camera(
   camera_type a_type
  ,float a_near_height
  ,float a_near) {
    if(a_type==camera_ortho) {
      ortho* camera = new ortho;
      camera->height = a_near_height;
      camera->znear = a_near;
      return camera;
    } else if(a_type==camera_perspective) { 
      perspective* camera = new perspective;

      float angle = 2 * fatan((a_near_height*0.5f)/a_near);

      camera->height_angle = angle;
      camera->znear = a_near;

      return camera;
    } else {
      return 0;
    }   
  }

  // in case cam ortho, get one screen world coords size :
  virtual void get_gui_wcw_wch(float& a_wcw,float& a_wch,
                               float& a_tx,float& a_ty,
                               float& a_aspect) const {
    get_screen_wcw_wch(gui_camera_height(),
                       0,0,
                       a_wcw,a_wch,a_tx,a_ty,a_aspect);
  }

  virtual void get_screens(unsigned int& a_cols,unsigned int& a_rows){
    a_cols = 1;
    a_rows = 1;
  }

  virtual void get_screen_wcw_wch(float a_cam_height,
                                  unsigned int,unsigned int,
                                  float& a_wcw,float& a_wch,
                                  float& a_tx,float& a_ty,
                                  float& a_aspect) const {
    a_aspect = float(m_ww)/float(m_wh);
    a_wch = a_cam_height;
    a_wcw = a_wch*a_aspect;
    a_tx = 0;    
    a_ty = 0;    
  }

  virtual void get_gui_all_wcw_wch(float& a_wcw,float& a_wch) const {
    float aspect = float(m_ww)/float(m_wh);
    a_wch = gui_camera_height();
    a_wcw = a_wch*aspect;
  }

  virtual void get_inside_pixels(unsigned int& a_w,unsigned int& a_h) const {
    a_w = m_ww;
    a_h = m_wh;
  }

  virtual void screen_to_gui(int a_ix,int a_iy,float& a_x,float& a_y) const {
    // for popup.
    float aspect = float(m_ww)/float(m_wh);
    float wch = gui_camera_height();
    float wcw = wch*aspect;
    a_x = float(a_ix)*wcw/float(m_ww)-wcw*0.5f;
    a_y = float(a_iy)*wch/float(m_wh)-wch*0.5f;
  }

  virtual bool treat_anim(const atime& a_t) {
    anim_event e(a_t.seconds(),a_t.micro_seconds());
    event_action action(m_out,m_ww,m_wh,e);
    m_sg.event(action);
    return e.some_found(); //someone did something with this event.
  }

  virtual void enable_anim() {
    if(has_valid_work(anim_work::s_class())) return;
    add_work(new anim_work(*this));
  }

  virtual void disable_anim() {
    invalidate_works(anim_work::s_class());
  }

  virtual void ask_to_sync_clients() {}

  virtual void wait_sync_client() {}

  virtual void clear_caches() {
    m_tmp_group.clear();
  }

  ////////////////////////////////////
  /// camedit panel : ////////////////
  ////////////////////////////////////

  virtual bool swap_camera_kind(){
    if(!m_scene_camera) return false;

    base_camera* new_cam = 0;

    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){

      //have to find a correct value for an ortho height.

      ortho* new_oc = new ortho;
      new_oc->height =
        2.0f*m_scene_camera->focal.value()*ftan(pc->height_angle.value()*0.5f);
      new_cam = new_oc;

    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
      //have to find a correct value for a perspective angle_height.

      perspective* new_pc = new perspective;
      // we assume that ortho height "at focal" is a good parameter
      // to guess a reasonnable perspective height_angle.
      new_pc->height_angle = 
        2.0f*fatan2(0.5f*oc->height.value(),m_scene_camera->focal.value());
      new_cam = new_pc;

    } else {
      m_out << "inlib::sg::gui_viewer::swap_camera_kind :"
                    << " camera not ortho and not perspective."
                    << std::endl;
      return false;
    }

    new_cam->znear = m_scene_camera->znear;
    new_cam->zfar = m_scene_camera->zfar;
    new_cam->position = m_scene_camera->position;
    new_cam->orientation = m_scene_camera->orientation;
    new_cam->dx = m_scene_camera->dx;
    new_cam->da = m_scene_camera->da;
    new_cam->ds = m_scene_camera->ds;
    new_cam->focal = m_scene_camera->focal;

    set_scene_camera(new_cam);

    return true;
  }

public:
  virtual inlib::opener& opener() {return m_opener;}

private:
  sf<bool> gui_visible;
public:

  sf<bool> cursor_visible;
  sf<float> cursor_line_width;
  sf_enum<cursor_shape> cursor_model;

  sf<bool> params_button_visible;
  sf<bool> camera_button_visible;

  sf<bool> camenu_edit_visible;
  sf<bool> camenu_90_visible;
  sf<bool> camenu_focal_visible;
  sf<bool> camenu_viewing_visible;
public:
  gui_viewer(std::ostream& a_out,
             gl_manager& a_gl_mgr,
             const base_freetype& a_ttf,
             unsigned int a_width,unsigned int a_height,
             bool a_verbose = false)
  :parent(a_out,a_width,a_height,a_verbose)

  ,gui_visible(true)
  ,cursor_visible(false)
  ,cursor_line_width(2)
  ,cursor_model(cursor_default)
  ,params_button_visible(true)
  ,camera_button_visible(true)

  ,camenu_edit_visible(true)
  ,camenu_90_visible(true)
  ,camenu_focal_visible(true)
  ,camenu_viewing_visible(true)

  ,m_gl_mgr(a_gl_mgr)
  ,m_ttf(a_ttf)

  ,m_scene_camera(0)
  ,m_reset_camera(0)
  ,m_scene_light(0)

  ,m_camenu_shift_button(a_ttf)
  ,m_camenu_sshoot_text_button(a_ttf)
  ,m_camenu_90_text_button(a_ttf)
  ,m_camenu_focal_button(a_ttf)
  ,m_camenu_viewing_button(a_ttf)
  ,m_camenu_gsto_button(a_ttf)
  ,m_camenu_plane_exam_button(a_ttf)
  ,m_console(a_ttf)

  ,m_popup_cbks()

  ,m_meta_had_been_shown(false)

  ,m_tab_current(-1)

  ,m_touch_in_motion(false)
  ,m_touch_prev_x(0)
  ,m_touch_prev_y(0)

  ,m_gesture_begin_x(0)
  ,m_gesture_begin_y(0)
  ,m_gesture_begin_camera(0)

  ,m_motion_slider(0)

  ,m_treat_mouse_motion(false)

  ,m_cursor_camera(0)

  ,m_memory_warning(false)
  //,m_jpeg_data(a_out)

  ,m_zip_func(0)
  ,m_unzip_func(0)
  ,m_action_prots()

  ,m_dumpers()
  ,m_opener(*this,0)
  {
    //WARNING : in m_sg, m_scene_switch expected at 0, m_gui at 1.
    //          If changing that, look at touch_[down,up]().
    m_sg.add(new noderef(m_scene_switch));

    m_scene_switch.add(new noderef(m_scene));
    m_scene_switch.add(new separator());
    m_scene_switch.which = gui_visible.value()?HIDDEN():SHOWN();

    //m_gui after m_scene because it disables depth test.
    // (But for picking it should be traversed first !)
    m_sg.add(new noderef(m_gui));

    m_gui.down_cbks().add(new gui_cbk(*this,gui_cbk::action_touch_down()));
    m_gui.up_cbks().add(new gui_cbk(*this,gui_cbk::action_touch_up()));
    m_gui.move_cbks().add(new gui_cbk(*this,gui_cbk::action_touch_move()));
    //m_gui.stop_at_first = true; //FIXME : because of buttons.
    //m_gui.verbose = true;

    m_sg.add(new noderef(m_cursor));

    m_main_menu_switch.which = gui_visible.value()?SHOWN():HIDDEN();
    m_camenu_switch.which = HIDDEN();
    m_gui_sliders_switch.which = HIDDEN();
    m_sliders_switch.which = HIDDEN();
    m_progress_switch.which = HIDDEN();
    m_console_switch.which = HIDDEN();
    m_popup_switch.which = HIDDEN();
    m_meta_switch.which = HIDDEN();
    m_cursor_switch.which = HIDDEN();

    m_cursor_matrix.set_identity();

    m_console.set_arconf("");
    m_console.hjust = sg::left;
    m_console.confine = false;
    m_console.add_callback(new inlib::cbk::hide(m_console_switch));

    // set default gsto mode on m_params :
    gsto_mode2s(m_gl_mgr.get_gsto_mode(),m_params.m_gsto_mode);
  }
  virtual ~gui_viewer(){
    inlib::clear<std::string,cbk::tag>(m_dumpers);
    delete m_reset_camera;
    delete m_gesture_begin_camera;
  }
protected:
  gui_viewer(const gui_viewer& a_from)
  :ui(a_from)
  ,alert(a_from)
  ,parent(a_from)

  ,gui_visible(a_from.gui_visible)
  ,cursor_visible(a_from.cursor_visible)
  ,cursor_line_width(a_from.cursor_line_width)
  ,cursor_model(a_from.cursor_model)
  ,params_button_visible(a_from.params_button_visible)
  ,camera_button_visible(a_from.camera_button_visible)

  ,camenu_edit_visible(a_from.camenu_edit_visible)
  ,camenu_90_visible(a_from.camenu_90_visible)
  ,camenu_focal_visible(a_from.camenu_focal_visible)
  ,camenu_viewing_visible(a_from.camenu_viewing_visible)

  ,m_gl_mgr(a_from.m_gl_mgr)
  ,m_ttf(a_from.m_ttf)

  ,m_scene_camera(0)
  ,m_reset_camera(0)
  ,m_scene_light(0)

  ,m_camenu_shift_button(m_ttf)
  ,m_camenu_sshoot_text_button(m_ttf)
  ,m_camenu_90_text_button(m_ttf)
  ,m_camenu_focal_button(m_ttf)
  ,m_camenu_viewing_button(m_ttf)
  ,m_camenu_gsto_button(m_ttf)
  ,m_camenu_plane_exam_button(m_ttf)
  ,m_console(m_ttf)

  ,m_popup_cbks(a_from.m_popup_cbks)

  ,m_meta_had_been_shown(false)

  ,m_touch_in_motion(false)
  ,m_touch_prev_x(0)
  ,m_touch_prev_y(0)

  ,m_gesture_begin_x(0)
  ,m_gesture_begin_y(0)
  ,m_gesture_begin_camera(0)

  ,m_motion_slider(0)

  ,m_treat_mouse_motion(false)

  ,m_cursor_camera(0)

  ,m_memory_warning(false)

  ,m_zip_func(a_from.m_zip_func)
  ,m_unzip_func(a_from.m_unzip_func)
  ,m_action_prots(a_from.m_action_prots)

  //,m_jpeg_data(a_from.m_out)
  ,m_dumpers()
  ,m_opener(a_from.m_opener)
  {
    delete m_reset_camera;
    m_reset_camera = a_from.m_reset_camera?a_from.m_reset_camera->copy():0;

    copy_dumpers(m_dumpers,a_from.m_dumpers);
  }

  gui_viewer& operator=(const gui_viewer& a_from){
    parent::operator=(a_from);

    if(&a_from==this) return *this;
    
    gui_visible = a_from.gui_visible;
    cursor_visible = a_from.cursor_visible;
    cursor_line_width = a_from.cursor_line_width;
    cursor_model = a_from.cursor_model;
    params_button_visible = a_from.params_button_visible;
    camera_button_visible = a_from.camera_button_visible;

    camenu_edit_visible = a_from.camenu_edit_visible;
    camenu_90_visible = a_from.camenu_90_visible;
    camenu_focal_visible = a_from.camenu_focal_visible;
    camenu_viewing_visible = a_from.camenu_viewing_visible;

    m_scene_camera = 0;    

    delete m_reset_camera;
    m_reset_camera = a_from.m_reset_camera?a_from.m_reset_camera->copy():0;
    m_scene_light = 0;

    m_popup_cbks = a_from.m_popup_cbks;

    m_meta_had_been_shown = false;

    m_touch_in_motion = false;
    m_touch_prev_x = 0;
    m_touch_prev_y = 0;

    m_gesture_begin_x = 0;
    m_gesture_begin_y = 0;
    m_gesture_begin_camera = 0;

    m_motion_slider = 0;

    m_treat_mouse_motion = false;

    m_cursor_camera = 0;

    m_memory_warning = false;

    m_zip_func = a_from.m_zip_func;
    m_unzip_func = a_from.m_unzip_func;
    m_action_prots = a_from.m_action_prots;

    copy_dumpers(m_dumpers,a_from.m_dumpers);

    return *this;
  }
public:
  const base_freetype& ttf() const {return m_ttf;}
public:   

  ///////////////////////////////////////////////////
  /// wall : for communication with data_client : ///
  ///////////////////////////////////////////////////

  typedef std::map<unsigned int,std::string> action_prots_t;
  const action_prots_t& action_prots() const {return m_action_prots;}
  //action_prots_t& action_prots() {return m_action_prots;}

  bool find_prot_action(const std::string& a_prot,unsigned int& a_action) {
    // used in wall/screen_dispatch :
    std::map<unsigned int,std::string>::const_iterator it;
    for(it=m_action_prots.begin();it!=m_action_prots.end();++it){
      if((*it).second==a_prot) {
        a_action = (*it).first;
        return true;
      }
    }
    a_action = 0;
    return false;
  }

  void set_wall_action_prots() {
    //used by wall_screen and wall data client programs.

    // See wall/screen_dispatch/EVT_USER_COMMAND.
    //IMPORTANT : action id must be the gui_viewer::gui_cbk ones.

    m_action_prots[gui_cbk::action_single_shoot()] =
      wall::protocol::s_rwc_single_shoot();
    m_action_prots[gui_cbk::action_90()] =
      wall::protocol::s_rwc_90();
    m_action_prots[gui_cbk::action_anim_shift()] =
      wall::protocol::s_rwc_anim_shift();
    m_action_prots[gui_cbk::action_anim_around_focal()] =
      wall::protocol::s_rwc_anim_around_focal();
    m_action_prots[gui_cbk::action_viewing()] =
      wall::protocol::s_rwc_viewing();

    m_action_prots[gui_cbk::action_reset_camera()] =
      wall::protocol::s_rwc_reset_camera();

    m_action_prots[gui_cbk::action_left()] =
      wall::protocol::s_rwc_left();
    m_action_prots[gui_cbk::action_right()] =
      wall::protocol::s_rwc_right();
    m_action_prots[gui_cbk::action_up()] =
      wall::protocol::s_rwc_up();
    m_action_prots[gui_cbk::action_down()] =
      wall::protocol::s_rwc_down();

    m_action_prots[gui_cbk::action_clear_scene()] =
      wall::protocol::s_rwc_clear_scene();

    m_action_prots[gui_cbk::action_cam_anim_zoom_in_out()] =
      wall::protocol::s_rwc_cam_anim_zoom_in_out();
    m_action_prots[gui_cbk::action_cam_anim_zoom_in_out_rot()] =
      wall::protocol::s_rwc_cam_anim_zoom_in_out_rot();
  }
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////

  virtual void set_event_anim(event_timer* a_timer) { //get ownership. //virtual for WebGL
    add_in_tmp_group<event_timer>(s_event_timer(),a_timer);  
    add_work(new inlib::cbk::timer(*this,*a_timer));
  }

  void stop_event_anim() { // Used in exlib/[pmx,agora,cbk/lhc1].
    inlib::cbk::timer::invalidate_timer_works(*this,event_timer::s_class());
    remove_in_tmp_group<base_timer>(s_event_timer());
  }

  ///////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////

  const selection& sg_ui() const {return m_gui;}
  selection& sg_ui() {return m_gui;}

  void arm_button(base_button* a_node) {
    add_work(new arm_work(*this,a_node));
    m_arm_buttons.push_back(a_node);
  }
  void trigger_button(base_button* a_node) {
    add_work(new disarm_work(*this,a_node));
    add_work_cbks(a_node->cbks().callbacks(),true);    
  }

  selection& scene() {return m_scene;}
  const selection& scene() const {return m_scene;}

  bool scene_center(vec3f& a_center) {
    bbox_action action(m_out);
    m_scene.bbox(action);
    if(!action.end()) {
      m_out << "inlib::sg::gui_viewer::scene_center :"
            << " bad bbox_action end."
            << std::endl;
      a_center.set_value(0,0,0);
      return false;
    }
    return action.box().center(a_center);
  }

  ////////////////////////////////////////////
  /// special scene nodes ////////////////////
  ////////////////////////////////////////////
  torche* scene_light() const {return m_scene_light;}
  void set_scene_light(torche* a_light) {
    //we don't get ownership of a_light.
    m_scene_light = a_light;
    if(m_scene_light) m_scene_light->on = m_params.m_light_on;
  }

  bool set_scene_light_on(bool a_value) {
    if(!m_scene_light) return false;
    m_scene_light->on = a_value;
    m_params.m_light_on = a_value; //keep in sync.
    return true;
  }

  void set_use_gsto(bool a_value) {
    m_use_gsto = a_value;
    m_params.m_use_gsto = a_value; //keep in sync m_params.

   {typedef sg::gsto_mode mode_t;
    mode_t mode;
    if(!s2gsto_mode(m_params.m_gsto_mode,mode)){
      m_out << "inlib::sg::gui_viewer::set_use_gsto :"
            << " unknown gsto mode " << m_params.m_gsto_mode << "."
            << std::endl;
    }
    m_gl_mgr.set_gsto_mode(mode);
    if(m_gl_mgr.get_gsto_mode()!=mode) {
      m_out << "inlib::sg::gui_viewer::set_use_gsto :"
            << " gsto mode " << m_params.m_gsto_mode
            << " not accepted by the gl manager."
            << std::endl;
    }}

    // the gl manager may refuse the given value :    
    gsto_mode2s(m_gl_mgr.get_gsto_mode(),m_params.m_gsto_mode);

    if(m_params.m_use_gsto) {
      m_camenu_gsto_button.back_area::color = colorf::pink();
      //m_params.m_gui_button_active_color;
    } else {
      m_camenu_gsto_button.back_area::color = m_params.m_gui_back_color;
    }

  }

  ////////////////////////////////////////////
  /// camera /////////////////////////////////
  ////////////////////////////////////////////
  base_camera* scene_camera() const {return m_scene_camera;}

  void set_scene_camera(base_camera* a_camera,bool a_set_reset_cam = true) {
    //we don't get ownership of a_camera.
    m_scene_camera = a_camera;
    _set_params_camera();    

    if(a_set_reset_cam){
      delete m_reset_camera;
      m_reset_camera = a_camera?a_camera->copy():0;
    }
  }

  float scene_camera_radius() {
    if(!m_scene_camera) return 10000; //10*m A01

    ortho* oc = safe_cast<node,ortho>(*m_scene_camera);
    if(oc) return oc->height;

    perspective* pc = safe_cast<node,perspective>(*m_scene_camera);
    if(pc) {
      //reverse of exlib/opener/exsg_create_camera.
      float pos = pc->position.value().length();
      return pos * ftan(pc->height_angle.value()*0.5f);
    }     

    return 10000; //10*m A01
  }     

  void start_anim_around_focal() { //for exlib/cbk/anim
    if(!m_params.m_anim_around_focal) {
      bcbk* cbk = new gui_cbk(*this,gui_cbk::action_anim_around_focal());
      cbk->action();
      delete cbk;
    }
    bcbk* cbk = new gui_cbk(*this,gui_cbk::action_right());
    cbk->action();
    delete cbk;
  }

  void update_anim_motion(anim_what a_anim,bool a_shift) {
    int move;
    if(!anim2motion(a_anim,a_shift,move)) return;
    update_motion(move);
    hide_meta_zone();
  }
private:
  void update_motion(int a_what) {
    if(!m_scene_camera) return;

    float dx = m_scene_camera->dx;
    float da = m_scene_camera->da;
    float ds = m_scene_camera->ds;

    if(a_what==move_rotate_right) {
      m_scene_camera->rotate_around_up(-da);
    } else if(a_what==move_rotate_left) {
      m_scene_camera->rotate_around_up(da);

    } else if(a_what==move_translate_right) {
      m_scene_camera->translate_along_side(dx);
    } else if(a_what==move_translate_left) {
      m_scene_camera->translate_along_side(-dx);

    } else if(a_what==move_up) {
      m_scene_camera->translate_along_up(dx);
    } else if(a_what==move_down) {
      m_scene_camera->translate_along_up(-dx);

    } else if(a_what==move_forward) {
      m_scene_camera->translate_along_dir(dx);
    } else if(a_what==move_backward) {
      m_scene_camera->translate_along_dir(-dx);

    } else if(a_what==move_zoom_in) {
      m_scene_camera->zoom(ds);
    } else if(a_what==move_zoom_out) {
      m_scene_camera->zoom(1.0f/ds);

    } else if(a_what==move_rotate_around_focal_right) {
      m_scene_camera->rotate_around_y_at_focal(-da);

    } else if(a_what==move_rotate_around_focal_left) {
      m_scene_camera->rotate_around_y_at_focal(da);

    }

  }
public:
  ////////////////////////////////////////////
  /// scene operations ///////////////////////
  ////////////////////////////////////////////
/*
  void delete_manips() {
    typedef search_action::path_t path_t;
    typedef search_action::paths_t paths_t;
    typedef cube_manip cm_t;

    search_action sa(m_out);
    const paths_t& paths = find_paths<cm_t>(sa,m_scene);

    paths_t::const_iterator it;
    for(it=paths.begin();it!=paths.end();++it) {
      const path_t& p = *it;
      group* grp = container<group>(p);
      if(!grp) {
        m_out << "gui_viewer::delete_manips :"
                      << " cube_manip parent group not found."
                      << std::endl;       
      } else {
        cm_t* cm = tail<cm_t>(p);
        if(!cm) {
          m_out << "inlib::sg::gui_viewer::delete_manips :"
                        << " cube_manip path with bad tail."
                        << std::endl;       
        } else {
          node* parent;
          node* node;
          cm->get_node(parent,node);
          if(!parent||!node) {
            m_out << "inlib::sg::gui_viewer::delete_manips :"
                          << " cube_manip without a maniped node."
                          << std::endl;       
          }
          
          matrix* m = new matrix;
          m->mtx = cm->mtx;
          grp->replace(cm,m,true); // it deletes cm.
           
          if(parent && node) {
            group* pgrp = safe_cast<node,group>(*parent);
            if(pgrp && pgrp->remove(node)) {
              delete node;          
            } else {
              m_out << "inlib::sg::gui_viewer::delete_manips :"
                            << " maniped node not in the expected parent."
                            << std::endl;       
            }
          }
        }
      }
    }    
    
  }
*/

  void remove_manips() {
    // but do not delete the working node.

    typedef cube_manip cm_t;

    search_action sa(m_out);
    const paths_t& paths = find_paths<cm_t>(sa,m_scene);

    paths_t::const_iterator it;
    for(it=paths.begin();it!=paths.end();++it) {
      const path_t& p = *it;
      group* grp = container<group>(p);
      if(!grp) {
        m_out << "inlib::sg::gui_viewer::reset_manips :"
                      << " cube_manip parent group not found."
                      << std::endl;       
      } else {
        cm_t* cm = tail<cm_t>(p);
        if(!cm) {
          m_out << "inlib::sg::gui_viewer::reset_manips :"
                        << " cube_manip path with bad tail."
                        << std::endl;       
        } else {
          matrix* m = new matrix;
          m->mtx = cm->m_start_matrix;
          grp->replace(cm,m,true); // it deletes cm.
        }
      }
    }    
  }

  void count_points() {
    count_action ca(m_out);
    m_scene.bbox(ca);
    //show_console(ca.number_of_points());

    std::string s;
    s += "pts ";
    s += to(ca.number_of_points());
    s += ",gsto ";
    s += to(m_gl_mgr.gstos_size());
    s += ",tex ";
    s += to(m_gl_mgr.used_texture_memory());
    //m_out << s << std::endl;
    show_console(s);

    m_params.m_console_width = 0.6F;
    set_console_layout();
  }

  std::string anim_shift_button_label() const {
    //logic must be in sync with the below update_anim_motion. 
    if(m_params.m_camera_type.empty()) return "nil";

    if(m_params.m_plane_viewer) {
      if(m_params.m_anim_shift) {
        return "P/Z"; //P=Pane, Z=Zoom
      } else {
        return "P";
      }
    } else { //exam viewer.
      if(m_params.m_anim_shift) {
        return "P";
      } else {
        if(m_params.m_camera_type==s_camera_ortho()){
          return "R/Z"; //R=Rotate.
        } else {
          return "R/T"; //T=Translate (in z)
        }
      }
    }
  }

  ////////////////////////////////////////////
  /// gui style //////////////////////////////
  ////////////////////////////////////////////
protected:
  INLIB_CLASS_STRING(gui)

public:
  void list_add(list& a_list,
                const std::string& a_label,
                const std::string& a_img_file,
                bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_file(m_out,m_res_dir,a_img_file,img)) {
        a_list.add(a_label,img,a_cbk);
      } else {
        a_list.add(a_label,a_cbk);
      }
    } else {
      a_list.add(a_label,a_cbk);
    }
  }

  void list_white_add(list& a_list,
                      const std::string& a_label,
                      bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_file(m_out,m_res_dir,s_white_jpg(),img)) {
        a_list.add(a_label,img,a_cbk);
      } else {
        a_list.add(a_label,a_cbk);
      }
    } else {
      a_list.add(a_label,a_cbk);
    }
  }

  void list_add_before(list& a_list,
                       const std::string& a_what,
                       const std::string& a_label,
                       const std::string& a_img_file,
                       bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_file(m_out,m_res_dir,a_img_file,img)) {
        a_list.add_before(a_what,a_label,img,a_cbk);
      } else {
        a_list.add_before(a_what,a_label,a_cbk);
      }
    } else {
      a_list.add_before(a_what,a_label,a_cbk);
    }
  }

  void list_add_after(list& a_list,
                      const std::string& a_what,
                      const std::string& a_label,
                      const std::string& a_img_file,
                      bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_file(m_out,m_res_dir,a_img_file,img)) {
        a_list.add_after(a_what,a_label,img,a_cbk);
      } else {
        a_list.add_after(a_what,a_label,a_cbk);
      }
    } else {
      a_list.add_after(a_what,a_label,a_cbk);
    }
  }

  bool anim2motion(anim_what a_anim,bool a_shift,int& a_move) {
    if(a_anim==anim_left) {
      if(m_params.m_plane_viewer) {
        a_move = move_translate_left;
        return true;
      } else { //exam viewer.
        if(a_shift) {
          a_move = move_translate_left;
          return true;
        } else {
          if(m_params.m_anim_around_focal) {
            a_move = move_rotate_around_focal_left;
            return true;
          } else {
            a_move = move_rotate_left;
            return true;
          }
        }
      }

    } else if(a_anim==anim_right) {
      if(m_params.m_plane_viewer) {
        a_move = move_translate_right;
        return true;
      } else { //exam viewer.
        if(a_shift) {
          a_move = move_translate_right;
          return true;
        } else {
          if(m_params.m_anim_around_focal) {
            a_move = move_rotate_around_focal_right;
            return true;
          } else {
            a_move = move_rotate_right;
            return true;
          }
        }
      }

    } if(a_anim==anim_up) {
      if(m_params.m_plane_viewer) {
        if(a_shift) {
          a_move = move_zoom_in;
          return true;
        } else {
          a_move = move_up;
          return true;
        }
      } else { //exam viewer.
        if(a_shift) {
          a_move = move_up;
          return true;
        } else {
          if(m_params.m_camera_type==s_camera_ortho()){
            a_move = move_zoom_in;
            return true;
          } else {
            a_move = move_forward;
            return true;
          }
        }
      }

    } if(a_anim==anim_down) {
      if(m_params.m_plane_viewer) {
        if(a_shift) {
          a_move = move_zoom_out;
          return true;
        } else {
          a_move = move_down;
          return true;
        }
      } else { //exam viewer.
        if(a_shift) {
          a_move = move_down;
          return true;
        } else {
          if(m_params.m_camera_type==s_camera_ortho()){
            a_move = move_zoom_out;
            return true;
          } else {
            a_move = move_backward;
            return true;
          }
        }
      }
    }
    a_move = 0;
    return false;
  }

  ////////////////////////////////////////////
  ////////////////////////////////////////////
  ////////////////////////////////////////////

  void set_slider_style(slider& a_node) const {
    a_node.back_area::color = m_params.m_gui_back_color;
    a_node.back_area::border_color = m_params.m_gui_border_color;
    //a_node.color = m_params.m_gui_front_color;
    //a_node.arm_color = m_params.m_gui_arm_color;
    a_node.color = m_params.m_gui_arm_color;
  }

  void set_colors(text& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
  }
  void set_colors(scroll_text& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }
  void set_colors(scroll_infos& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }

  void set_colors(list& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.dir_color = m_params.m_gui_dir_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }
  typedef button_grid<simple_button> sbg_t;
  void set_colors(button_grid<simple_button>& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }
  void set_colors(entries& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.labels_back_color = m_params.m_gui_label_back_color;
  }
  void set_colors(entry& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }
  void set_colors(numeric& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }
  void set_colors(keyboard& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }
  void set_colors(edvalop& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }
  void set_colors(colors& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }

  void set_text_layout(text& a_node,
                       float a_wcw,float a_wch,float a_hbutton,
                       matrix& a_mtx) const {
    a_node.width = a_wcw*0.7F;

    float havailable = a_wch-2*a_hbutton;

   {unsigned int linen = a_node.strings.size();
    float h = linen*a_hbutton*0.8F;
    if(h>=havailable) h = havailable*0.95f;
    a_node.height = h;}

    float y = a_wch*0.5f-havailable*0.5f;
    a_mtx.set_translate(0,y,0);

    a_node.corner_radius = m_params.m_corner_radius;
  //a_node.confine = true;
  }

  void set_back_area_layout(back_area& a_node,
                       float a_wcw,float a_wch,float a_hbutton,
                       matrix& a_mtx) const {
    a_node.width = a_wcw*0.5F;

    float havailable = a_wch-2*a_hbutton;

   {float h = a_wch*0.5f;
    if(h>=havailable) h = havailable*0.95f;
    a_node.height = h;}

    float y = a_wch*0.5f-havailable*0.5f;
    a_mtx.set_translate(0,y,0);

    a_node.corner_radius = m_params.m_corner_radius;
  }

  void set_scroll_text_layout(scroll_text& a_node,
                       float a_wcw,float a_wch,float a_hbutton,
                       matrix& a_mtx) const {
  //float wscroll = a_wcw*0.08f;
    float wscroll = a_hbutton;

    // fix margin and get wtext :
    float wmargin = a_wcw*0.01f;
    //We should have : 2*wmargin+wtext+wscroll*1.2 = wcw;
    float wtext = a_wcw-wscroll*1.2f-2.0f*wmargin;

    float hmargin = a_wch*0.01f;
    float hscroll = a_wch-2*a_hbutton-2*hmargin;

    float x = -(a_wcw-wtext)*0.5f+wmargin; //at left+margin.
    float y = a_wch*0.5f-hmargin-hscroll*0.5f;
    a_mtx.set_translate(x,y,0);

    a_node.width = wtext;
    a_node.height = hscroll;
    a_node.scroll_width = wscroll;
    a_node.visible_items = 20;
    a_node.confine = true;
    a_node.wmargin_factor = 0.98f;
    a_node.hmargin_factor = 0.98f;
  }

  void set_base_list_layout(base_list& a_node,
                            float a_wcw,float a_wch,float a_hbutton,
                            matrix& a_mtx) const {
    a_node.visible_items = m_params.m_list_visible_items;
    a_node.text_common_height = true;

    a_node.width = a_wcw*0.7F; //round style needs space.
    a_node.scroll_width = a_hbutton;

    float hmargin = 0.05f*a_hbutton;
    float havailable = a_wch-2*a_hbutton-2*hmargin;

    unsigned int nitem = a_node.visible_items;
    float hwanted = nitem*a_hbutton;
    float hlist = mn<float>(hwanted,havailable);

    a_node.height = hlist;
        
    float y = a_wch*0.5f-havailable*0.5f-hmargin;
    // x center relative to central list (not taking into account right arrows)
    float x = a_node.width*0.5f-a_node.witem()*0.5f;

    a_mtx.set_translate(x,y,0);
  }

  //virtual for ArcheryTune.
  virtual void set_list_layout(list& a_node,
                               float a_wcw,float a_wch,float a_hbutton,
                               matrix& a_mtx) const {
    set_base_list_layout(a_node,a_wcw,a_wch,a_hbutton,a_mtx);
    a_node.text_hmargin_factor = 0.5f; //Apple
    s2layout_policy(m_params.m_list_item_layout,a_node.item_layout.value());
    a_node.corner_radius = m_params.m_corner_radius;
  }

  void set_scroll_infos_layout(scroll_infos& a_node,
                               float a_wcw,float a_wch,float a_hbutton,
                               matrix& a_mtx) const {

  //float wscroll = a_wcw*0.08f;
    float wscroll = a_hbutton;

  //float wtext = wcw*0.8f;
  //float wsctxt = wtext+wscroll*0.2f+wscroll; //scroll_text::update_sg
  //float wmargin = (wcw-wsctxt)*0.2f;

    // fix margin and get wtext :
    float wmargin = a_wcw*0.01f;
    //We should have : 2*wmargin+wtext+wscroll*1.2 = wcw;
    float wtext = a_wcw-wscroll*1.2f-2.0f*wmargin;

    float hmargin = a_wch*0.01f;
    float hscroll = a_wch-2*a_hbutton-2*hmargin;

    float x = -(a_wcw-wtext)*0.5f+wmargin; //at left+margin.
    float y = a_wch*0.5f-hmargin-hscroll*0.5f;
    a_mtx.set_translate(x,y,0);

    a_node.width = wtext;
    a_node.height = hscroll;
    a_node.scroll_width = wscroll;
    a_node.visible_items = 20;
    a_node.confine = true;
    a_node.wmargin_factor = 0.98f;
    a_node.hmargin_factor = 0.98f;

  }

  void set_edvalop_layout(edvalop& a_node,
                          float a_wcw,float a_wch,float a_hbutton,
                          matrix&) const {
    a_node.width = a_wcw*0.7F;
    a_node.height = a_wch*0.5F;

    a_node.text_hmargin_factor = 0.5f; //Apple
    a_node.numeric_width = a_wcw*0.7f;
    a_node.numeric_height = a_wch*0.5f;
    a_node.list_width = a_wcw*0.5f;
    a_node.list_height = a_wch*0.5f;
  //a_node.list_scroll_width = a_wch*0.5f*0.2f;
    a_node.list_scroll_width = a_hbutton;
  }

  //virtual for ArcheryTune.
  virtual void set_entries_layout(entries& a_node,
                                  float a_wcw,float a_wch,float a_hbutton,
                                  matrix& a_mtx) const {
    set_base_list_layout(a_node,a_wcw,a_wch,a_hbutton,a_mtx);

    a_node.text_hmargin_factor = 0.5f; //Apple
    a_node.corner_radius = m_params.m_corner_radius;

    a_node.numeric_width = a_wcw*0.7F;
    a_node.numeric_height = a_wch*0.5f;
    a_node.keyboard_width = a_wcw*0.98F;
    a_node.keyboard_height = a_wch*0.5f;
    a_node.colors_width = a_wcw*0.8F;
    a_node.colors_height = a_wch*0.5f;
    a_node.edvalop_width = a_wcw*0.8F;
    a_node.edvalop_height = a_wch*0.5f;
    a_node.file_chooser_width = a_wcw*0.8F;
    a_node.file_chooser_height = a_wch*0.5f;
    a_node.list_width = a_wcw*0.5F;
    a_node.list_height = a_wch*0.5F;
  //a_node.list_scroll_width = a_wcw*0.5F*0.2F;
    a_node.list_scroll_width = a_hbutton;

    // entries need more space than a list :
    a_node.width = a_wcw*0.9f;
    a_node.buttons_to_arrows_factor = 0.1f;
  //a_node.entry_label_result_factor = 0.7f;

    // x center relative to the whole widget (taking into account right arrows)
    a_mtx.set_translate(0,a_mtx.mtx.value().v13(),a_mtx.mtx.value().v23());

  }  

  bool ui_visible() {
    return (m_main_menu_switch.which.value()==SHOWN()?true:false);
  }
  bool camenu_visible() {
    return (m_camenu_switch.which.value()==SHOWN()?true:false);
  }
  bool sliders_visible() {
    return (m_sliders_switch.which.value()==SHOWN()?true:false);
  }
  bool popup_visible() {
    return (m_popup_switch.which.value()==SHOWN()?true:false);
  }

  // two method to hide scene when in rwc.
  void save_scene()    {
    m_backup_scene.transfer(m_scene);

    m_backup_scene.up_cbks().copy(m_scene.up_cbks());
    m_backup_scene.down_cbks().copy(m_scene.down_cbks());
    m_backup_scene.move_cbks().copy(m_scene.move_cbks());
    m_scene.clear_cbks();
  } 
  void restore_scene() {
    m_scene.transfer(m_backup_scene);

    m_scene.up_cbks().copy(m_backup_scene.up_cbks());
    m_scene.down_cbks().copy(m_backup_scene.down_cbks());
    m_scene.move_cbks().copy(m_backup_scene.move_cbks());
    m_backup_scene.clear_cbks();
  }

  void set_scene_clear_color(const colorf& a_color) {
    m_params.m_scene_screen_color = a_color;
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      m_clear_color = m_params.m_scene_screen_color;
    }
  }

  void set_scene_clear_color(float a_r,float a_g,float a_b,float a_a = 1) {
    set_scene_clear_color(colorf(a_r,a_g,a_b,a_a));
  }  
 
  //virtual
  void show_main_menu() {
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      m_main_menu_switch.which = SHOWN();
      m_clear_color = m_params.m_gui_screen_color;
      m_meta_switch.which = HIDDEN();
      if(m_params.m_auto_hide_scene) m_scene_switch.which = HIDDEN();
      m_gui_sliders_switch.which = HIDDEN(); //do not traverse scene sliders
      hide_popup();
    }
  }

  bool main_menu_shown() {
    return m_main_menu_switch.which.value()==SHOWN()?true:false;
  }

  bool scene_shown() {
    return m_scene_switch.which.value()==SHOWN()?true:false;
  }

  void hide_main_menu() {
    if(m_main_menu_switch.which.value()==SHOWN()) {
      m_main_menu_switch.which = HIDDEN();
      m_clear_color = m_params.m_scene_screen_color;
      if(m_params.m_auto_hide_scene) m_scene_switch.which = SHOWN();
      m_gui_sliders_switch.which = SHOWN(); //traverse scene sliders
    }
    if(!m_meta_had_been_shown) {
      m_meta_switch.which = SHOWN();
      m_meta_had_been_shown = true;
    }
  }
 
  void hide_meta_zone() {m_meta_switch.which = HIDDEN();}
  void meta_zone_had_been_shown() {
    m_meta_had_been_shown = true;
  }

  void hide_camera_menu() {m_camenu_switch.which = HIDDEN();}

  void set_camera_menu_labels() {
    m_camenu_shift_button.set_arconf(anim_shift_button_label());
    m_camenu_viewing_button.set_arconf(viewing_button_label());

    set_img_from_file(m_out,m_res_dir,single_shoot_image_button_file(),m_camenu_sshoot_image_button.img.value());
    m_camenu_sshoot_image_button.img.touch();
    m_camenu_sshoot_text_button.set_arconf(single_shoot_button_label());

    set_img_from_file(m_out,m_res_dir,rot_90_image_button_file(),m_camenu_90_image_button.img.value());
    m_camenu_90_image_button.img.touch();
    m_camenu_90_text_button.set_arconf(rot_90_button_label());

    m_camenu_focal_button.set_arconf(around_focal_button_label());
    m_camenu_plane_exam_button.set_arconf(plane_exam_button_label());
    set_use_gsto(m_use_gsto);
  }

  void show_camera_menu() {
    hide_main_menu();
    m_camenu_switch.which = SHOWN();
    set_camera_menu_labels();
  }

  void activate_meta_zone() {
    // some menu exists (mapped or not).
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      // ask to map menu.
      show_main_menu();
      hide_camera_menu();
    } else { // some menu mapped.
      if(m_scene_camera) hide_main_menu();
    }
  }

  void hide_gui() { //used by rwc.
    hide_main_menu();
    hide_camera_menu();
    hide_meta_zone();
  }

  void show_progress() {m_progress_switch.which = SHOWN();}
  void hide_progress() {m_progress_switch.which = HIDDEN();}
  sg::progress& progress() {return m_progress;}

  void hide_sliders() {m_sliders_switch.which = HIDDEN();}
  void show_sliders() {m_sliders_switch.which = SHOWN();}
/*
  void toggle_sliders() {
    m_sliders_switch.which = m_sliders_switch.which==HIDDEN()?SHOWN():HIDDEN();
  }
*/

  slider& slider_1() {return m_slider_1;}
  slider& slider_2() {return m_slider_2;}
  slider& slider_3() {return m_slider_3;}
  slider& slider_4() {return m_slider_4;}

  void show_console() {m_console_switch.which = SHOWN();}
  void hide_console() {m_console_switch.which = HIDDEN();}
  //text_button& console() {return m_console;}

  void set_console_size(float a_width = 0.3F,float a_height = 0.05F,float a_scale = 1) {
    if(a_width!=m_params.m_console_width) {
      m_params.m_console_width = a_width;
      if(m_params.m_console_width<=0) m_params.m_console_width = 0.3F;
      set_console_layout();
    }
    if(a_height!=m_params.m_console_height) {
      m_params.m_console_height = a_height;
      if(m_params.m_console_height<=0) m_params.m_console_height = 0.05F;
      set_console_layout();
    }
    if(a_scale!=m_params.m_console_scale) {
      m_params.m_console_scale = a_scale;
      if(m_params.m_console_scale<=0) m_params.m_console_scale = 1;
      set_console_layout();
    }
  }

  void show_popup() {m_popup_switch.which = SHOWN();}
  void hide_popup() {m_popup_switch.which = HIDDEN();}
  separator& popup_sep() {return m_popup_sep;}
  //matrix& popup_matrix() {return m_popup_matrix;}
  sg::cbks& popup_cbks() {return m_popup_cbks;}
  const sg::cbks& popup_cbks() const {return m_popup_cbks;}

  void place_show_popup(int a_event_x,int a_event_y,float a_w,float a_h) {
    //a_w,a_h is the size of the popuped item.

    float one_wcw,one_wch; //wall : for one screen.

    float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);

    float all_wcw,all_wch; //wall : for all screens.
    get_gui_all_wcw_wch(all_wcw,all_wch);

    float x,y;
    screen_to_gui(a_event_x,a_event_y,x,y);

    // popup at top-left corner on x,y by taking
    // into account window limits.

    float xright = mn<float>(x+a_w,all_wcw*0.5f);
    //float xright = x+list.width;
    float ybot   = mx<float>(y-a_h,-all_wch*0.5f);

    float xpop = xright-a_w*0.5f;
    float ypop = ybot+a_h*0.5f;

    //compensate also the m_gui trans.
    m_popup_matrix.set_translate(xpop-tx,ypop-ty,0);

    show_popup();
  }


  void map_warn(const std::string& a_msg,bool a_warn = true) {
    show_main_menu();
    list* _list = new list(m_ttf);
    set_colors(*_list);
    if(a_warn) _list->back_color = m_params.m_gui_warn_back_color;
    else       _list->back_color = m_params.m_gui_warn_ok_color;
    _list->front_color = m_params.m_gui_warn_front_color;
    _list->border_color = m_params.m_gui_warn_border_color;
    _list->add(a_msg,new gui_cbk(*this,gui_cbk::action_last()));
    m_uitems.push_back(_list);
    ask_to_rebuild_gui();
  }

  void do_escape() {activate_meta_zone();} 

  bool touch_down(int a_x,int a_y) {
    //a_x,a_y are signed because of wall. (0,0) is bottom left of window.

    if(!m_ww || !m_wh) return false;

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_down :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;       
    }

    down_event e(a_x,a_y);

    int old_scene_switch_which = m_scene_switch.which;
    int old_cursor_switch_which = m_cursor_switch.which;

    if(m_params.m_viewing) m_scene_switch.which = HIDDEN();
    m_cursor_switch.which = HIDDEN();

    event_action action(m_out,m_ww,m_wh,e);
    m_sg.swap(0,1); //have m_gui traversed before m_scene_switch.
    m_sg.event(action);
    m_sg.swap(0,1); 

    m_scene_switch.which = old_scene_switch_which;
    m_cursor_switch.which = old_cursor_switch_which;

    return action.done();
  }

  bool touch_up(int a_x,int a_y) {
    //a_x,a_y are signed because of wall. (0,0) is bottom left of window.

    if(m_touch_in_motion) {
      m_touch_in_motion = false;

      if(m_motion_slider) {
        // We may have missed a touch up on the slider thumb.
        // We have to execute the ends callbacks anyway.
        add_work_cbks(m_motion_slider->ends(),true);    
        m_motion_slider = 0;
        return false;
      }
    }

    if(!m_ww || !m_wh) return false;

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_up :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;       
    }

    up_event e(a_x,a_y);

    int old_scene_switch_which = m_scene_switch.which;
    int old_cursor_switch_which = m_cursor_switch.which;

    if(m_params.m_viewing) m_scene_switch.which = HIDDEN(); //do not traverse scene.
    // But in viewing mode we would traverse m_scene before m_gui,
    // we have to swap m_scene_switch and m_gui.
    m_cursor_switch.which = HIDDEN(); //do not traverse cursor.

    event_action action(m_out,m_ww,m_wh,e);
    m_sg.swap(0,1);
    m_sg.event(action);
    m_sg.swap(0,1);

    m_scene_switch.which = old_scene_switch_which;
    m_cursor_switch.which = old_cursor_switch_which;

    return action.done();
  }

  bool touch_move(int a_x,int a_y) { //could be negative in case of wall.
    if(!m_touch_in_motion) {
      m_touch_prev_x = a_x;
      m_touch_prev_y = a_y;
      m_touch_in_motion = true;
    }

    if(!m_ww||!m_wh) {
      m_touch_prev_x = a_x;
      m_touch_prev_y = a_y;
      return false;
    }

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_move :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;       
    }

    bool to_render = false;

    if(ui_visible()) {

      // for sliders in the gui.
      move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
      event_action action(m_out,m_ww,m_wh,e);
      m_gui.event(action);
      to_render = false; //Android : "true" may induce double redraw.

    } else { //scene or sliders visible
    
      bool gui_hit = false; //for ArcheryTune mv animal whilst having sliders.

      if(sliders_visible()) {

        move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
        event_action action(m_out,m_ww,m_wh,e);
        m_gui.event(action); //on m_sg ?
        hide_meta_zone(); //should have to_render = true ?
        to_render = false; //Android : "true" may induce double redraw.
        if(action.done()) {
          //to_render = true;
          gui_hit = true;
        }

      }

      if(!gui_hit) {
      if(m_params.m_viewing) {

        if(m_scene_camera && m_params.m_touch_move) {
          if(!m_params.m_plane_viewer && m_params.m_anim_around_focal) {

            float n2f = m_scene_camera->focal-m_scene_camera->znear;
            if(n2f) {
              float wnh = m_scene_camera->near_height();
              float aspect = float(m_ww)/float(m_wh);
              float wnw = wnh*aspect;

              // x in wc in near plane :
              float wpx = wnw*float(m_touch_prev_x)/float(m_ww);
              float wx  = wnw*float(a_x)/float(m_ww);

              float apx = ::atan(wpx/n2f);
              float ax  = ::atan(wx/n2f);

              float da = ax-apx;

              if(m_scene_camera->type()==camera_perspective){
                da *= 10.0f; //cooking
              }

              m_scene_camera->rotate_around_y_at_focal(-da);

              hide_meta_zone();
              to_render = true;
            }
          } else {
            float wch;
            if(m_scene_camera->height_at_focal(wch)){
            //float wch = m_scene_camera->near_height();{

              float aspect = float(m_ww)/float(m_wh);
              float wcw = wch*aspect;

              int dx = a_x-m_touch_prev_x;
              int dy = a_y-m_touch_prev_y;

              float wc_trans_x = wcw*float(dx)/float(m_ww);
              float wc_trans_y = wch*float(dy)/float(m_wh);
              m_scene_camera->translate_along_side(-wc_trans_x);
              m_scene_camera->translate_along_up(-wc_trans_y);

              hide_meta_zone();
              to_render = true;
            }
          }
        }

      } else { //viewer is in picking mode.

        move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
        event_action action(m_out,m_ww,m_wh,e);
        m_scene_switch.event(action);
        if(action.done()) {
          //someone did something with this event (an image ?)
          to_render = true; //ioda::main::move_image_cbk uses console.
        }

      }}
    }

    m_touch_prev_x = a_x;
    m_touch_prev_y = a_y;

    return to_render;
  }

  void treat_mouse_motion(bool a_value) {m_treat_mouse_motion = a_value;}

  bool mouse_motion(unsigned int a_x,unsigned int a_y) {
    bool to_render = false;

    if(m_ww && m_wh && m_treat_mouse_motion) {

      move_event e(a_x,a_y,0,0,false);
      event_action action(m_out,m_ww,m_wh,e);
      m_scene_switch.event(action);
      if(action.done()) {
        //someone did something with this event (an image ?)
        to_render = true; //ioda::main::move_image_cbk uses console.
      }

    }

    return to_render;
  }

  /////////////////////////////////////
  /// gesture (mainly iOS) ////////////
  /////////////////////////////////////
  void start_gesture(unsigned int a_x,unsigned int a_y) {
    //keep separate for iPhone gestures.
    delete m_gesture_begin_camera;
    m_gesture_begin_camera = 0;
    if(m_scene_camera) {
      m_gesture_begin_camera = m_scene_camera->copy();
    }
    m_gesture_begin_x = a_x;
    m_gesture_begin_y = a_y;
  }

  base_camera* saved_cursor_and_camera(unsigned int& a_x,unsigned int& a_y) {
    a_x = m_gesture_begin_x;
    a_y = m_gesture_begin_y;
    if(!m_gesture_begin_camera) return 0;
    return safe_cast<node,base_camera>(*m_gesture_begin_camera);
  }

  void reset_camera_with_saved() {
    if(m_scene_camera && m_gesture_begin_camera) {

      ortho* oc = safe_cast<base_camera,ortho>(*m_scene_camera);
      perspective* pc =  safe_cast<base_camera,perspective>(*m_scene_camera);
      ortho* roc = safe_cast<node,ortho>(*m_gesture_begin_camera);
      perspective* rpc = safe_cast<node,perspective>(*m_gesture_begin_camera);

      if(oc && roc) {
        *oc = *roc;
      }
      if(pc && rpc) {
        *pc = *rpc;
      }
    }

    _set_params_camera();    
  }
  /////////////////////////////////////
  /////////////////////////////////////
  /////////////////////////////////////

public:
  base_camera* cursor_camera() const {return m_cursor_camera;}

  void set_cursor_position(float a_x,float a_y) {
    m_cursor_matrix.set_translate(a_x,a_y,0);
  } 
  void get_cursor_position(float& a_x,float& a_y) const {
    const mat4f& mtx = m_cursor_matrix.mtx.value();
    a_x = mtx[12];
    a_y = mtx[13];
  } 


  void set_ziper(zip_func a_func){m_zip_func = a_func;}
  zip_func ziper() const {return m_zip_func;}

  void set_unziper(unzip_func a_func){m_unzip_func = a_func;}
  unzip_func unziper() const {return m_unzip_func;}
  
public:
  //void clear_tmp_group() {m_tmp_group.clear();}

  //const group& tmp_group() const {return m_tmp_group;}
  //group& tmp_group() {return m_tmp_group;}

  template <class T>
  void add_in_tmp_group(const std::string& a_name,T* a_obj) {
    m_tmp_group.add(new holder<T>(a_obj,a_name));
  }

  template <class T>
  T* find_in_tmp_group(const std::string& a_name) {
    return find_holder<T>(m_tmp_group.children(),a_name);
  }

  template <class T>
  T* find_first_in_tmp_group() {
    return find_first_holder<T>(m_tmp_group.children());
  }

  template <class T>
  void remove_in_tmp_group(const std::string& a_name) {
    remove_holders<T>(m_tmp_group.children(),a_name);
  }

protected:
  static void set_button_style(const gui_params& a_params,
                               text_button& a_node) {
    a_node.back_area::color = a_params.m_gui_back_color;
    a_node.back_area::border_color = a_params.m_gui_border_color;
    a_node.color = a_params.m_gui_front_color;
    a_node.arm_color = a_params.m_gui_arm_color;
    a_node.hmargin_factor = 0.5f; //Apple seems to have that.
  }
  static void set_image_button_style(const gui_params& a_params,
                                     image_button& a_node) {
    a_node.back_area::color = a_params.m_gui_back_color;
    a_node.back_area::border_color = a_params.m_gui_border_color;
    a_node.color = a_params.m_gui_back_color;
    a_node.arm_color = a_params.m_gui_arm_color;
    //a_node.hmargin_factor = 0.8f;
    a_node.hmargin_factor = 0.6f;
  }
  static void set_arrow_button_style(const gui_params& a_params,
                                     arrow_button& a_node) {
    a_node.back_area::color = a_params.m_gui_back_color;
    a_node.back_area::border_color = a_params.m_gui_border_color;
    a_node.color = a_params.m_gui_front_color;
    a_node.arm_color = a_params.m_gui_arm_color;
  }

  //static //not static because of set_img_from_file
  void create_main_button(std::ostream& a_out,
                          const std::string& a_res_dir,
                          const gui_params& a_params,
                          separator& a_parent,
                          float a_wcw,float a_wch,float a_wb,float a_hb,
                          float a_roffset,
                          unsigned int a_col,unsigned int a_row,
                          const std::string& a_label,
                          const std::string& a_img_label,
                          const std::string& a_img,
                          bcbk* a_cbk) { //take ownerhship.
    //a_col=[0,a_cols-1] 0=left
    //a_row=[0,a_rows-1] 0=bottom
    //a_roffset : for Wt : to see right border of buttons at right.
 
    //float wbutton = a_wcw/float(a_cols);
    //float hbutton = a_wch/float(a_rows);
    float wbutton = a_wb;
    float hbutton = a_hb;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;

    float x = -a_wcw*0.5F+wbutton*0.5f; //at left.
    x += a_col*wbutton;
    x -= a_wcw*a_roffset;

    float y = -a_wch*0.5F+hbutton*0.5f; //at bottom.
    y += a_row*hbutton;

    m->set_translate(x,y,0);
    sep->add(m);

    if(a_img.size()&&a_params.m_image_buttons) {
      image_text_button* b = new image_text_button(m_ttf);
      b->width = wbutton;
      b->height = hbutton;

      set_image_button_style(a_params,*b);
      set_img_from_file(a_out,a_res_dir,a_img,b->img.value());
      b->img.touch();

      if(a_img_label.size()) {
        b->text().strings.clear();
        b->text().strings.add(a_img_label);
        b->text().font = gui_font();
        b->text().color = a_params.m_gui_front_color;
      }
      s2layout_policy(m_params.m_list_item_layout,b->layout.value());
      b->corner_radius = a_params.m_corner_radius;

      b->add_callback(a_cbk);
      sep->add(b);

    } else {
      text_button* b = new text_button(m_ttf);
      b->width = wbutton;
      b->height = hbutton;

      set_button_style(a_params,*b);
      b->set_arconf(a_label);

      b->corner_radius = a_params.m_corner_radius;

      b->add_callback(a_cbk);
      sep->add(b);
    }
  }

  //static //not static because of set_img_from_file
  void create_main_button(std::ostream& a_out,
                          const std::string& a_res_dir,
                          const gui_params& a_params,
                          separator& a_parent,
                          float a_wcw,float a_wch,float a_wb,float a_hb,
                          float a_roffset,
                          unsigned int a_col,unsigned int a_row,
                          image_button& a_img_button,
                          text_button& a_button,
                          const std::string& a_label,
                          const std::string& a_img,
                          bcbk* a_cbk) { //take ownerhship.
    float wbutton = a_wb;
    float hbutton = a_hb;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;

    float x = -a_wcw*0.5F+wbutton*0.5f; //at left.
    x += a_col*wbutton;
    x -= a_wcw*a_roffset;

    float y = -a_wch*0.5F+hbutton*0.5f; //at bottom.
    y += a_row*hbutton;

    m->set_translate(x,y,0);
    sep->add(m);

    if(a_params.m_image_buttons) {
      a_img_button.width = wbutton;
      a_img_button.height = hbutton;

      set_image_button_style(a_params,a_img_button);
      set_img_from_file(a_out,a_res_dir,a_img,a_img_button.img.value());
      a_img_button.img.touch();

      a_img_button.corner_radius = a_params.m_corner_radius;

      a_img_button.clear_cbks();
      a_img_button.add_callback(a_cbk);
      sep->add(new noderef(a_img_button));

    } else {
      a_button.width = wbutton;
      a_button.height = hbutton;

      set_button_style(a_params,a_button);
      a_button.set_arconf(a_label);

      a_button.corner_radius = a_params.m_corner_radius;

      a_button.clear_cbks();
      a_button.add_callback(a_cbk);
      sep->add(new noderef(a_button));
    }
  }

  static void create_main_button(
                          const gui_params& a_params,
                          separator& a_parent,
                          float a_wcw,float a_wch,float a_wb,float a_hb,
                          float a_roffset,
                          unsigned int a_col,unsigned int a_row,
                          const std::string& a_label,
                          text_button& a_button,
                          bcbk* a_cbk) { //take ownerhship.
    float wbutton = a_wb;
    float hbutton = a_hb;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;

    float x = -a_wcw*0.5F+wbutton*0.5f; //at left.
    x += a_col*wbutton;
    x -= a_wcw*a_roffset;

    float y = -a_wch*0.5F+hbutton*0.5f; //at bottom.
    y += a_row*hbutton;

    m->set_translate(x,y,0);
    sep->add(m);

    a_button.width = wbutton;
    a_button.height = hbutton;

    set_button_style(a_params,a_button);
    a_button.set_arconf(a_label);

    a_button.corner_radius = a_params.m_corner_radius;

    a_button.clear_cbks();
    a_button.add_callback(a_cbk);

    sep->add(new noderef(a_button));
  }

  static void create_arrow(const gui_params& a_params,
                           separator& a_parent,
                           float a_wcw,float a_wch,float a_wb,float a_hb,
                           float a_roffset,
                           unsigned int a_col,unsigned int a_row,
                           arrow_type a_type,
                           bcbk* a_cbk) { //take ownerhship.
    float wbutton = a_wb;
    float hbutton = a_hb;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;

    float x = -a_wcw*0.5F+wbutton*0.5f; //at left.
    x += a_col*wbutton;
    x -= a_wcw*a_roffset;

    float y = -a_wch*0.5F+hbutton*0.5f; //at bottom.
    y += a_row*hbutton;

    m->set_translate(x,y,0);
    sep->add(m);

    arrow_button* b = new arrow_button;
    b->width = wbutton;
    b->height = hbutton;
    b->orientation = a_type;
    set_arrow_button_style(a_params,*b);

    b->corner_radius = a_params.m_corner_radius;

    b->add_callback(a_cbk);

    sep->add(b);
  }

  static void create_meta_zone(const gui_params& a_params,
                               const base_freetype& a_ttf,
                               separator& a_parent,
                               _switch& a_meta_switch,
                               float a_wcw,float a_wch,float a_hzone,
                               bcbk* a_cbk) { //take ownerhship.
    int old_meta_switch_which = a_meta_switch.which;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;
    float wbutton = a_wcw;
    float x = 0;
    float y = -a_wch*0.5F+a_hzone*0.5f;
    m->set_translate(x,y,-0.1f);
    sep->add(m);

    a_meta_switch.clear();
    sep->add(new noderef(a_meta_switch));

   {text_button* b = new text_button(a_ttf);
    b->set_arconf("scene to menu area (shown once)");
    set_button_style(a_params,*b);
    b->back_area::color = colorf(0.7f,0.9f,1,0.2f);
    //b->width = wbutton*(1-2*0.3f);
    b->width = wbutton;
    b->height = a_hzone;
    b->add_callback(a_cbk->copy());
    a_meta_switch.add(b);}

   {ghost* b = new ghost;
    b->width = wbutton;
    b->height = a_hzone;
    b->add_callback(a_cbk);
    a_meta_switch.add(b);}

    a_meta_switch.which = old_meta_switch_which;
  }

public:
  bool set_img(image_button& a_button,const std::string& a_file) {
    bool status = set_img_from_file(m_out,m_res_dir,a_file,a_button.img.value());
    a_button.img.touch();
    return status;
  }

public:
  float gui_camera_height() const {return 2;}

  void create_gui() { //public to handle DOCUMENT at startup.
    //NOTE : there is no callback setup here. There are done
    //       in sub virtual methods.

    //m_out << "inlib::sg::gui_viewer::create_gui : " << std::endl;

    int old_menu_switch_which = m_main_menu_switch.which;
    int old_camenu_switch_which = m_camenu_switch.which;
    int old_gui_sliders_switch_which = m_gui_sliders_switch.which;
    int old_sliders_switch_which = m_sliders_switch.which;
    int old_progress_switch_which = m_progress_switch.which;
    //int old_meta_switch_which = m_meta_switch.which;
    int old_console_switch_which = m_console_switch.which;
    int old_popup_switch_which = m_popup_switch.which;

    m_gui.clear();

   {depth_test* node = new depth_test;
    node->on = false;
    m_gui.add(node);}

    bool old_param_cam_tiled = m_params.m_cam_tiled;
    //wall screen app : enforce gui in one screen only.
    m_params.m_cam_tiled = true;

    // NOTE : wall : in this case camera height is mapped
    //               on the whole "wall inside external borders" height.

    float cam_height = gui_camera_height();
    base_camera* camera = create_camera(camera_ortho,cam_height,0.1f);
    camera->position.value().set_value(0,0,2);
    camera->focal = 2;
    m_gui.add(camera);

    m_params.m_cam_tiled = old_param_cam_tiled;

    float wcw,wch,aspect;

   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);
    matrix* m = new matrix;
    m->set_translate(tx,ty,0);
    m_gui.add(m);}

    float hbutton = wch/float(10);

    float right_offset = 0.001f; //Wt : to see the right border of buttons.

    ///////////////////////////////////////////////////////////////////////
    /// sliders ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    // sliders are in front of the scene but behind all UI things.

    m_gui_sliders_switch.clear();
    m_gui.add(new noderef(m_gui_sliders_switch));

   {m_sliders_switch.clear();
    m_gui_sliders_switch.add(new noderef(m_sliders_switch));
    m_gui_sliders_switch.add(new separator());
    m_gui_sliders_switch.which = old_gui_sliders_switch_which;

    separator* sliders_sep = new separator;
    m_sliders_switch.add(sliders_sep);
    m_sliders_switch.add(new separator());
    m_sliders_switch.which = old_sliders_switch_which;

    create_sliders(aspect,wcw,wch,*sliders_sep);}

    ///////////////////////////////////////////////////////////////////////
    /// main menu /////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_main_menu_switch.clear();
    m_gui.add(new noderef(m_main_menu_switch));

    m_full_sep.clear();

    m_main_menu_switch.add(new noderef(m_full_sep));
    m_main_menu_switch.add(new separator());
    m_main_menu_switch.which = old_menu_switch_which;
    m_clear_color = m_main_menu_switch.which.value()==SHOWN()?
      m_params.m_gui_screen_color:m_params.m_scene_screen_color;

    float wbutton = wcw/float(3);

    create_control_items(wcw,wch,wbutton,hbutton,right_offset);
  
   {separator* sep = new separator;
    m_full_sep.add(sep);

    matrix* m = new matrix;
    sep->add(m);

    node* _node = current_list();
    if(_node) {
      if(list* _list = safe_cast<node,list>(*_node)) {
        set_list_layout(*_list,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(text* _text = safe_cast<node,text>(*_node)) {
        set_text_layout(*_text,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(scroll_text* _stext = safe_cast<node,scroll_text>(*_node)) {
        set_scroll_text_layout(*_stext,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(scroll_infos* _sinfos = safe_cast<node,scroll_infos>(*_node)) {
        set_scroll_infos_layout(*_sinfos,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(numeric* _numeric = safe_cast<node,numeric>(*_node)){
        _numeric->width = wcw*0.5F;
        _numeric->height = wch*0.5F;
        _numeric->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(edvalop* _edvalop = safe_cast<node,edvalop>(*_node)){
        set_edvalop_layout(*_edvalop,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(colors* _colors = safe_cast<node,colors>(*_node)) {
        _colors->width = wcw*0.8F;
        _colors->height = wch*0.5F;
        _colors->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(/* button_grid<simple_button>* cnode = */
                  safe_cast<node, button_grid<simple_button> >(*_node)) {
        // do not enforce a size. If not see rwc_gui.
        //cnode->width = wcw*0.8F;
        //cnode->height = wch*0.5F;
        sep->add(new noderef(*_node));

      } else if(keyboard* _kb = safe_cast<node,keyboard>(*_node)){
        _kb->width = wcw*0.98F;
        _kb->height = wch*0.5F;
        _kb->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(entry* _entry = safe_cast<node,entry>(*_node)) {
        _entry->width = wcw*0.5F;
        _entry->height = hbutton;
        _entry->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(entries* _entries = safe_cast<node,entries>(*_node)) {
        set_entries_layout(*_entries,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(slider* _slider = safe_cast<node,slider>(*_node)) {
        _slider->width = wcw*0.5F;
        _slider->height = wch*0.05F;
        sep->add(new noderef(*_node));

      } else if(back_area* _ba = safe_cast<node,back_area>(*_node)) {
        set_back_area_layout(*_ba,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      }
    }}

    } //end central menu.

    ///////////////////////////////////////////////////////////////////////
    /// camera menu ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_camenu_switch.clear();
    m_gui.add(new noderef(m_camenu_switch));

    m_camenu_switch.add(new noderef(m_camenu_sep));
    m_camenu_switch.add(new separator());
    m_camenu_switch.which = old_camenu_switch_which;

    unsigned int nbutton = device::small_screen()?15:20;
    float warrow = wcw/float(nbutton);
    float harrow = warrow;

    m_camenu_sep.clear();

    create_camenu_items(nbutton,wcw,wch,warrow,harrow);

    } //end camenu

    ///////////////////////////////////////////////////////////////////////
    /// console ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_console_switch.clear();
    m_gui.add(new noderef(m_console_switch));

    separator* console_sep = new separator;
    m_console_switch.add(console_sep);
    m_console_switch.add(new separator());
    m_console_switch.which = old_console_switch_which;

    console_sep->add(new noderef(m_console_matrix));
    console_sep->add(new noderef(m_console));

    set_button_style(m_params,m_console);
    _set_console_layout(wcw,wch);

    } //end console

    ///////////////////////////////////////////////////////////////////////
    /// progress //////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
   {m_progress_switch.clear();
    m_gui.add(new noderef(m_progress_switch));

    separator* progress_sep = new separator;
    m_progress_switch.add(progress_sep);
    m_progress_switch.add(new separator());
    m_progress_switch.which = old_progress_switch_which;

    float h = wch*0.05f;
    float w = wcw*0.8f;

    m_progress.width = w;
    m_progress.height = h;
    m_progress.color = m_params.m_gui_arm_color;
  //m_progress.corner_radius = m_params.m_corner_radius;
    progress_sep->add(new noderef(m_progress));
    }

    ///////////////////////////////////////////////////////////////////////
    /// popup /////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_popup_switch.clear();
    m_gui.add(new noderef(m_popup_switch));

    separator* _popup_sep = new separator;
    m_popup_switch.add(_popup_sep);
    m_popup_switch.add(new separator());
    m_popup_switch.which = old_popup_switch_which;

    //m_popup_matrix.set_identity();
    _popup_sep->add(new noderef(m_popup_matrix));
    _popup_sep->add(new noderef(m_popup_sep));

    } //end popup

    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    create_meta_zone(wcw,wch,hbutton);

  }

protected:
  // virtual gui methods containing callbacks :
  // For example redefined for the wall data client remote control gui.
  virtual void create_meta_zone(float a_wcw,float a_wch,float a_hzone) {
    create_meta_zone(m_params,m_ttf,m_gui,m_meta_switch,
                     a_wcw,a_wch,a_hzone,
                     new gui_cbk(*this,gui_cbk::action_meta_zone()));
  }

  virtual void create_control_items(float a_wcw,float a_wch,
                                    float a_wb,float a_hb,float a_roffset) {
    create_main_button(m_out,m_res_dir,m_params,
                       m_full_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,0,"home","home","go_home_large.jpg",
                       new gui_cbk(*this,gui_cbk::action_home()));

    if(params_button_visible.value()) { 
      create_main_button(m_out,m_res_dir,m_params,
                         m_full_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         0,1,"params","params","system_config_boot.jpg",
                         new gui_cbk(*this,gui_cbk::action_params_show()));
    }
  
    create_main_button(m_out,m_res_dir,m_params,
                       m_full_sep,a_wcw,a_wch,a_wb,a_hb,a_roffset,
                       2,0,"back","back","turn_around.jpg",
                       new gui_cbk(*this,gui_cbk::action_back()));

    if(camera_button_visible.value()) { 
      create_main_button(m_out,m_res_dir,m_params,
                         m_full_sep,a_wcw,a_wch,a_wb,a_hb,a_roffset,
                         2,1,"camera","camera","movie_camera.jpg",
                         new gui_cbk(*this,gui_cbk::action_show_camenu()));
    }
  }

  virtual void create_camenu_items(unsigned int a_nb,
                                   float a_wcw,float a_wch,
                                   float a_wb,float a_hb) {

    ///////////////////////////////////////////////////////////////////////
    /// camenu right area /////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    // create four arrows :
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-2,2,arrow_up,
                 new gui_cbk(*this,gui_cbk::action_up()));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-2,0,arrow_down,
                 new gui_cbk(*this,gui_cbk::action_down()));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-3,1,arrow_left,
                 new gui_cbk(*this,gui_cbk::action_left()));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-1,1,arrow_right,
                 new gui_cbk(*this,gui_cbk::action_right()));

    //inside "shift" button :
    create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-2,1,anim_shift_button_label(),
                       m_camenu_shift_button,
                       new gui_cbk(*this,gui_cbk::action_anim_shift()));

    //outside top-left "single shoot" button :
    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-3,2,
                       m_camenu_sshoot_image_button,
                       m_camenu_sshoot_text_button,
                       single_shoot_button_label(),
                       single_shoot_image_button_file(),
                       new gui_cbk(*this,gui_cbk::action_single_shoot()));

    //outside bottom-right hide button :
    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-1,0,"hide","","close.jpg",
                       new gui_cbk(*this,gui_cbk::action_hide_camenu()));

    //outside top-right reset camera button :
    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-1,2,"reset","","edit_undo.jpg",
                       new gui_cbk(*this,gui_cbk::action_reset_camera()));

    //outside bottom-left "90" button :
    if(camenu_90_visible.value()) {
      create_main_button(m_out,m_res_dir,m_params,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-3,0,
                         m_camenu_90_image_button,
                         m_camenu_90_text_button,
                         rot_90_button_label(),
                         rot_90_image_button_file(),
                         new gui_cbk(*this,gui_cbk::action_90()));
    }

    if(camenu_edit_visible.value()) {
      //outside top-left "edit" button :
      create_main_button(m_out,m_res_dir,m_params,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-4,2,"edit","","edit.jpg",
                         new gui_cbk(*this,gui_cbk::action_cam_choose_type()));
    }

    if(camenu_focal_visible.value()) {
      //"aroud focal" button under the edit one :
      create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-4,1,around_focal_button_label(),
                       m_camenu_focal_button,
                       new gui_cbk(*this,gui_cbk::action_anim_around_focal()));
    }
  
    if(camenu_viewing_visible.value()) {
      // viewing/picking mode button under the focal one :
      create_main_button(m_params,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-4,0,viewing_button_label(),
                         m_camenu_viewing_button,
                         new gui_cbk(*this,gui_cbk::action_viewing()));
    }

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,2,"mv","","",
                       new gui_cbk(*this,gui_cbk::action_cam_choose_anim()));

    ///////////////////////////////////////////////////////////////////////
    /// camenu left area //////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,0,"clear","","edit_clear.jpg",
                       new gui_cbk(*this,gui_cbk::action_clear_scene()));

    create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,1,plane_exam_button_label(),
                       m_camenu_plane_exam_button,
                       new gui_cbk(*this,gui_cbk::action_plane_exam()));

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,2,"<)","","",
                       new gui_cbk(*this,gui_cbk::action_adapt_camera()));

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,0,"N","","",
                       new gui_cbk(*this,gui_cbk::action_count_points()));

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,1,"^","","",
                       new gui_cbk(*this,gui_cbk::action_toggle_light()));

    create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,2,"gsto",
                       m_camenu_gsto_button,
                       new gui_cbk(*this,gui_cbk::action_toggle_gsto()));
    set_use_gsto(m_use_gsto); //update back color.

  }
protected:
  void _set_console_layout(float a_wcw,float a_wch) {
    float hconsole = a_wch*m_params.m_console_height*m_params.m_console_scale;
    float wconsole = a_wcw*m_params.m_console_width*m_params.m_console_scale;

    float x = -a_wcw*0.5F+wconsole*0.5F; //right.
    float y = a_wch*0.5F-hconsole*0.5f; //top
    m_console_matrix.set_translate(x,y,0);

    m_console.width = wconsole;
    m_console.height = hconsole;
  }
public:
  void set_console_layout() {
    float wcw,wch;
   {float tx,ty,aspect;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}
    _set_console_layout(wcw,wch);
  }
protected:

  void set_sliders_layout(float a_wcw,float a_wch,float a_aspect) {
    float hslider = a_wch*0.025f; // desktops.
    if(device::small_screen()) {
      if(a_aspect>1) {
        hslider *= 3;
      } else {
        hslider *= 2;
      }
    }

    float whide = hslider;
    float hhide = hslider;
    float whand = 4*whide; //for Archery vertical slider.

    // slider 1 :
   {float wslider,x,y;
    if((m_params.m_sliders_pos==gui_params::s_sliders_2b())    ||
       (m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) ){
      wslider = (a_wcw-whide)*0.5f;
      x = -a_wcw*0.5f+wslider*0.5f; //left
      y = -a_wch*0.5F+hslider*0.5f; //bottom
    } else if(m_params.m_sliders_pos==gui_params::s_sliders_bl()) {
      wslider = a_wcw-whide;
      x = -a_wcw*0.5f+wslider*0.5f; //left
      y = -a_wch*0.5F+hslider*0.5f; //bottom
    } else {
      wslider = 0; //not visible.
      x = 0;
      y = 0;
    }
    m_slider_1_matrix.set_translate(x,y,0);
    m_slider_1.width = wslider;
    m_slider_1.height = hslider;
    m_slider_1.size = whand;}

    // slider 2 :
   {float wslider,x,y;
    if((m_params.m_sliders_pos==gui_params::s_sliders_2b())    ||
       (m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) ){
      wslider = (a_wcw-whide)*0.5f;
      x = -a_wcw*0.5f+wslider*0.5f+wslider; //left+wslider
      y = -a_wch*0.5F+hslider*0.5f;         //bottom
    } else {
      wslider = 0; //not visible.
      x = 0;
      y = 0;
    }
    m_slider_2_matrix.set_translate(x,y,0);
    m_slider_2.width = wslider;
    m_slider_2.height = hslider;
    m_slider_2.size = whand;}

    // slider 3 :
   {float wslider,x,y;
    if(m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) {
      wslider = (a_wch-hhide)*0.5f;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f-wslider;
      m_slider_3_matrix.set_translate(x,y,0);
      m_slider_3_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else if((m_params.m_sliders_pos==gui_params::s_sliders_bl())||
              (m_params.m_sliders_pos==gui_params::s_sliders_l()) ){
      wslider = a_wch-hhide;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f;
      m_slider_3_matrix.set_translate(x,y,0);
      m_slider_3_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else {
      wslider = 0; //not visible
      x = 0;
      y = 0;
      m_slider_3_matrix.set_translate(x,y,0);
    }
    m_slider_3.width = wslider;
    m_slider_3.height = hslider;
    m_slider_3.size = whand;}

    // slider 4 :
   {float wslider,x,y;
    if(m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) {
      wslider = (a_wch-hhide)*0.5f;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f;
      m_slider_4_matrix.set_translate(x,y,0);
      m_slider_4_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else {
      wslider = 0; //not visible
      x = 0;
      y = 0;
      m_slider_4_matrix.set_translate(x,y,0);
    }
    m_slider_4.width = wslider;
    m_slider_4.height = hslider;
    m_slider_4.size = whand;}

    // hide button :
   {float x = a_wcw*0.5F-whide*0.5F; //at right. //2b,2b_2v
    float y = -a_wch*0.5F+hhide*0.5f; //bottom
    m_hide_sliders_matrix.set_translate(x,y,0);}

    back_area* ba = safe_cast<node,back_area>(*m_hide_sliders_sep[1]);
    ba->width = whide;
    ba->height = hhide;
  }
public:
  void set_sliders_layout() {
    float wcw,wch,aspect;
   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}
    set_sliders_layout(wcw,wch,aspect);
  }
  void set_sliders_pos(const std::string& a_v) {
    if(m_params.m_sliders_pos==a_v) return;
    m_params.m_sliders_pos = a_v;
    set_sliders_layout();
  }
protected:
  void create_sliders(float a_aspect,float a_wcw,float a_wch,separator& a_sliders_sep) {
    // slider 1 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_1_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_1));}

    // slider 2 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_2_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_2));}

    // slider 3 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_3_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_3));}

    // slider 4 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_4_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_4));}

    // hide button :
   {m_hide_sliders_sep.clear();
    a_sliders_sep.add(new noderef(m_hide_sliders_sep));

    m_hide_sliders_sep.add(new noderef(m_hide_sliders_matrix)); //0

    if(m_params.m_image_buttons) {
      image_button* b = new image_button;
      set_image_button_style(m_params,*b);
      set_img(*b,"close.jpg");
      b->add_callback(new inlib::cbk::hide(m_sliders_switch));
      m_hide_sliders_sep.add(b); //1
    } else {
      text_button* b = new text_button(m_ttf);
      set_button_style(m_params,*b);
      b->set_arconf("H");
      b->add_callback(new inlib::cbk::hide(m_sliders_switch));
      m_hide_sliders_sep.add(b); //1
    }}

    set_sliders_layout(a_wcw,a_wch,a_aspect);

    set_slider_style(m_slider_1);
    set_slider_style(m_slider_2);
    set_slider_style(m_slider_3);
    set_slider_style(m_slider_4);
  }

protected:
  void _set_params_camera() {

    if(!m_scene_camera) {
      m_params.m_camera_type.clear();

    } else if(safe_cast<base_camera,ortho>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_ortho();
    } else if(safe_cast<base_camera,lrbt>(*m_scene_camera)) { 
      m_params.m_camera_type = s_camera_ortho();

    } else if(safe_cast<base_camera,perspective>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_perspective();
    } else if(safe_cast<base_camera,frustum>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_perspective();

    } else {
      m_params.m_camera_type.clear();
    }

    // for rwc :
    // one wall screen apps send the m_cam_<xxx> params to the rwc.
    // See wall/SDL_dispatch.
    if(!m_scene_camera) {
      m_params.m_cam_x = 0;
      m_params.m_cam_y = 0;
      m_params.m_cam_z = 0;
      m_params.m_cam_near = 0;
      m_params.m_cam_far = 0;
      m_params.m_cam_focal = 0;
      m_params.m_cam_dx = 0;
      m_params.m_cam_da = 0;
      m_params.m_cam_ds = 0;
    } else {
      m_params.m_cam_x = m_scene_camera->position.value().x();
      m_params.m_cam_y = m_scene_camera->position.value().y();
      m_params.m_cam_z = m_scene_camera->position.value().z();
      m_params.m_cam_near = m_scene_camera->znear;
      m_params.m_cam_far = m_scene_camera->zfar;
      m_params.m_cam_focal = m_scene_camera->focal;
      m_params.m_cam_dx = m_scene_camera->dx;
      m_params.m_cam_da = m_scene_camera->da;
      m_params.m_cam_ds = m_scene_camera->ds;
    }
    m_params.m_cam_zof = 1;
  }
public:
  void reset_camera() {
    if(m_scene_camera && m_reset_camera) {

      ortho* oc = safe_cast<base_camera,ortho>(*m_scene_camera);
      perspective* pc = safe_cast<base_camera,perspective>(*m_scene_camera);
      lrbt* lc = safe_cast<base_camera,lrbt>(*m_scene_camera);
      frustum* fc = safe_cast<base_camera,frustum>(*m_scene_camera);

      ortho* roc = safe_cast<node,ortho>(*m_reset_camera);
      perspective* rpc = safe_cast<node,perspective>(*m_reset_camera);
      lrbt* rlc = safe_cast<node,lrbt>(*m_reset_camera);
      frustum* rfc = safe_cast<node,frustum>(*m_reset_camera);

      if(oc && roc) {
        *oc = *roc;
      }
      if(pc && rpc) {
        *pc = *rpc;
      }
      if(lc && rlc) {
        *lc = *rlc;
      }
      if(fc && rfc) {
        *fc = *rfc;
      }
    }

    _set_params_camera();    
  }

  bool adapt_camera(node& a_node) {
    base_camera* cam = scene_camera();
    if(!cam) return false;

    bbox_action _action(m_out);
    a_node.bbox(_action);
    if(!_action.end()) return false;
    float dx,dy,dz;
    if(!_action.box().get_size(dx,dy,dz)) return false;    
    vec3f c;
    if(!_action.box().center(c)) return false;
    if((dz<=0)&&(dy<=0)) return false;

    group* grp = find_container<group>(m_out,m_scene,cam,false);
    if(!grp) return false;

    base_camera* new_cam = 0;
    float z;

    if( safe_cast<base_camera,ortho>(*cam) ||
        safe_cast<base_camera,lrbt>(*cam)  ){ 

      float cam_height = 2;
      //if(dy>0) cam_height = dy*2;
      if(dy>0) cam_height = dy*1.2f;

      z = dz>0?dz*2:dy*10;

      float znear = 0.01f*z;
      new_cam = create_camera(camera_ortho,cam_height,znear);

    } else if(safe_cast<base_camera,perspective>(*cam) ||
              safe_cast<base_camera,frustum>(*cam) ){

      float angle;
      z = 0;
      if(dz<=0) { //use dy to get z.
        angle = fpi()*0.25f;
        z = 0.5f*dy/ftan(angle*0.5f);
      } else {
        z = dz*2;
        if(dy>0) {
          // compute half angle with front face of scene box.
          angle = 2*fatan((0.5f*dy)/(1.5f*dz));
        } else {
          angle = fpi()*0.25f;
        }
      }

      float znear = 0.01f*z;
      float near_height = 2*znear*ftan(angle*0.5f);

      new_cam = create_camera(camera_perspective,near_height,znear);

    }

    if(!new_cam) return false;

    new_cam->zfar = 100*z;
    new_cam->position = vec3f(0,0,z);
    new_cam->dx = z*0.003f;
    new_cam->focal = z;

    //::printf("debug : dy %g dz %g : %g %g %g\n",dy,dz,c.x(),c.y(),c.z());
    new_cam->position.value() += c;

    if(!grp->replace(cam,new_cam,true)) {
      delete new_cam;
      return false;
    }

    set_scene_camera(new_cam);

    return true;
  }

  bool cam_anim_is_running() const {
    if(!m_scene_camera) return false;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    return anim?true:false;
  }

  void stop_cam_anim() {
    if(!m_scene_camera) return;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    if(!anim) return; //done

    //restore a not anim camera :
    search_action sa(m_out);
    const path_t& _path = find_path(sa,m_scene,m_scene_camera,false);
    if(_path.empty()) {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " path not found for current camera."
                    << std::endl;       
      return;
    }
    group* grp = container<group>(_path);
    if(!grp) {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " camera group not found."
                    << std::endl;       
      return;
    }

    base_camera* new_cam = 0;
    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){
      new_cam = new perspective(*pc);
    } else if(frustum* fc = safe_cast<node,frustum>(*m_scene_camera)){
      new_cam = new frustum(*fc);
    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
      new_cam = new ortho(*oc);
    } else if(lrbt* lc = safe_cast<node,lrbt>(*m_scene_camera)){
      new_cam = new lrbt(*lc);

    } else {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " camera not ortho and not perspective."
                    << std::endl;
      return;
    }

    grp->replace(m_scene_camera,new_cam,true); // it deletes m_scene_camera.
    set_scene_camera(new_cam,false); //WARNING : false
  }

  void start_cam_anim(anim_what a_anim,bool a_shift,unsigned int a_cycle) {
    int move;
    if(!anim2motion(a_anim,a_shift,move)) {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " unknown anim code " << a_anim
                    << std::endl;       
      return;
    }
    start_cam_move(move,a_cycle);
  }

  void start_cam_move(int a_move,unsigned int a_cycle) {
    if(!m_scene_camera) return;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    if(anim) return; //done

    search_action sa(m_out);
    const path_t& _path = find_path(sa,m_scene,m_scene_camera,false);
    if(_path.empty()) {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " path not found for current camera."
                    << std::endl;       
      return;
    }

    group* grp = container<group>(_path);
    if(!grp) {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " camera group not found."
                    << std::endl;       
      return;
    }

    atime _now(0,0);
    if(!get_time_now(_now)) {}

    base_camera* new_cam = 0;
    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){
      new_cam = new camera_anim<perspective>(*pc,_now,-1,a_move,a_cycle);
    } else if(frustum* fc = safe_cast<node,frustum>(*m_scene_camera)){
      new_cam = new camera_anim<frustum>(*fc,_now,-1,a_move,a_cycle);

    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
     new_cam = new camera_anim<ortho>(*oc,_now,-1,a_move,a_cycle);
    } else if(lrbt* lc = safe_cast<node,lrbt>(*m_scene_camera)){
      new_cam = new camera_anim<lrbt>(*lc,_now,-1,a_move,a_cycle);

    } else {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " camera not ortho and not perspective."
                    << std::endl;
      return;
    }

    grp->replace(m_scene_camera,new_cam,true); // it deletes m_scene_camera.
    set_scene_camera(new_cam,false); //WARNING : false

    enable_anim();
  }


public:
  static bool cmp_camera(const node& a_1,const node& a_2) {

    const ortho* oc1 = safe_cast<node,ortho>(a_1);
    const perspective* pc1 = safe_cast<node,perspective>(a_1);
    const lrbt* lc1 = safe_cast<node,lrbt>(a_1);
    const frustum* fc1 = safe_cast<node,frustum>(a_1);

    const ortho* oc2 = safe_cast<node,ortho>(a_2);
    const perspective* pc2 = safe_cast<node,perspective>(a_2);
    const lrbt* lc2 = safe_cast<node,lrbt>(a_2);
    const frustum* fc2 = safe_cast<node,frustum>(a_2);

    if(oc1 && oc2) return (*oc1)==(*oc2);
    if(pc1 && pc2) return (*pc1)==(*pc2);
    if(lc1 && lc2) return (*lc1)==(*lc2);
    if(fc1 && fc2) return (*fc1)==(*fc2);

    return false;
  }

public:
  //_switch& camera_menu_switch() {return m_camenu_switch;}
  //_switch& main_menu_switch() {return m_main_menu_switch;}

  /////////////////////////////////////////////////
  /// m_params ////////////////////////////////////
  /////////////////////////////////////////////////

  typedef std::pair<std::string,std::string> arg;
  bool args2params(const std::vector<arg>& a_args,bool a_warn){
    // WARNING : used in for wall/screen_dispatch rwc_set_params protocol.    
    bool status = true;

    for(unsigned int index=0;index<a_args.size();index++) {
      const std::string& lab = a_args[index].first;
      const std::string& val = a_args[index].second;

      if(rcmp(lab,gui_params::s_scene_screen_color())) {
        float r,g,b,a;
        if(!entries_color(val,r,g,b,a)) {
          if(a_warn) {
            map_warn("get color failed");
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " get color failed."
                          << std::endl;
            status = false; //not fatal.
          }
        } else {
          set_scene_clear_color(r,g,b,a);
        }

      } else if(rcmp(lab,gui_params::s_auto_hide_scene())) {
        bool changed;
        if(!to<bool>(m_params.m_auto_hide_scene,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          //we just click on the "param ok button", then ui is mapped.
          if(m_params.m_auto_hide_scene) {
            m_scene_switch.which = HIDDEN();
            //NOTE : we should stop any scene animation !
          } else {
	    m_scene_switch.which = SHOWN();
          }
        }
      
      } else if(rcmp(lab,gui_params::s_image_buttons())) {
        bool changed;
        if(!to<bool>(m_params.m_image_buttons,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          push_home(); //to reset style of central menu.
        }

      } else if(rcmp(lab,gui_params::s_plane_viewer())) {
        bool changed;
        if(!to<bool>(m_params.m_plane_viewer,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          set_camera_menu_labels();
        }

      } else if(rcmp(lab,gui_params::s_touch_move())) {
        bool changed;
        if(!to<bool>(m_params.m_touch_move,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_light_on())) {
        bool changed;
        if(!to<bool>(m_params.m_light_on,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          set_scene_light_on(m_params.m_light_on);
        }

      } else if(rcmp(lab,gui_params::s_solid())) {
        bool changed;
        if(!to<bool>(m_params.m_solid,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          // should force update_sg ?
        }

      } else if(rcmp(lab,gui_params::s_use_gsto()) ||
                rcmp(lab,gui_params::s_use_vbo())  ){ // old apps -> wall.
        bool changed;
        if(!to<bool>(m_params.m_use_gsto,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          set_use_gsto(m_params.m_use_gsto);
        }

      } else if(rcmp(lab,s_gsto_mode())) {
        if(val!=m_params.m_gsto_mode) {
          typedef sg::gsto_mode mode_t;
          mode_t mode;
          if(s2gsto_mode(val,mode)) {
            m_params.m_gsto_mode = val;
            set_use_gsto(m_params.m_use_gsto);
          }
        }

      } else if(rcmp(lab,gui_params::s_store_mode())) { //old apps -> wall.

        bool value = m_gl_mgr.get_gsto_mode()==sg::gsto_memory?false:true;

        bool changed;
        if(!to<bool>(value,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          std::string sv;
          m_gl_mgr.available_not_memory_gsto_mode(sv);
          if(sv.size()) {
            m_params.m_gsto_mode = sv;
            set_use_gsto(m_params.m_use_gsto);
          }
        }

      } else if(rcmp(lab,gui_params::s_image_expand())) {
        bool changed;
        if(!to<bool>(m_params.m_image_expand,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          // should force update_sg ?
        }

      } else if(rcmp(lab,gui_params::s_node_height())) {
        bool changed;
        if(!to<float>(m_params.m_node_height,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          // should force update_sg ?
          if(m_params.m_node_height<0) m_params.m_node_height = 0;
        }

      } else if(rcmp(lab,gui_params::s_node_color())) {
        m_params.m_node_color = val;

      } else if(rcmp(lab,gui_params::s_sliders_pos())) {
        bool changed = val==m_params.m_sliders_pos?false:true;
        m_params.m_sliders_pos = val;
        if(changed) set_sliders_layout();

      } else if(rcmp(lab,gui_params::s_time_interval())) {
        bool changed;
        if(!to<unsigned int>(m_params.m_time_interval,val,changed)) {
          if(a_warn) {
            map_warn_naui();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not an unsigned int."
                          << std::endl;
            status = false;      //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_cycle_secs())) {
        bool changed;
        if(!to<unsigned int>(m_params.m_cycle_secs,val,changed)) {
          if(a_warn) {
            map_warn_naui();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not an unsigned int."
                          << std::endl;
            status = false;      //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_console_scale())) {
        bool changed;
        if(!to<float>(m_params.m_console_scale,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a number."
                          << std::endl;
            status = false;      //not fatal.
          }
        } else if(changed) {
          if(m_params.m_console_scale<=0) m_params.m_console_scale = 1;
          set_console_layout();
        }

      } else if(rcmp(lab,gui_params::s_console_width())) {
        bool changed;
        if(!to<float>(m_params.m_console_width,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a number."
                          << std::endl;
            status = false;      //not fatal.
          }
        } else if(changed) {
          if(m_params.m_console_width<=0) m_params.m_console_width = 0.3F;
          set_console_layout();
        }

      } else if(rcmp(lab,gui_params::s_console_height())) {
        bool changed;
        if(!to<float>(m_params.m_console_height,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a number."
                          << std::endl;
            status = false;      //not fatal.
          }
        } else if(changed) {
          if(m_params.m_console_height<=0) m_params.m_console_height = 0.05F;
          set_console_layout();
        }

      } else if(rcmp(lab,gui_params::s_camera_tiled())) {
        bool changed;
        if(!to<bool>(m_params.m_cam_tiled,val,changed)) {
          if(a_warn) {
            map_warn_nab();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not a boolean."
                          << std::endl;
            status = false;      //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_plot_col())) {
        bool changed;
        if(!to<unsigned int>(m_params.m_plot_col,val,changed)) {
          if(a_warn) {
            map_warn_naui();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not an unsigned int."
                          << std::endl;
            status = false;      //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_plot_row())) {
        bool changed;
        if(!to<unsigned int>(m_params.m_plot_row,val,changed)) {
          if(a_warn) {
            map_warn_naui();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2params :"
                          << " not an unsigned int."
                          << std::endl;
            status = false;      //not fatal.
          }
        } else if(changed) {
        }

      } else {
        if(a_warn) {
          map_warn(std::string("unknown param ")+lab);
          return false;
        } else {
          m_out << "inlib::sg::gui_viewer::args2params :"
                        << " unknown param " << lab
                        << std::endl;
          status = false;      //not fatal.
        }
      }
    }
    return status;     
  }

  bool args2camera(const std::vector<arg>& a_args,bool a_warn){
    //WARNING : used in for wall/screen_dispatch rwc_set_camera protocol.    
    if(!m_scene_camera) return false;

    bool status = true;

    // first pass to see if we have to swap the camera kind :
   {for(unsigned int index=0;index<a_args.size();index++) {
      const std::string& lab = a_args[index].first;
      const std::string& val = a_args[index].second;
      if(rcmp(lab,s_camera_type())             ||
         rcmp(lab,gui_params::s_camera_kind()) ){ //old wall data clients.

        bool to_swap = false;
        if((m_params.m_camera_type==s_camera_ortho())&&
           ((val==s_camera_perspective())||
            (val==gui_params::s_perspective())) ) //old wall data clients.
          to_swap = true;

        if((m_params.m_camera_type==s_camera_perspective())&&
           ((val==s_camera_ortho())||
            (val==gui_params::s_ortho())) )       //old wall data clients.
          to_swap = true;
          
        if(to_swap) {
          if(!swap_camera_kind()) { //FIXME : have to delete old cam !
            if(a_warn) {
              map_warn("swap camera kind failed");
            } else {
              m_out << "inlib::sg::gui_viewer::args2camera :"
                            << " swap camera kind failed."
                            << std::endl;
            }
            return false;
          }
        }
      }
    }}
  
    for(unsigned int index=0;index<a_args.size();index++) {
      const std::string& lab = a_args[index].first;
      const std::string& val = a_args[index].second;

      if(rcmp(lab,gui_params::s_cam_x())) {
        float field = m_scene_camera->position.value()[0];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[0] = field;
        }

      } else if(rcmp(lab,gui_params::s_cam_y())) {
        float field = m_scene_camera->position.value()[1];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[1] = field;
        }

      } else if(rcmp(lab,gui_params::s_cam_z())) {
        float field = m_scene_camera->position.value()[2];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[2] = field;
        }

      } else if(rcmp(lab,gui_params::s_cam_near())) {
        bool changed;
        if(!to<float>(m_scene_camera->znear.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_cam_far())) {
        bool changed;
        if(!to<float>(m_scene_camera->zfar.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_cam_focal())) {
        bool changed;
        if(!to<float>(m_scene_camera->focal.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_cam_dx())) {
        bool changed;
        if(!to<float>(m_scene_camera->dx.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_cam_da())) {
        bool changed;
        if(!to<float>(m_scene_camera->da.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_cam_ds())) {
        bool changed;
        if(!to<float>(m_scene_camera->ds.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(lab,gui_params::s_cam_zof())) {
        float v = -1;
        bool changed;
        if(!to<float>(v,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {          
          m_scene_camera->zoom(v);
        }

      } else if(rcmp(lab,gui_params::s_cam_orientation())) {
        if(!sqrot<float>
              (val,m_scene_camera->orientation.value())) status = false;

      } else {
        if(a_warn) {
          map_warn(std::string("unknown param ")+lab);
          return false;     
        } else {
          m_out << "inlib::sg::gui_viewer::args2camera :"
                        << " unknown param " << lab
                        << std::endl;
          status = false; //not fatal.
        }
      }
    }
    return status;     
  }

  //bool anim_shift() const {return m_params.m_anim_shift;}

  void set_params_camenu(const gui_params& a_params) {
    m_params = a_params;
    set_param_single_shoot(a_params.m_single_shoot);    
    set_param_90(a_params.m_90);    
    set_param_anim_shift(a_params.m_anim_shift);    
    set_param_anim_around_focal(a_params.m_anim_around_focal);    
    set_param_viewing(a_params.m_viewing);    
  }

  void set_param_anim_shift(bool a_value) {
    m_params.m_anim_shift = a_value;
    m_camenu_shift_button.set_label(anim_shift_button_label());
  }
  void toggle_param_anim_shift() {
    set_param_anim_shift(m_params.m_anim_shift?false:true);
  }

  void set_param_anim_around_focal(bool a_value) {
    m_params.m_anim_around_focal = a_value;
    if(m_params.m_plane_viewer) m_params.m_anim_around_focal = false;
    m_camenu_focal_button.set_label(around_focal_button_label());
  }
  void toggle_param_anim_around_focal() {
    set_param_anim_around_focal(m_params.m_anim_around_focal?false:true);
  }

  void set_param_viewing(bool a_value) {
    m_params.m_viewing = a_value;
    m_camenu_viewing_button.set_label(viewing_button_label());
    if(m_params.m_viewing){
      set_default_cursor_shape();
    } else {
      set_cursor_shape(cursor_target);
    }
  }
  void toggle_param_viewing() {
    set_param_viewing(m_params.m_viewing?false:true);
  }

  void set_param_90(bool a_value) {
    m_params.m_90 = a_value;
    if(m_params.m_plane_viewer) m_params.m_90 = false;
    if(m_params.m_image_buttons) {
      set_img(m_camenu_90_image_button,rot_90_image_button_file());
    } else {
      m_camenu_90_text_button.set_label(rot_90_button_label());
    }
  }
  void toggle_param_90() {set_param_90(m_params.m_90?false:true);}

  void set_param_single_shoot(bool a_value) {
    stop_cam_anim();

    m_params.m_single_shoot = a_value;
    if(m_params.m_single_shoot) stop_cam_anim();

    if(m_params.m_image_buttons) {
      set_img(m_camenu_sshoot_image_button,single_shoot_image_button_file());
    } else {
      m_camenu_sshoot_text_button.set_label(single_shoot_button_label());
    }
  }
  void toggle_param_single_shoot() {
    set_param_single_shoot(m_params.m_single_shoot?false:true);
  }

  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  void create_cursor() {
    //m_out << "inlib::sg::gui_viewer::create_cursor : " << std::endl;

    //mat4f old_mtx = m_cursor_matrix.mtx.value();

    m_cursor.clear();

   {depth_test* node = new depth_test;
    node->on = false;
    m_cursor.add(node);}

    // cam pos(0,0,1) near 0.1 far 10, menu pos in xy plan.
    float cam_height = 2;
    base_camera* camera = create_camera(camera_ortho,cam_height,0.1f);
    m_cursor_camera = camera;
    m_cursor.add(camera);

   {m_cursor_switch.clear();
    m_cursor.add(new noderef(m_cursor_switch));

    separator* full_sep = new separator;
    m_cursor_switch.add(full_sep);
    m_cursor_switch.add(new separator());
    m_cursor_switch.which = cursor_visible.value()?SHOWN():HIDDEN();

    rgba* mat = new rgba();
    mat->color = colorf::red();
    full_sep->add(mat);

    draw_style* ds = new draw_style;
    ds->style = draw_style::lines;
    ds->line_width = cursor_line_width;
    full_sep->add(ds);

    //m_cursor_matrix.mtx.value(old_mtx);
    full_sep->add(new noderef(m_cursor_matrix));

    vertices* vtcs = new vertices;

    vtcs->mode = gl::lines();

    if(cursor_model.value()==cursor_target) {
    
      float size = 0.1f;

      vtcs->add(-size, size,0);
      vtcs->add( size,-size,0);

      vtcs->add(-size,-size,0);
      vtcs->add( size, size,0);

    } else {

      float size = 0.2f;

      vtcs->add(0,-size,0);
      vtcs->add(0, size,0);

      vtcs->add(-size,0,0);
      vtcs->add( size,0,0);

/* various tentative definitly uglies.	
    } else {

      float hsq = 0.05f;

      // square :
      vtcs->add(-hsq,-hsq,0);
      vtcs->add( hsq,-hsq,0);

      vtcs->add( hsq,-hsq,0);
      vtcs->add( hsq, hsq,0);

      vtcs->add( hsq, hsq,0);
      vtcs->add(-hsq, hsq,0);

      vtcs->add(-hsq, hsq,0);
      vtcs->add(-hsq,-hsq,0);

      // lines to square :
      float end = 3*hsq;
      vtcs->add(-end,0,0);
      vtcs->add(-hsq,0,0);

      vtcs->add(end,0,0);
      vtcs->add(hsq,0,0);

      vtcs->add(0,end,0);
      vtcs->add(0,hsq,0);

      vtcs->add(0,-end,0);
      vtcs->add(0,-hsq,0);

    } else { //up_right_arrow

      float size = 0.2f;
      vtcs->add(   0,    0,0);
      vtcs->add(size,-size,0);

      vtcs->add(        0,0,0);
      vtcs->add(size*0.5f,0,0);

      vtcs->add(0,         0,0);
      vtcs->add(0,-size*0.5f,0);
*/
    }
    full_sep->add(vtcs);}

  }

public:
  void set_memory_warning(bool a_value) {m_memory_warning = a_value;}
  bool has_memory_warning() {return m_memory_warning;}

  //bool add_jpeg_read_work(const std::string& a_file) {    
  //  if(!m_jpeg_data.open(a_file)) return false;
  //  add_work(new jpeg_read_work(*this,m_jpeg_data));
  //  return true;
  //}
  ////////////////////////////////////////////
  /// menu tab navigation system /////////////
  ////////////////////////////////////////////
protected:
  ptrs_t base_buttons() {
    search_action action(m_out);
    action.set_class(base_button::s_class());
    m_gui.search(action);
    return action.objs();
  }
  base_button* get_tab_current() {
    ptrs_t btns = base_buttons();
    if(m_tab_current<0) return 0;
    if(m_tab_current>=(int)btns.size()) return 0;
    return (base_button*)btns[m_tab_current];
  }
public:
  bool do_tab(bool a_shift) {
    ptrs_t btns = base_buttons();
    unsigned int btnn = btns.size();
    if((m_tab_current>=0)&&(m_tab_current<(int)btnn)) {
      base_button* btn = (base_button*)btns[m_tab_current];
      btn->disarm();
    }

    //::printf("debug : do_tab : btnn %d current %d\n",btnn,m_tab_current);

    if(a_shift) { // go back.
      m_tab_current--;
      if(m_tab_current<0) m_tab_current = btnn-1;
    } else {
      m_tab_current++;
      if(m_tab_current>=(int)btnn) m_tab_current = 0;
    }

    bool to_render = false;
    if((m_tab_current>=0)&&(m_tab_current<(int)btnn)) {
      base_button* btn = (base_button*)btns[m_tab_current];
      btn->arm();
      btn->arm_color.touch();
      to_render = true;
    }
    return to_render;
  } 
  void do_return() {
    base_button* btn = get_tab_current(); 
    if(!btn) return;

    // ask to execute cbks by using the highly
    // protected ui::do_works.

    btn->disarm();

    add_work_cbks(btn->cbks().callbacks(),true);    

    m_tab_current--; //so that next tab be at same button position.
  } 

  void add_work_check_arm_buttons() {
    add_work(new check_arms_work(*this));
  }

public:
  ////////////////////////////////////////////
  /// common scenes //////////////////////////
  ////////////////////////////////////////////
  void visualize_text(const std::vector<std::string>& a_text,
    const std::vector<std::string>& a_rtext = std::vector<std::string>()) {

    hide_main_menu();
    clear_scene();
    if(!m_ww) return;
    if(!m_wh) return;
    if(a_text.empty()) return;

    // cam pos(0,0,1) near 0.1 far 10, primitives in xy plan.
    float cam_height = 2;
    float znear = 0.1f;
    base_camera* camera = create_camera(camera_ortho,cam_height,znear);
    if(!camera) return;

    separator* sep = new separator;
    m_scene.add(sep);

    camera->dx = cam_height/50.0f; //for 50 see touch_move.

    sep->add(camera);

    set_scene_camera(camera);
  
    rgba* mat = new rgba();
    mat->color = colorf::black();
    sep->add(mat);
  
    sep->add(new normal);

    matrix* m = new matrix;
    sep->add(m);
  
    float wcw,wch,aspect;
   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}

    infos_box* text = new infos_box(m_ttf);   
    text->width = wcw;
    text->back_visible = false;
    //text->hmargin_factor = 1.0f;
    //text->rhjust = left;
    text->font = gui_font();
    sep->add(text);

   {std::vector<std::string>::const_iterator it;
    for(it=a_text.begin();it!=a_text.end();++it) {
      text->lstrings.add(*it);
    }}

   {std::vector<std::string>::const_iterator it;
    for(it=a_rtext.begin();it!=a_rtext.end();++it) {
      text->rstrings.add(*it);
    }}

    text->update_sg(); //it sets text->height.

    mat4f& mtx = m->mtx.value();
    mtx.mul_translate(0,-text->height*0.5f+wch*0.5f,0);
  }

  void gui_text(const std::vector<std::string>& a_text){
    if(a_text.empty()) {
      map_warn_empty();
      return;
    }

    scroll_text* text = new scroll_text(m_ttf);
    text->font = gui_font();
    set_colors(*text);

   {std::vector<std::string>::const_iterator it;
    for(it=a_text.begin();it!=a_text.end();++it) {
      text->text.add(*it);
    }}

    push_list(text);
  }

  void gui_text(const std::vector<std::string>& a_ltext,
                const std::vector<std::string>& a_rtext) {

    if(a_ltext.empty()) {
      map_warn_empty();
      return;
    }
    if(a_ltext.size()!=a_rtext.size()) {
      map_warn("size mismatch");
      return;
    }

    scroll_infos* text = new scroll_infos(m_ttf);
    text->font = gui_font();
    set_colors(*text);

   {std::vector<std::string>::const_iterator it;
    for(it=a_ltext.begin();it!=a_ltext.end();++it) {
      text->ltext.add(*it);
    }}
   {std::vector<std::string>::const_iterator it;
    for(it=a_rtext.begin();it!=a_rtext.end();++it) {
      text->rtext.add(*it);
    }}

    push_list(text);
  }

  base_camera* create_3D_camera(float a_radius){
    float cam_pos = 2*a_radius;
    float znear = 0.1f*a_radius;
    float near_height = 2 * znear * (a_radius/cam_pos);

    base_camera* camera =
      create_camera(camera_perspective,near_height,znear);
    if(!camera) {
      m_out << "inlib::sg::gui_viewer::create_3D_camera :"
            << " create_camera failed."
            << std::endl;
      return 0;
    }

    camera->zfar = 10*a_radius;
    camera->position = vec3f(0,0,cam_pos);
    camera->focal = cam_pos;

    camera->dx = 2.0f*a_radius/100.0f;
    //camera->da = camera->da.value()/2;

    return camera;
  }

  base_camera* create_2D_camera(float a_height) { //for image, plots
    float z = 10*a_height;
    float znear = 0.1f*z;
    base_camera* cam = create_camera(camera_ortho,a_height,znear);
    if(!cam) {
      m_out << "inlib::sg::gui_viewer::create_2D_camera :"
            << " create_camera failed."
            << std::endl;
      return 0;
    }
    cam->zfar = 10*z;
    cam->position = vec3f(0,0,z);
    cam->orientation = rotf(vec3f(0,0,1),0);
    cam->focal = z;
    cam->dx = a_height/100.0f;
    return cam;
  }
  base_camera* create_camera(base_camera& a_cam){
    base_camera* camera = 0;
    if(safe_cast<node,ortho>(a_cam)) {
      camera = create_camera(camera_ortho,a_cam.near_height(),a_cam.znear);
    } else if(safe_cast<node,perspective>(a_cam)){
      camera =
        create_camera(camera_perspective,a_cam.near_height(),a_cam.znear);
    }
    if(!camera) return 0;    

    camera->zfar = a_cam.zfar;
    camera->position = a_cam.position;
    camera->orientation = a_cam.orientation;

    camera->dx = a_cam.dx;
    camera->da = a_cam.da;
    camera->ds = a_cam.ds;
    camera->focal = a_cam.focal;

    return camera;
  }

public:
  bool do_key(key_move a_key,bool a_shift,bool a_ctrl) {
    if(a_ctrl) {

      if(cam_anim_is_running()) {
        stop_cam_anim();

      } else {

        anim_what anim = anim_left;
        if(a_key==key_left)
          anim = anim_left;
        else if(a_key==key_right)
          anim = anim_right;
        else if(a_key==key_up)
          anim = anim_up;
        else if(a_key==key_down)
          anim = anim_down;

        // do we want to change things in the cam panel ?
        // Huum, yes as long as m_params.m_anim_shift
        // belongs to gui_viewer.
        set_param_anim_shift(a_shift);

        start_cam_anim(anim,a_shift,m_params.m_cycle_secs);
      }
      return false; //do not render.

    } else {
      if(a_key==key_left)
        update_anim_motion(anim_left,a_shift);
      else if(a_key==key_right)
        update_anim_motion(anim_right,a_shift);
      else if(a_key==key_up)
        update_anim_motion(anim_up,a_shift);
      else if(a_key==key_down)
        update_anim_motion(anim_down,a_shift);

      return true; //to render.
    }
  } 

public: //for rwc_gui
  class gui_cbk : public ecbk {
    typedef sg::gui_viewer gv_t;

    INLIB_CLASS_STRING(ui_style)

  public:
    // gui navigation :
    static unsigned int action_home()         {return 0;}    
    static unsigned int action_back()         {return 1;}    
    static unsigned int action_meta_zone()    {return 2;}    
    static unsigned int action_last()         {return 3;}    
    // camenu :
    static unsigned int action_single_shoot()      {return 4;}
    static unsigned int action_90()                {return 5;}
    static unsigned int action_anim_shift()        {return 6;}
    static unsigned int action_anim_around_focal() {return 7;}
    static unsigned int action_viewing()           {return 8;}
  
    static unsigned int action_reset_camera() {return 9;}    
    static unsigned int action_left()         {return 10;}
    static unsigned int action_right()        {return 11;}
    static unsigned int action_up()           {return 12;}
    static unsigned int action_down()         {return 13;}
    static unsigned int action_hide_camenu()  {return 14;}
    static unsigned int action_show_camenu()  {return 15;}
    // params :
    static unsigned int action_params_show()  {return 16;}
    static unsigned int action_params_ok()    {return 17;}
    // camed :
    static unsigned int action_cam_choose_type() {return 18;}
    static unsigned int action_cam_set_type()    {return 19;}
    static unsigned int action_cam_set_params()  {return 20;}

    // in list menus :
    static unsigned int action_clear_scene()             {return 21;}
    static unsigned int action_start_anim_around_focal() {return 23;}
  //static unsigned int action_delete_manips()           {return 24;}
  
    static unsigned int action_touch_down()     {return 25;}
    static unsigned int action_touch_up()       {return 26;}
    static unsigned int action_touch_move()     {return 27;}
  
    static unsigned int action_plane_exam()     {return 28;}
  
  //static unsigned int action_toggle_sliders() {return xxx;}
  
    static unsigned int action_adapt_camera()    {return 29;}
    static unsigned int action_cam_choose_anim() {return 30;}
    static unsigned int action_cam_set_anim()    {return 31;}

    static unsigned int action_count_points()    {return 32;}
    static unsigned int action_toggle_light()    {return 33;}
    static unsigned int action_toggle_gsto()     {return 34;}

    //for rwc and special cam anims :
    static unsigned int action_cam_anim_zoom_in_out()     {return 40;}
    static unsigned int action_cam_anim_zoom_in_out_rot() {return 41;}

  public:
    virtual return_action action() {
      ///////////////////////////////////////////
      /// gui events ////////////////////////////
      ///////////////////////////////////////////
      if(m_action==action_touch_down()){

        if(m_node) {
          if(base_button* btn = safe_cast<node,base_button>(*m_node)){
            m_gv.arm_button(btn);
            m_event_action->set_done(true);
            return return_none;
            
          } else if(slider* sd = safe_cast<node,slider>(*m_node)){
            m_gv.add_work_cbks(sd->begs(),true);    
            m_event_action->set_done(true);
            return return_none;
          }
        }

      } else if(m_action==action_touch_up()){

        if(m_node) {
          if(base_button* btn = safe_cast<node,base_button>(*m_node)){
            m_gv.trigger_button(btn);
            m_event_action->set_done(true);
            return return_none;
  
          } else if(slider* sd = safe_cast<node,slider>(*m_node)){
            m_gv.add_work_cbks(sd->ends(),true);    
            m_event_action->set_done(true);
            return return_none;
  
          } else if(ghost* gh = safe_cast<node,ghost>(*m_node)){

            //m_out << "inlib::sg::gui_viewer::touch_up :" 
            //      << " pick ghost."
            //      << std::endl;

            m_gv.add_work_cbks(gh->cbks().callbacks(),true);    
            m_event_action->set_done(true);
            return return_none;
  
          }
        }
  
      } else if(m_action==action_touch_move()){

        if(m_node) {
          if(slider* sd = safe_cast<node,slider>(*m_node)){

            // we have to update the slider pos :
            if(move_event* mevt = safe_cast<event,move_event>(*m_event)){
              sd->set_value(m_event_action->saved_state(),*mevt);
            }

            m_gv.add_work_cbks(sd->drags(),true);    
  
            m_gv.m_motion_slider = sd;

            m_event_action->set_done(true);
            return return_none;
  
          }
        }
  
      ///////////////////////////////////////////
      /// gui navigation ////////////////////////
      ///////////////////////////////////////////
      } else if(m_action==action_home()){
        m_gv.push_home();
      } else if(m_action==action_back()){
        m_gv.push_back_item();
      } else if(m_action==action_meta_zone()){
        m_gv.activate_meta_zone();
      } else if(m_action==action_last()){
        m_gv.pop_list();

      ///////////////////////////////////////////
      /// camenu ////////////////////////////////
      ///////////////////////////////////////////
      } else if(m_action==action_reset_camera()){
        m_gv.reset_camera();

      } else if( (m_action==action_left()) || 
                 (m_action==action_right()) || 
                 (m_action==action_up()) || 
                 (m_action==action_down()) ){

        //m_gv.stop_cam_anim(); //???

        if(m_gv.m_params.m_90 && !m_gv.m_params.m_plane_viewer) {
          if(m_action==action_left()) {
            m_gv.m_scene_camera->rotate_around_y_at_focal(-fhalf_pi());
          } else if(m_action==action_right()) {     
            m_gv.m_scene_camera->rotate_around_y_at_focal(fhalf_pi());

          } else if(m_action==action_up()) {
            m_gv.m_scene_camera->rotate_around_x_at_focal(-fhalf_pi());
          } else if(m_action==action_down()) {     
            m_gv.m_scene_camera->rotate_around_x_at_focal(fhalf_pi());
          }

          return return_to_render;     
        }

        if(m_gv.m_params.m_single_shoot) {

               if(m_action==action_left())
            m_gv.update_anim_motion(anim_left,m_gv.m_params.m_anim_shift);
          else if(m_action==action_right())
            m_gv.update_anim_motion(anim_right,m_gv.m_params.m_anim_shift);
          else if(m_action==action_up())
            m_gv.update_anim_motion(anim_up,m_gv.m_params.m_anim_shift);
          else if(m_action==action_down())
            m_gv.update_anim_motion(anim_down,m_gv.m_params.m_anim_shift);


        } else {

          if(m_gv.cam_anim_is_running()) {

            m_gv.stop_cam_anim();

          } else {
             
            anim_what anim = anim_left;

            if(m_action==action_left())
              anim = anim_left;
            else if(m_action==action_right())
              anim = anim_right;
            else if(m_action==action_up())
              anim = anim_up;
            else if(m_action==action_down())
              anim = anim_down;

            m_gv.start_cam_anim(anim,
                                m_gv.m_params.m_anim_shift,
                                m_gv.m_params.m_cycle_secs);

          }
        }

      } else if(m_action==action_single_shoot()) {
        m_gv.toggle_param_single_shoot();
      } else if(m_action==action_90()) {
        m_gv.toggle_param_90();
      } else if(m_action==action_anim_shift()) {
        m_gv.toggle_param_anim_shift();
      } else if(m_action==action_anim_around_focal()) {
        m_gv.toggle_param_anim_around_focal();
      } else if(m_action==action_viewing()) {
        m_gv.toggle_param_viewing();

      } else if(m_action==action_hide_camenu()) {
        m_gv.hide_camera_menu();

      } else if(m_action==action_show_camenu()) {

        m_gv.show_camera_menu();

      } else if(m_action==action_plane_exam()) {
        m_gv.set_plane_viewer(m_gv.plane_viewer()?false:true);
        m_gv.set_camera_menu_labels();

      ///////////////////////////////////////////
      /// params ////////////////////////////////
      ///////////////////////////////////////////
      } else if(m_action==action_params_show()) {
        entries* node = new entries(m_gv.m_ttf);
        node->entry_label_result_factor = 0.7f;

        std::vector<std::string> modes;
        m_gv.m_gl_mgr.available_gsto_modes(modes);
        params2entries(m_gv.m_params,*node,m_gv.is_wall_screen_app(),modes);

       {std::vector<std::string> opts;
        opts.push_back(s_camera_ortho());
        m_gv.m_styles.find_styles("gui_*",opts);
        opts.push_back(s_default());
        node->add_opts(s_ui_style(),m_gv.m_gui_style,opts);}

        gui_cbk* _cbk = new gui_cbk(m_gv,action_params_ok());
        _cbk->m_entries = node;
        node->add_callback(_cbk);
  
        m_gv.set_colors(*node);
   
        m_gv.push_list(node);

      } else if(m_action==action_params_ok()) {

        std::string ui_style;

        std::vector<arg> args;
        const std::vector<std::string>& labs = m_entries->labels.values();
        const std::vector<std::string>& vals = m_entries->values.values();
        for(unsigned int index=0;index<labs.size();index++) {
          const std::string& lab = labs[index];
          const std::string& val = vals[index];
          if(lab==s_ui_style()) {
            ui_style = val;
          } else {
            args.push_back(arg(lab,val));
          }
        }

        if(!m_gv.args2params(args,true)) {
          return return_to_render;     
        }

        if(ui_style.size()&&(ui_style!=m_gv.m_gui_style)) {
          // if style changed, it override m_params.m_image_buttons.
          if(ui_style==s_default()) {
            m_gv.m_params.set_gui_default();
          } else {
            m_gv.set_gui_style(ui_style);
          }
          m_gv.push_home(); //to reset style of central menu.
        }

      ///////////////////////////////////////////
      /// list menu : ///////////////////////////
      ///////////////////////////////////////////
      } else if(m_action==action_clear_scene()) {
        m_gv.clear_scene();

      } else if(m_action==action_start_anim_around_focal()) {
        m_gv.start_anim_around_focal();

    //} else if(m_action==action_delete_manips()) {
    //  m_gv.delete_manips();

    //} else if(m_action==action_toggle_sliders()) {
    //    m_gv.toggle_sliders();

      } else if(m_action==action_adapt_camera()) {
        if(!m_gv.adapt_camera(m_gv.scene())) {
          m_gv.map_warn("adapt failed");
          return return_to_render;     
        }
 
      } else if(m_action==action_count_points()) {
        m_gv.count_points();
      } else if(m_action==action_toggle_light()) {
        m_gv.set_scene_light_on(m_gv.m_params.m_light_on?false:true);
      } else if(m_action==action_toggle_gsto()) {
        m_gv.set_use_gsto(m_gv.m_params.m_use_gsto?false:true);
 
      ///////////////////////////////////////////
      /// camed : ///////////////////////////////
      ///////////////////////////////////////////
      } else if(m_action==action_cam_choose_type()) {

        if(m_gv.m_params.m_camera_type.empty()) {
          m_gv.map_warn("no camera");
          return return_to_render;     
        }

        entries* _entries = new entries(m_gv.m_ttf);
        _entries->label = "camera";
        m_gv.set_colors(*_entries);

        std::vector<std::string> opts;
        opts.push_back(s_camera_ortho());
        opts.push_back(s_camera_perspective());
        _entries->add_opts("kind",m_gv.m_params.m_camera_type,opts);

        gui_cbk* _cbk = new gui_cbk(m_gv,action_cam_set_type());
        _cbk->m_entries = _entries;
        _entries->add_callback(_cbk);

        m_gv.push_list(_entries);

        m_gv.show_main_menu(); //needed if triggered from cam panel.

      } else if(m_action==action_cam_set_type()) {

        base_camera* cam = m_gv.scene_camera();
        if(!cam) {
          m_gv.map_warn("no camera found.");
          return return_to_render;     
        }
  
        //change cam class if needed and present entries for params.
        
        base_camera* new_cam = 0;
  
        std::string skind = m_entries->values[0];
        //m_gv.out() << "choosen class " << scls << std::endl;
        if(skind.size() && m_gv.m_params.m_camera_type.size() &&
           (skind!=m_gv.m_params.m_camera_type)) {
  
          // look first if we can find back the cam in the scene sg :
  
          search_action sa(m_gv.out());

          group* grp = find_container<group>(m_gv.out(),
                                             m_gv.scene(),cam,m_gv.verbose());
          if(!grp) {
            m_gv.map_warn("search of camera parent failed.");
            return return_to_render;     
          }          

          if(!m_gv.swap_camera_kind()) {
            m_gv.map_warn("swap camera kind failed");
            return return_to_render;     
          } 
          new_cam = m_gv.scene_camera();

          if(!grp->replace(cam,new_cam,true)) {
            m_gv.map_warn("replace camera failed");
            return return_to_render;     
          }
  
        } else {
          new_cam = cam;
        }
  
        entries* _entries = new entries(m_gv.m_ttf);
        _entries->label = "camera";
        m_gv.set_colors(*_entries);
  
        _entries->add_float("x",new_cam->position.value().x());    //0
        _entries->add_float("y",new_cam->position.value().y());    //1
        _entries->add_float("z",new_cam->position.value().z());    //2
       {std::string s;
        if(!tos(new_cam->orientation.value(),s)) s = "0 1 0 0";
        _entries->add_string("orientation",s);}                    //3
        _entries->add_float("near",new_cam->znear.value());        //4
        _entries->add_float("far",new_cam->zfar.value());          //5
        _entries->add_float("focal",new_cam->focal.value());       //6
        _entries->add_float("dx",new_cam->dx.value());             //7
        _entries->add_float("da (deg)",new_cam->da.value()/fdeg2rad());     //8
        _entries->add_float("ds (for zoom)",new_cam->ds.value());  //9
        if(m_gv.is_wall_screen_app()) {
          _entries->add_float("zoom out",1);     //10
        } else {
          if(ortho* oc =
             safe_cast<node,ortho>(*new_cam)){
            _entries->add_float("height",oc->height.value()); //10
          } else if(perspective* pc = 
             safe_cast<node,perspective>(*new_cam)){
            _entries->add_float("height angle (deg)",
                            pc->height_angle.value()/fdeg2rad()); //10
          } else {
            m_gv.map_warn("unhandled camera type");
            return return_to_render;     
          }
        }
  
        gui_cbk* _cbk = new gui_cbk(m_gv,action_cam_set_params());
        _cbk->m_entries = _entries;
        _entries->add_callback(_cbk);
  
        m_gv.push_list(_entries);

      } else if(m_action==action_cam_choose_anim()) {

        if(m_gv.m_params.m_camera_type.empty()) {
          m_gv.map_warn("no camera");
          return return_to_render;     
        }

        entries* _entries = new entries(m_gv.m_ttf);
        _entries->label = "camera anim";
        m_gv.set_colors(*_entries);

        std::vector<std::string> opts;
        opts.push_back(s_zoom_in_out());
        opts.push_back(s_zoom_in_out_rot());
        _entries->add_opts("anim",s_zoom_in_out(),opts);

        _entries->add_uint("cycle (secs)",10);

        gui_cbk* _cbk = new gui_cbk(m_gv,action_cam_set_anim());
        _cbk->m_entries = _entries;
        _entries->add_callback(_cbk);

        m_gv.push_list(_entries);

        m_gv.show_main_menu(); //needed if triggered from cam panel.

      } else if(m_action==action_cam_set_anim()) {

        base_camera* cam = m_gv.scene_camera();
        if(!cam) {
          m_gv.map_warn("no camera found.");
          return return_to_render;     
        }
  
        std::string sanim = m_entries->values[0];

        unsigned int cycle;
        if(!m_gv.tow<unsigned int>(m_entries->values[1],cycle))
          return return_to_render;     

        if(sanim==s_zoom_in_out()) {
          m_gv.start_cam_move(move_zoom_in_out,cycle);
          m_gv.hide_main_menu();
        } else if(sanim==s_zoom_in_out_rot()) {
          m_gv.start_cam_move(move_zoom_in_out_rot,cycle);
          m_gv.hide_main_menu();
        } else {
          m_gv.map_warn("unknown anim.");
        }

      } else if(m_action==action_cam_anim_zoom_in_out()) {     //from rwc.
        m_gv.start_cam_move(move_zoom_in_out,m_gv.m_params.m_cycle_secs);
        m_gv.hide_main_menu();
      } else if(m_action==action_cam_anim_zoom_in_out_rot()) { //from rwc.
        m_gv.start_cam_move(move_zoom_in_out_rot,m_gv.m_params.m_cycle_secs);
        m_gv.hide_main_menu();

      } else if(m_action==action_cam_set_params()) {

        base_camera* cam = m_gv.scene_camera();
        if(!cam) {
          m_gv.map_warn("no camera found.");
          return return_to_render;     
        }
  
       {float x;
        if(!m_gv.tow<float>(m_entries->values[0],x)) return return_to_render;
        float y;
        if(!m_gv.tow<float>(m_entries->values[1],y)) return return_to_render;
        float z;
        if(!m_gv.tow<float>(m_entries->values[2],z)) return return_to_render;  
        cam->position.value().set_value(x,y,z);}
  
        if(!sqrot<float>(m_entries->values[3],cam->orientation.value()))
          return return_to_render;

       {float v;
        if(!m_gv.tow<float>(m_entries->values[4],v)) return return_to_render;
        if(v<=0) {
          m_gv.map_warn("must be >0");
          return return_to_render;     
        }
        cam->znear = v;}
  
       {float v;
        if(!m_gv.tow<float>(m_entries->values[5],v)) return return_to_render;
        if(v<=0) {
          m_gv.map_warn("must be >0");
          return return_to_render;     
        }
        if(v<=cam->znear.value()) {
          m_gv.map_warn("far must be > near");
          return return_to_render;     
        }
        cam->zfar = v;}
  
       {float v;
        if(!m_gv.tow<float>(m_entries->values[6],v)) return return_to_render;
        if(v<=0) {
          m_gv.map_warn("must be >0");
          return return_to_render;     
        }
        cam->focal = v;}
  
       {float v;
        if(!m_gv.tow<float>(m_entries->values[7],v)) return return_to_render;
        if(v<=0) {
          m_gv.map_warn("must be >0");
          return return_to_render;     
        }
        cam->dx = v;}
  
       {float v;
        if(!m_gv.tow<float>(m_entries->values[8],v)) return return_to_render;
        if(v<=0) {
          m_gv.map_warn("must be >0");
          return return_to_render;     
        }
        cam->da = v*fdeg2rad();}
  
       {float v;
        if(!m_gv.tow<float>(m_entries->values[9],v)) return return_to_render;
        if(v<=0) {
          m_gv.map_warn("must be >0");
          return return_to_render;     
        }
        cam->ds = v;}
  
        if(m_gv.is_wall_screen_app()) {
          float v;
          if(!m_gv.tow<float>(m_entries->values[10],v)) return return_to_render;
          if(v<=0) {
            m_gv.map_warn("must be >0");
            return return_to_render;     
          }
          cam->zoom(v);
        } else {
          float v;
          if(!m_gv.tow<float>(m_entries->values[10],v)) return return_to_render;
          if(v<=0) {
            m_gv.map_warn("must be >0");
            return return_to_render;     
          }
          if(ortho* oc = safe_cast<node,ortho>(*cam)) {
            oc->height = v;
          } else if(perspective* pc = safe_cast<node,perspective>(*cam)) {
            pc->height_angle = v*fdeg2rad();   
          }
        }
  
        m_gv.hide_main_menu();
  
      } else {
        m_gv.map_warn("gui_cbk : unknown action");
      }
      return return_to_render;     
    }
    virtual bcbk* copy() const {return new gui_cbk(*this);}
  public:
    gui_cbk(gv_t& a_gv,unsigned int a_action)
    :ecbk(a_action)
    ,m_gv(a_gv)
    ,m_entries(0)
    {
#ifdef INLIB_MEM
      mem::increment(s_class().c_str());
#endif
    }
    virtual ~gui_cbk(){
#ifdef INLIB_MEM
      mem::decrement(s_class().c_str());
#endif
    }
  protected:
    gui_cbk(const gui_cbk& a_from)
    :ecbk(a_from)
    ,m_gv(a_from.m_gv)
    ,m_entries(a_from.m_entries)
    { 
#ifdef INLIB_MEM
      mem::increment(s_class().c_str());
#endif
    }
    gui_cbk& operator=(const gui_cbk& a_from){
      ecbk::operator=(a_from);
      m_entries = a_from.m_entries;
      return *this;
    }
  protected:
    INLIB_SCLASS(inlib::sg::gui_viewer::gui_cbk)
  protected:
    gv_t& m_gv;
    entries* m_entries;
  };

protected:

  ////////////////////////////////////////////////////
  /// works //////////////////////////////////////////
  ////////////////////////////////////////////////////

  class check_arms_work : public bcbk {
  public:
    virtual return_action action() {
      std::vector<base_button*>::iterator it;
      for(it=m_gv.m_arm_buttons.begin();it!=m_gv.m_arm_buttons.end();++it) {
        if(m_gv.search_button(*it)){
          (*it)->disarm();
          (*it)->arm_color.touch(); //touch something.
        }
      }    
      m_gv.m_arm_buttons.clear();
      return return_to_render;     
    }
    virtual bcbk* copy() const {return new check_arms_work(*this);}
  public:
    check_arms_work(gui_viewer& a_gv):bcbk(),m_gv(a_gv) {
      m_single_shoot = true;
    }
    virtual ~check_arms_work(){}
  public:
    check_arms_work(const check_arms_work& a_from)
    :bcbk(a_from),m_gv(a_from.m_gv){}
    check_arms_work& operator=(const check_arms_work& a_from){
      bcbk::operator=(a_from);
      return *this;
    }
  protected:
    gui_viewer& m_gv;
  };

  class arm_work : public bcbk {
    INLIB_HEADER_COPY(arm_work,inlib::sg::gui_viewer::arm_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //WARNING : m_button could have been deleted by some cbk.
      //          (Case of a timer work that would do an indirect gui_visible.touch()
      //           which would induce a delete of buttons in the win_render() -> render()
      //           and then check_gui_curosr()).
      //if(m_gv.search_button(m_button)){
        m_button->arm();
        m_button->arm_color.touch(); //touch something.
      //} else {
      //  m_gv.out() << "arm_work : warning : anomaly : button does not exist." << std::endl;
      //}
      return return_to_render;     
    }
  public:
    arm_work(gui_viewer& a_gv,base_button* a_button)
    :parent()
    ,m_gv(a_gv)
    ,m_button(a_button)
    {
      m_single_shoot = true;
    }
    virtual ~arm_work(){}
  public:
    arm_work(const arm_work& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    ,m_button(a_from.m_button)
    {}
    arm_work& operator=(const arm_work& a_from){
      parent::operator=(a_from);
      m_button = a_from.m_button;
      return *this;
    }
  protected:
    gui_viewer& m_gv;
    base_button* m_button;
  };

  class disarm_work : public bcbk {
    INLIB_HEADER_COPY(disarm_work,inlib::sg::gui_viewer::disarm_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //WARNING : m_button could have be deleted by some cbk.
      //if(m_gv.search_button(m_button)){
        m_button->disarm();
        m_button->arm_color.touch(); //touch something.
      //} else {
      //  m_gv.out() << "disarm_work : warning : anomaly : button does not exist." << std::endl;
      //}
      return return_to_render;     
    }
  public:
    disarm_work(gui_viewer& a_gv,base_button* a_button)
    :parent()
    ,m_gv(a_gv)
    ,m_button(a_button)
    {
      m_single_shoot = true;
    }
    virtual ~disarm_work(){}
  public:
    disarm_work(const disarm_work& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    ,m_button(a_from.m_button)
    {}
    disarm_work& operator=(const disarm_work& a_from){
      parent::operator=(a_from);
      m_button = a_from.m_button;
      return *this;
    }
  protected:
    gui_viewer& m_gv;
    base_button* m_button;
  };


  class anim_work : public bcbk {
    INLIB_HEADER_COPY(anim_work,inlib::sg::gui_viewer::anim_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //m_gv.out() << "debug : anim_work::action" << std::endl;
      if(m_gv.treat_anim(atime::now())) return return_to_render;     
      return return_none;     
    }
  public:
    anim_work(gui_viewer& a_gv)
    :bcbk()
    ,m_gv(a_gv)
    {}
    virtual ~anim_work(){}
  public:
    anim_work(const anim_work& a_from)
    :bcbk(a_from)
    ,m_gv(a_from.m_gv)
    {}
    anim_work& operator=(const anim_work& a_from){
      bcbk::operator=(a_from);
      return *this;
    }
  protected:
    gui_viewer& m_gv;
  };

protected:
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  typedef std::map<std::string,cbk::tag*> dumpers_t;
  void copy_dumpers(dumpers_t& a_to,const dumpers_t& a_from){
    raw_clear<std::string,cbk::tag>(a_to);
    dumpers_t::const_iterator it;
    for(it=a_from.begin();it!=a_from.end();++it) {
      cbk::tag* cbk;
      (*it).second->cp(cbk);
      a_to[(*it).first] = cbk;
    }
  }
public:
  const dumpers_t& dumpers() const {return m_dumpers;}
  dumpers_t& dumpers() {return m_dumpers;}
  bool exec_dumper(const std::string& a_name,const std::string& a_tag) {
    dumpers_t::const_iterator it = m_dumpers.find(a_name);
    if(it==m_dumpers.end()) return false;
    cbk::tag* cbk;
    (*it).second->cp(cbk);
    cbk->m_tag = a_tag;
    cbk->action();
    delete cbk;
    return true;
  }

  bool add_popup_dumper(const std::string& a_name,
                        const std::vector<std::string>& a_v) {
    dumpers_t::const_iterator it = m_dumpers.find(a_name);
    if(it!=m_dumpers.end()) return false; //done
    m_dumpers[a_name] = new popup_dumper(*this,a_v);
    return true;
  }
protected:

  void check_gui_cursor() {
    if(gui_visible.touched()){
      create_gui();
      gui_visible.reset_touched();
    }

    if( cursor_visible.touched()    ||
        cursor_line_width.touched() ||
        cursor_model.touched()      ){
      //m_out << "debug : inlib::sg::gui_viewer::render : create_cursor."
      //      << std::endl;
      create_cursor();
      cursor_visible.reset_touched();
      cursor_line_width.reset_touched();
      cursor_model.reset_touched();
    }
  }
protected:
  bool search_button(base_button* a_node) {
    search_action action(m_out);
    action.set_class(base_button::s_class());
    m_gui.search(action);
    const ptrs_t& objs = action.objs();
    ptrs_t::const_iterator it;
    for(it=objs.begin();it!=objs.end();++it) {
      if(a_node==(*it)) return true;
    }    
    return false;    
  }
protected:
  class popup_dumper : public cbk::tag {
    typedef sg::gui_viewer gv_t;
  public:
    virtual bcbk* copy() const {return new popup_dumper(*this);}
    virtual bool cp(cbk::tag*& a_o) const {
      a_o = new popup_dumper(*this);
      return true;
    }
  public:
    virtual return_action action() {
      separator& psep = m_gv.popup_sep();
      list& _list = *((list*)psep.children().back());
      std::vector<std::string>::const_iterator it;
      for(it=m_infos.begin();it!=m_infos.end();++it){
        _list.add(*it,new inlib::cbk::none());
      }
      return return_to_render;
    }
  public:
    popup_dumper(gv_t& a_gv,const std::vector<std::string>& a_infos)
    :cbk::tag()
    ,m_gv(a_gv)
    ,m_infos(a_infos)
    {}
    virtual ~popup_dumper(){}
  public:
    popup_dumper(const popup_dumper& a_from)
    :cbk::tag(a_from)
    ,m_gv(a_from.m_gv)
    ,m_infos(a_from.m_infos)
    {}
    popup_dumper& operator=(const popup_dumper& a_from){
      cbk::tag::operator=(a_from);
      m_infos = a_from.m_infos;
      return *this;
    }
  protected:
    gv_t& m_gv;
    std::vector<std::string> m_infos;
  };

protected:
  gl_manager& m_gl_mgr;
  const base_freetype& m_ttf;

  selection m_scene;
  selection m_backup_scene;

  base_camera* m_scene_camera;
  node* m_reset_camera;
  torche* m_scene_light;

  selection m_gui;

  separator m_full_sep;

  _switch m_scene_switch;
  _switch m_main_menu_switch;
  _switch m_camenu_switch;
  separator m_camenu_sep;

  text_button m_camenu_shift_button;
  image_button m_camenu_sshoot_image_button;
  text_button m_camenu_sshoot_text_button;
  image_button m_camenu_90_image_button;
  text_button m_camenu_90_text_button;
  text_button m_camenu_focal_button;  
  text_button m_camenu_viewing_button;  
  text_button m_camenu_gsto_button;  
  text_button m_camenu_plane_exam_button;

  _switch m_gui_sliders_switch;
  _switch m_sliders_switch;
  matrix m_slider_1_matrix;
  matrix m_slider_2_matrix;
  matrix m_slider_3_matrix;
  matrix m_slider_4_matrix;
  slider m_slider_1;
  slider m_slider_2;
  slider m_slider_3;
  slider m_slider_4;
  separator m_hide_sliders_sep;
  matrix m_hide_sliders_matrix;

  _switch m_console_switch;
  matrix m_console_matrix;
  text_button m_console;

  _switch m_popup_switch;
  separator m_popup_sep;
  matrix m_popup_matrix;
  sg::cbks m_popup_cbks;

  _switch m_progress_switch;
  sg::progress m_progress;

  bool m_meta_had_been_shown;
  _switch m_meta_switch;

  std::vector<base_button*> m_tab_buttons;
  int m_tab_current; //could be (-1)
 
  std::vector<base_button*> m_arm_buttons;

  bool m_touch_in_motion; // X11, Android :
  int m_touch_prev_x;
  int m_touch_prev_y;

  unsigned int m_gesture_begin_x;
  unsigned int m_gesture_begin_y;
  node* m_gesture_begin_camera;

  slider* m_motion_slider;

  bool m_treat_mouse_motion;

  //wall :
  separator m_cursor;
  _switch m_cursor_switch;
  base_camera* m_cursor_camera;
  matrix m_cursor_matrix;

  bool m_memory_warning;
  group m_tmp_group; //to deposit sg::holder to data.

  zip_func m_zip_func;
  unzip_func m_unzip_func;
  action_prots_t m_action_prots;
  //end wall.

  dumpers_t m_dumpers;  
  inlib::opener m_opener;
};

inline gui_viewer* cast_gui_viewer(viewer& a_viewer) {
  return safe_cast<viewer,gui_viewer>(a_viewer);
}

template <class WIDGET>
class funtag_cbk : public bcbk {
  INLIB_T_CBK(WIDGET,funtag_cbk,inlib::sg::funtag_cbk,bcbk)
public:
  typedef bcbk::return_action (*cbk_func)(sg::gui_viewer&,const bcbk&,WIDGET&,void*);
public:
  virtual return_action action() {return m_func(m_gv,*this,m_widget,m_tag);}
public:
  funtag_cbk(gui_viewer& a_gv,WIDGET& a_widget,cbk_func a_func,void* a_tag)
  :parent()
  ,m_gv(a_gv),m_widget(a_widget)
  ,m_func(a_func),m_tag(a_tag)
  {}
  virtual ~funtag_cbk(){}
public:
  funtag_cbk(const funtag_cbk& a_from)
  :parent(a_from)
  ,m_gv(a_from.m_gv),m_widget(a_from.m_widget)
  ,m_func(a_from.m_func),m_tag(a_from.m_tag)
  {}
  funtag_cbk& operator=(const funtag_cbk& a_from){
    parent::operator=(a_from);
    m_func=a_from.m_func;
    m_tag=a_from.m_tag;
    return *this;
  }
protected:
  gui_viewer& m_gv;
  WIDGET& m_widget;
  cbk_func m_func;
  void* m_tag;
};

template <class WIDGET>
class funtag_ecbk : public ecbk {
  INLIB_T_CBK(WIDGET,funtag_ecbk,inlib::sg::funtag_ecbk,ecbk)
public:
  typedef bcbk::return_action (*cbk_func)(sg::gui_viewer&,const ecbk&,WIDGET&,void*);
public:
  virtual return_action action() {return m_func(m_gv,*this,m_widget,m_tag);}
public:
  funtag_ecbk(gui_viewer& a_gv,WIDGET& a_widget,cbk_func a_func,void* a_tag)
  :parent()
  ,m_gv(a_gv),m_widget(a_widget)
  ,m_func(a_func),m_tag(a_tag)
  {}
  virtual ~funtag_ecbk(){}
public:
  funtag_ecbk(const funtag_ecbk& a_from)
  :parent(a_from)
  ,m_gv(a_from.m_gv),m_widget(a_from.m_widget)
  ,m_func(a_from.m_func),m_tag(a_from.m_tag)
  {}
  funtag_ecbk& operator=(const funtag_ecbk& a_from){
    parent::operator=(a_from);
    m_func=a_from.m_func;
    m_tag=a_from.m_tag;
    return *this;
  }
protected:
  gui_viewer& m_gv;
  WIDGET& m_widget;
  cbk_func m_func;
  void* m_tag;
};

inline void add_label_item(gui_viewer& a_gv,list& a_list,
                           const std::string& a_label,
                           bcbk::return_action (*a_func)(gui_viewer&,const bcbk&,list&,void*),void* a_tag = 0){
  a_list.add(a_label,new funtag_cbk<list>(a_gv,a_list,a_func,a_tag));
}

inline void add_image_item(gui_viewer& a_gv,list& a_list,
                           const std::string& a_label,const std::string& a_img_file,
                           bcbk::return_action (*a_func)(gui_viewer&,const bcbk&,list&,void*),void* a_tag = 0){
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_file(a_gv.out(),a_gv.res_dir(),a_img_file,img)) {
      a_list.add(a_label,img,new funtag_cbk<list>(a_gv,a_list,a_func,a_tag));
    } else {
      a_list.add(a_label,new funtag_cbk<list>(a_gv,a_list,a_func,a_tag));
    }
  } else {
    a_list.add(a_label,new funtag_cbk<list>(a_gv,a_list,a_func,a_tag));
  }
}

inline void add_white_item(gui_viewer& a_gv,list& a_list,
                           const std::string& a_label,
                           bcbk::return_action (*a_func)(gui_viewer&,const bcbk&,list&,void*),void* a_tag = 0){
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_file(a_gv.out(),a_gv.res_dir(),s_white_jpg(),img)) {
      a_list.add(a_label,img,new funtag_cbk<list>(a_gv,a_list,a_func,a_tag));
    } else {
      a_list.add(a_label,new funtag_cbk<list>(a_gv,a_list,a_func,a_tag));
    }
  } else {
    a_list.add(a_label,new funtag_cbk<list>(a_gv,a_list,a_func,a_tag));
  }
}

inline bcbk::return_action action_none(gui_viewer&,const bcbk&,list&,void*) {
  return bcbk::return_none;
}

inline bcbk::return_action action_exit(gui_viewer& a_gv,const bcbk&,list&,void*) {
  a_gv.set_to_exit();
  return bcbk::return_none;
}

inline bcbk::return_action action_about(gui_viewer& a_gv,const bcbk&,list&,void* a_tag) {

  const std::vector<std::string>& a_txt = *((const std::vector<std::string>*)a_tag);

  sg::text* text = new sg::text(a_gv.ttf());
  text->font = sg::gui_font();
  a_gv.set_colors(*text);

  text->strings = a_txt;

  text->confine = true;
  text->hjust = sg::center;

  a_gv.push_list(text);

  return bcbk::return_to_render;
}

}}

#endif
