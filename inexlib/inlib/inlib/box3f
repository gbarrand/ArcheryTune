// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_box3f
#define inlib_box3f

#include "vec3f"
#include "mnmx"

#include <cfloat> // FLT_MAX
#include <ostream>

namespace inlib {

class box3f {
public:
  box3f(){
    make_empty();
  }
  virtual ~box3f() {}
public:
  box3f(const box3f& a_from)
  :m_min(a_from.m_min)
  ,m_max(a_from.m_max)
  {}
  box3f& operator=(const box3f& a_from){
    m_min = a_from.m_min;
    m_max = a_from.m_max;
    return *this;
  }
public:
  bool center(vec3f& a_center) const {
    if(is_empty()) {
      a_center.set_value(0,0,0); //??
      return false;
    }
    a_center.set_value((m_max[0] + m_min[0]) * 0.5f,
                       (m_max[1] + m_min[1]) * 0.5f,
                       (m_max[2] + m_min[2]) * 0.5f);
    return true;
  }

  bool set_bounds(const vec3f& a_mn,const vec3f& a_mx){
    if( a_mn[0]>a_mx[0] || 
        a_mn[1]>a_mx[1] || 
        a_mn[2]>a_mx[2]) return false;
    m_min = a_mn;
    m_max = a_mx;
    return true;
  }
  bool set_bounds(float a_mn_x,float a_mn_y,float a_mn_z,
                  float a_mx_x,float a_mx_y,float a_mx_z){
    if( a_mn_x>a_mx_x || 
        a_mn_y>a_mx_y || 
        a_mn_z>a_mx_z ) return false;
    m_min.set_value(a_mn_x,a_mn_y,a_mn_z);
    m_max.set_value(a_mx_x,a_mx_y,a_mx_z);
    return true;
  }
  void make_empty(){
    m_min.set_value(FLT_MAX, FLT_MAX, FLT_MAX);
    m_max.set_value(-FLT_MAX, -FLT_MAX, -FLT_MAX);
  }
  bool get_size(float& a_dx,float& a_dy,float& a_dz) const {
    if(is_empty()) {
      a_dx = 0;
      a_dy = 0;
      a_dz = 0;
      return false;
    }
    a_dx = m_max[0] - m_min[0];
    a_dy = m_max[1] - m_min[1];
    a_dz = m_max[2] - m_min[2];
    return true;
  }
  bool is_empty() const {
    return m_max[0] < m_min[0];
  }
  const vec3f& mn() const {return m_min;}
  const vec3f& mx() const {return m_max;}

  void extend_by(const vec3f& a_point) {
    // Extend the boundaries of the box by the given point, i.e. make the
    // point fit inside the box if it isn't already so.
    if(is_empty()) {
      set_bounds(a_point,a_point);
    } else {
      m_min.set_value(inlib::mn<float>(a_point[0],m_min[0]),
                      inlib::mn<float>(a_point[1],m_min[1]),
                      inlib::mn<float>(a_point[2],m_min[2]));
      m_max.set_value(inlib::mx<float>(a_point[0],m_max[0]),
                      inlib::mx<float>(a_point[1],m_max[1]),
                      inlib::mx<float>(a_point[2],m_max[2]));
    }
  }

  void extend_by(float a_x,float a_y,float a_z) {
    // Extend the boundaries of the box by the given point, i.e. make the
    // point fit inside the box if it isn't already so.
    if(is_empty()) {
      set_bounds(a_x,a_y,a_z,a_x,a_y,a_z);
    } else {
      m_min.set_value(inlib::mn<float>(a_x,m_min[0]),
                      inlib::mn<float>(a_y,m_min[1]),
                      inlib::mn<float>(a_z,m_min[2]));
      m_max.set_value(inlib::mx<float>(a_x,m_max[0]),
                      inlib::mx<float>(a_y,m_max[1]),
                      inlib::mx<float>(a_z,m_max[2]));
    }
  }

  //NOTE : print is a Python keyword.
  void dump(std::ostream& a_out) {
    float dx,dy,dz;
    if(!get_size(dx,dy,dz)) {
      a_out << "box is empty." << std::endl;
    } else {
      a_out << " size " << dx << " " << dy << " " << dz << std::endl;
    }
    a_out << " min " << m_min[0] << " " << m_min[1] << " " << m_min[2] << std::endl;
    a_out << " max " << m_max[0] << " " << m_max[1] << " " << m_max[2] << std::endl;
    vec3f c;
    center(c);
    a_out << " center " << c[0] << " " << c[1] << " " << c[2] << std::endl;
  }

protected:
  vec3f m_min;
  vec3f m_max;
};

}

#endif
