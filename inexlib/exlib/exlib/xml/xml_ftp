// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file exlib.license for terms.

#ifndef exlib_xml_ftp
#define exlib_xml_ftp

#include "loader"
#include <inlib/forit>
#include <inlib/b2s>

namespace exlib {
namespace xml {

class ftp {
public:
  ftp():m_active(true){}
  ftp(const std::string& a_host,
             const std::string& a_user,
             const std::string& a_pass,
             const std::string& a_dir,
             bool a_active)
  :m_host(a_host)
  ,m_user(a_user)
  ,m_pass(a_pass)
  ,m_dir(a_dir)
  ,m_active(a_active)
  {}
  virtual ~ftp(){}
public:
  ftp(const ftp& a_from)
  :m_host(a_from.m_host)
  ,m_user(a_from.m_user)
  ,m_pass(a_from.m_pass)
  ,m_dir(a_from.m_dir)
  ,m_active(a_from.m_active)
  {}
  ftp& operator=(const ftp& a_from){
    m_host = a_from.m_host;
    m_user = a_from.m_user;
    m_pass = a_from.m_pass;
    m_dir = a_from.m_dir;
    m_active = a_from.m_active;
    return *this;
  }
public:
  const std::string& host() const {return m_host;}
  const std::string& user() const {return m_user;}
  const std::string& pass() const {return m_pass;}
  const std::string& dir() const {return m_dir;}
  bool active() const {return m_active;}
protected:
  std::string m_host;
  std::string m_user;
  std::string m_pass;
  std::string m_dir;
  bool m_active;
};

class xml_ftp {
public:
  xml_ftp(){}
  virtual ~xml_ftp(){}
public:
  xml_ftp(const xml_ftp& a_from)
  :m_ftps(a_from.m_ftps)
  {}
  xml_ftp& operator=(const xml_ftp& a_from){
    m_ftps = a_from.m_ftps;
    return *this;
  }
public:
  std::vector<ftp> ftps() {return m_ftps;}
  const std::vector<ftp>& ftps() const {return m_ftps;}  
  void add_ftp(const std::string& a_host,
                      const std::string& a_user,
                      const std::string& a_pass,
                      const std::string& a_dir,
                      bool a_active) {
    //look if already in the list :
    inlib_vforcit(ftp,m_ftps,it) {
      if( ((*it).host()==a_host) && 
          ((*it).user()==a_user) &&
          ((*it).pass()==a_pass) &&
          ((*it).dir()==a_dir)   &&
          ((*it).active()==a_active) 
        ) return;
    }
    m_ftps.push_back(ftp(a_host,a_user,a_pass,a_dir,a_active));
  }
  bool save_ftps(const std::string& a_path) {
    std::vector<std::string> lines;
    std::string stmp;
    lines.push_back("<ftps>");
    inlib_vforcit(ftp,m_ftps,it) {
      lines.push_back("  <ftp>");
      lines.push_back("    <host>"+(*it).host()+"</host>");
      lines.push_back("    <user>"+(*it).user()+"</user>");
      lines.push_back("    <pass>"+(*it).pass()+"</pass>");
      lines.push_back("    <dir>"+(*it).dir()+"</dir>");
      inlib::b2s((*it).active(),stmp);
      lines.push_back("    <active>"+stmp+"</active>");
      lines.push_back("  </ftp>");
    }    
    lines.push_back("</ftps>");
    return inlib::file::write(a_path,lines);
  }

  bool load_ftp_file(std::ostream& a_out,const std::string& a_file) {
    inlib::xml::default_factory factory;
    exlib::xml::loader ml(factory,a_out,false);
    std::vector<std::string> tags;
    tags.push_back("ftps");
    tags.push_back("ftp");
    ml.set_tags(tags);
    if(!ml.load_file(a_file,false)) return false;
    inlib::xml::tree* top = ml.top_item();
    if(!top) return true; //File could be empty.
    return scan_ftp_tree(*top);
  }

protected:
  bool scan_ftp_tree(inlib::xml::tree& a_tree) {

    const std::string& tag = a_tree.tag_name();
    if(tag=="ftps") {
    } else if(tag=="ftp") {   
      load_ftp(a_tree);
    }
  
    // scan children :
   {inlib::xml::looper _for(a_tree);
    while(inlib::xml::tree* _tree = _for.next_tree()) {
      if(!scan_ftp_tree(*_tree)) return false;
    }}
  
    return true;
  }
  
  void load_ftp(inlib::xml::tree& a_tree) {
    std::string host,user,pass,dir;
    bool active = true;

   {inlib::xml::looper _for(a_tree);
    while(inlib::xml::element* _elem = _for.next_element()) {

      if(_elem->name()=="host") {
        host = _elem->value();
      } else if(_elem->name()=="user") {
        user = _elem->value();
      } else if(_elem->name()=="pass") {
        pass = _elem->value();
      } else if(_elem->name()=="dir") {
        dir = _elem->value();
      } else if(_elem->name()=="active") {
        if(!inlib::to(_elem->value(),active)) { //return false ?
          active = true;
        }
      }

    }}  

    if(host.size() && user.size() && dir.size()) 
      add_ftp(host,user,pass,dir,active);
  }

protected:
  std::vector<ftp> m_ftps;
};

}}

#endif

//exlib_build_use inlib expat
