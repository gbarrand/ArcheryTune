// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file exlib.license for terms.

#ifndef exlib_app_WebGL_main_cpp
#define exlib_app_WebGL_main_cpp

#include "../../WebGL/session"

#include <inlib/net/http_server>

namespace exlib {
namespace WebGL {

template <class APP_MAIN>
class my_server : public inlib::net::http_server {
  INLIB_CLASS_STRING(cmd)

  INLIB_CLASS_STRING_VALUE(cmd_shutdown,shutdown)
public:
  virtual bool dispatch_GET(const std::string& a_url,const inlib::args& a_args) {
    //if(m_verbose) {
    //  ::printf("cmdserv : url : \"%s\"\n",a_url.c_str());
    //}
    std::ostringstream a_reply_sout;
    std::ostringstream a_reply_out;

   {std::string content_type;
    if(m_session.dispatch_url(a_url,a_reply_out,a_reply_sout,content_type)) {
      if(a_reply_out.str().size()) {
        send_reply(a_reply_out.str(),content_type);
      } else if(a_reply_sout.str().size()) {
        send_reply(a_reply_sout.str(),content_type);
      }
      return true;
    }}

    if(a_url=="/") {

      std::string cmd;
      a_args.find(s_cmd(),cmd);
      inlib::replace(cmd,"%20"," ");

     {std::string content_type;
      if(m_session.dispatch_cmd(cmd,a_reply_out,a_reply_sout,content_type)) {
        if(a_reply_out.str().size()) {
          send_reply(a_reply_out.str(),content_type);
        } else if(a_reply_sout.str().size()) {
          send_reply(a_reply_sout.str(),content_type);
        }
        return true;
      }}

      if(m_session.verbose()) m_out << "exlib::WebGL::my_server::dispatch_GET : cmd : " << cmd << std::endl;

      std::string rest;
      inlib::cmd::rest(cmd,rest);
      if(cmd==s_cmd_shutdown()) {
        if(m_session.can_shutdown()) {
          a_reply_sout << s_done();
          send_reply(a_reply_sout.str());
          return false; //exit steer()
        } else {
          m_session.http_failed(a_reply_sout,"cmd=shutdown not enabled.");
          send_reply(a_reply_sout.str());
        }

      } else {
        m_session.http_failed(a_reply_sout,"unknown command.");
        send_reply(a_reply_sout.str());
      }

    }

    return true;
  }
  virtual bool dispatch_POST(const std::string& a_document) {
    if(m_verbose) {
      ::printf("dispatch_POST : document : \"%s\"\n",a_document.c_str());
    }
    send_reply("ok");
    return true;
  }
  virtual bool dispatch_multipart(const std::string& /*a_url*/,const std::vector<inlib::net::http_part*>& /*a_parts*/) {
    return true;
  }
public:
  my_server(std::ostream& a_out,const inlib::args& a_args,bool a_verbose)
  :inlib::net::http_server(a_out,a_verbose)
  ,m_session(a_out,a_args)
  {}
  virtual ~my_server() {}
protected:
  my_server(const my_server& a_from):inlib::net::http_server(a_from),m_session(inlib::args()){}
  my_server& operator=(const my_server&) {return *this;}
protected:
  session<APP_MAIN> m_session;
};

}}

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

#include <iostream>

#ifdef INLIB_MEM
#include <inlib/mem>
#endif

#include <inlib/net/base_socket>

template <class APP_CONTEXT,class APP_MAIN>
int exlib_main(const std::string& a_app_name,int argc,char** argv,bool a_land = true) { //enforce landscape by default for Web apps.

  bool verbose = false;

#ifdef INLIB_MEM
  inlib::mem::set_check_by_class(true);{
#endif

  inlib::args args(argc,argv);
  if(a_land) args.add(inlib::s_arg_land(),"");

  if(args.is_arg(inlib::s_arg_help())) {
    std::cout << "args :" << std::endl
              << inlib::s_arg_help() << std::endl
              << inlib::s_arg_verbose() << std::endl
              << inlib::s_arg_host() << std::endl
              << inlib::s_arg_port() << std::endl
              << inlib::s_arg_can_shutdown() << std::endl
              << inlib::s_arg_land() << std::endl
              << inlib::s_arg_document() << std::endl
              << s_arg_bgcolor() << std::endl
              << s_arg_compression() << std::endl
              << s_arg_reply_compression() << std::endl
              << std::endl;
    return EXIT_SUCCESS;
  }

  verbose = args.is_arg(inlib::s_arg_verbose());

  std::string host;
  if(args.is_arg(inlib::s_arg_host())) {
    args.find(inlib::s_arg_host(),host,"0.0.0.0");
  } else {
    if(!inlib::net::host_name(std::cout,host)) host = "0.0.0.0";
  }

  unsigned int port;
  args.find<unsigned int>(inlib::s_arg_port(),port,8000);
  if(verbose) {
    std::cout << "host " << host << std::endl;
    std::cout << "port " << port << std::endl;
  }

  args.remove(inlib::s_arg_host());
  args.remove(inlib::s_arg_port());
  args.add(s_arg_app_name(),a_app_name);

 {std::string app_exe;
  if(!args.prog_name(app_exe)) {
    std::cout << "no app exe." << std::endl;
  } else {
    std::string res_dir;
    if(!inlib::app_res_dir(app_exe,res_dir)) {
      std::cout << "can't get res_dir." << std::endl;
    } else {
      APP_CONTEXT app_context(res_dir);
    }
  }}

  exlib::WebGL::my_server<APP_MAIN> svr(std::cout,args,verbose);
  if(!svr.initialize(host,port)) {
    std::cout << "my_server.initialize() failed." << std::endl;
    return EXIT_FAILURE;
  }
  svr.steer();

#ifdef INLIB_MEM
  }inlib::mem::balance(std::cout);
  if(verbose) {
    std::cout << "exlib_main : (mem) exit..." << std::endl;
  }
#else
  if(verbose) {
    std::cout << "exlib_main : exit..." << std::endl;
  }
#endif

  return EXIT_SUCCESS;
}

#endif

//exlib_build_use inlib glutess freetype png jpeg zlib expat
