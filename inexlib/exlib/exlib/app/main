// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file exlib.license for terms.

#ifndef exlib_app_main
#define exlib_app_main

//////////////////////////////////////
//////////////////////////////////////
//////////////////////////////////////

#include "../xml/xml_style"
#include "../xml/xml_ftp"
#include "../xml/xml_srv"
#include "../xml/xml_wall"
#include "../xml/LOAD"
#include "../zlib"

#include "../png_opener"
#include "../jpeg_opener"

#include "../insh"

#include <inlib/help/wrap_description_help>
#include <inlib/help/wrap_usage_help>
#include <inlib/help/wrap_top_menu_help>
#include <inlib/help/wrap_files_help>
#include <inlib/help/wrap_exas_help>
#include <inlib/help/wrap_camera_panel_help>
#include <inlib/help/wrap_styles_help>
#include <inlib/help/wrap_fits_help>
#include <inlib/help/wrap_web_help>

#include <inlib/touplow>
//#include <inlib/web>

#include <inlib/cbk/background_popup>
#include <inlib/cbk/image_popup>
#include <inlib/cbk/help>

#include <inlib/sg/view_sg_client>
#include <inlib/sg/gl2ps_manager>
#include <inlib/sg/insh_opener>

#include <inlib/sg/view_sg_serv>

#ifdef EMSCRIPTEN
#include <emscripten.h>
#endif

namespace exlib {
namespace app {

class main
:public inlib::sg::gui_viewer
,public inlib::sg::view_sg_serv
,public inlib::sg::view_sg_client
{
  typedef inlib::sg::gui_viewer parent;
  typedef inlib::sg::view_sg_serv parent_sg_serv;
  typedef inlib::sg::view_sg_client parent_sg_client;
protected:
  //const gui_viewer& get_me() const {return *this;}
  gui_viewer& get_me() {return *this;}
public:
  virtual void* cast(const std::string& a_class) const {
    //if(void* p = inlib::cmp_cast<main>(this,a_class)) return p;
    if(void* p = inlib::cmp_cast<parent_sg_serv>(this,a_class)) return p;
    if(void* p = inlib::cmp_cast<parent_sg_client>(this,a_class)) return p;
    return parent::cast(a_class);
  }
protected:
  INLIB_CLASS_STRING(scene)
  INLIB_CLASS_STRING(gui_Apple_black_on_white)
public:
  virtual void render() = 0;
public:
  main(const std::string& a_app_name,const std::string& a_app_version,
       std::ostream& a_out,
       inlib::sg::render_manager& a_gl_mgr,
       const inlib::sg::base_freetype& a_ttf,
       const inlib::sg::selection& a_selection,
       const std::string& a_doc_dir,
       const std::string& a_res_dir,
       const std::string& a_out_dir,
       const std::string& a_tmp_dir,
       bool a_verbose,
       unsigned int a_mem_limit)
  :parent(a_out,a_gl_mgr,a_ttf,a_selection,0,0,a_verbose)
  ,parent_sg_serv(get_me(),a_verbose)
  ,parent_sg_client(a_out,a_app_name,a_doc_dir,compress_buffer,a_ttf)
  //,m_web_cache(a_out,false) //false = no verbose
  {
    m_res_dir = a_res_dir;
    m_out_dir = a_out_dir;
    m_tmp_dir = a_tmp_dir;
    m_doc_dir = a_doc_dir;

   {std::string _pwd;
    if(!inlib::dir::pwd(_pwd)) {
      m_out << "exlib::app::main::main : can't get pwd." << std::endl;
    } else {
      //m_out << "pwd : " << _pwd << std::endl;
    }
    m_start_dir = _pwd;}

  //m_data_dirs.clear();
  //m_data_dirs.push_back(a_doc_dir);

    // res_dir :
    //   desktop : <install_path>/<app>/<version>/res.
    //   Cocoa : <app>.app/Contents/Resources.
    //   Android : /data/data/fr.in2p3.lal.<app>/files
    //   iPhone : <app>.app/res
   {std::vector<std::string> vals;
    vals.push_back(a_res_dir);
    vals.push_back(a_doc_dir); // So that user can download a font if needed :
    inlib::env_path_append("EXLIB_FONT_PATH",vals);}

    m_app_name = a_app_name;

    m_app_version = a_app_version;

    //m_web_cache.set_tmp_dir(a_tmp_dir);

    ////////////////////////////////////////////
    /// openers ////////////////////////////////
    ////////////////////////////////////////////
    m_opener.add_ext(inlib::file::s_ext_insh());
    m_opener.add_opener(inlib::file::s_format_insh(),new inlib::sg::insh_opener());

    m_opener.add_ext(inlib::file::s_ext_jpeg());
    m_opener.add_ext(inlib::file::s_ext_jpg());
    m_opener.add_opener(inlib::file::s_format_jpeg(),new jpeg_opener(a_mem_limit));

    m_opener.add_ext(inlib::file::s_ext_png());
    m_opener.add_opener(inlib::file::s_format_png(),new png_opener(a_mem_limit));

    ////////////////////////////////////////////
    /// image : ////////////////////////////////
    ////////////////////////////////////////////
    m_image_readers.add_reader(inlib::file::s_format_jpeg(),new jpeg::reader());
    m_image_readers.add_reader(inlib::file::s_format_png(),new png::reader());
    m_png_writer = exlib::png::write;
    m_jpeg_writer = exlib::jpeg::write;

    ////////////////////////////////////////////
    /// help ///////////////////////////////////
    ////////////////////////////////////////////
    typedef inlib::cbk::help::help_item help_item;
    m_help.push_back(help_item("description",description_help));
    m_help.push_back(help_item("usage",usage_help));
    m_help.push_back(help_item("web",web_help));
    m_help.push_back(help_item(inlib::sg::s_files(),files_help));
    m_help.push_back(help_item("examples",exas_help));
    m_help.push_back(help_item("top menu",top_menu_help));
    m_help.push_back(help_item("camera panel",camera_panel_help));
    m_help.push_back(help_item("styles",styles_help));
    m_help.push_back(help_item("fits",fits_help));

    ////////////////////////////////////////////
    /// cmaps //////////////////////////////////
    ////////////////////////////////////////////
    m_styles.add_colormap("default",inlib::sg::style_default_colormap());
    m_styles.add_colormap("ROOT",inlib::sg::style_ROOT_colormap());

    ////////////////////////////////////////////
    /// <app>.style ////////////////////////////
    ////////////////////////////////////////////
    EXLIB_XML_LOAD(style)

    ////////////////////////////////////////////
    ////////////////////////////////////////////
    m_styles.res_color(s_scene(),"screen_color",m_params.m_scene_screen_color);
    set_gui_style(s_gui());

    // old ioda.style in doc_dir : if gui_Apple_white_on_black gui style,
    // avoid orange back on m_gui_label_back_color.
   {std::string alias;
    if(m_styles.is_alias(s_gui(),alias)){
      if(alias==s_gui_Apple_black_on_white()) {
        if(m_params.m_gui_label_back_color==inlib::colorf_orange()){
          m_params.m_gui_label_back_color = inlib::colorf(0.97f,.97f,0.97f);
        }
      }
    }}

    //if(m_verbose) m_styles.dump();

    ////////////////////////////////////////////
    /// <app>.ftp //////////////////////////////
    ////////////////////////////////////////////
    EXLIB_XML_LOAD(ftp)

    ////////////////////////////////////////////
    /// <app>.srv //////////////////////////////
    ////////////////////////////////////////////
    EXLIB_XML_LOAD(srv)

    ////////////////////////////////////////////
    /// <app>.wall /////////////////////////////
    ////////////////////////////////////////////
    EXLIB_XML_LOAD(wall)

    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    m_popup_cbks.add(new inlib::cbk::background_popup(*this));
    m_popup_cbks.add(new inlib::cbk::image_popup(*this,inlib::sg::base_tex::s_class()));
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
    main::insh_add_cmds();

   {std::string PATH;
    doc_res_dirs_to_PATH(PATH);
    m_insh.add_env("PATH",PATH);}

  // avoid too much envs, use cmds.
  //m_insh.add_env("RES_DIR",m_res_dir);
  //m_insh.add_env("DOC_DIR",m_doc_dir);
  //m_insh.add_env("TMP_DIR",m_tmp_dir);
  //m_insh.add_env("OUT_DIR",m_out_dir);
  //m_insh.add_env("START_DIR",m_start_dir);
  //m_insh.add_env("FILE_SEP",inlib::sep());
  //m_insh.add_env("PATH_SEP",inlib::psep());

    ////////////////////////////////////////////
    ////////////////////////////////////////////
    ////////////////////////////////////////////
#ifdef EMSCRIPTEN
    set_use_gsto(true);
#endif
  }
  virtual ~main() {
    //m_web_cache.clear();
  }
protected:
  main(const main& a_from)
  :inlib::sg::ui(a_from)
  ,inlib::sg::alert(a_from)
  ,parent(a_from)
  ,parent_sg_serv(a_from)
  ,parent_sg_client(a_from)
  ,m_ftps(a_from.m_ftps)
  ,m_srvs(a_from.m_srvs)
  //,m_web_cache(m_out,false)
  ,m_tmp_dirs(a_from.m_tmp_dirs)
  {}
  main& operator=(const main& a_from){
    parent::operator=(a_from);
    m_tmp_dirs = a_from.m_tmp_dirs;
    return *this;
  }

public:
  void clear_tmp() {
    inlib_vforcit(std::string,m_tmp_dirs,it){
      if(!inlib::dir::rmdir(*it)){
        viewer::m_out << "exlib::app::main::clear_tmp :"
                      << " can't remove directory "
                      << inlib::sout(*it)
                      << std::endl;
      } /*else {
        viewer::m_out << "exlib::app_main::clear_tmp :"
                      << " remove directory "
                      << inlib::sout(*it)
                      << std::endl;
      }*/
    }
    m_tmp_dirs.clear();
  }
protected:
  void _style_load_file(const std::vector<std::string>& a_args) {
    static const std::string s_header("exlib::app::main::_style_load_file :");
    inlib::args _args(a_args);
    std::string file;
    if(!_args.first_not_hyphen(file)) {
      m_insh.warn(s_header+" no file given.");
      return;
    }
    if(_args.is_arg("-doc_res")) {
      std::string path;
      if(!find_doc_res_file(file,path)) {
        m_insh.warn(s_header+" file "+inlib::sout(file)+" not found in doc and res dirs.");
        return;
      }
      file = path;
    } else if(_args.is_arg("-doc")) {
      std::string path;
      if(!find_doc_file(file,path)) {
        m_insh.warn(s_header+" file "+inlib::sout(file)+" not found in doc dir.");
        return;
      }
      file = path;
    } else if(_args.is_arg("-res")) {
      std::string path;
      if(!find_res_file(file,path)) {
        m_insh.warn(s_header+" file "+inlib::sout(file)+" not found in res dir.");
        return;
      }
      file = path;
    }
    if(!xml::load_style_file(m_out,file,m_styles)) {
      m_insh.warn(s_header+" xml parsing of "+file+" failed.");
      return;
    }
  }
  static const std::string& _style_load_file_help() {
    static const std::string s_help("\
style_load_file: style_load_file [-doc_res,-res,-doc] path\n\
  Load a XML style file.\n\
  If no directory is given in path, the -doc_res option permits to search a file first\n\
  in the document directory declared to the app, and then in the app (internal) resource directory.\n\
  -res for the resource directory only, -doc for the document directory only.\n\
  See also : app_dir.\n\
");
    return s_help;
  }

#ifdef EMSCRIPTEN
  void _emscripten_run_script(const std::vector<std::string>& a_args) {
    if(a_args.empty()) return;
    ::emscripten_run_script(a_args[0].c_str());
  }
  static const std::string& _emscripten_run_script_help() {
    static const std::string s_help("\
ems: ems command\n\
  Do a ::emscripten_run_script(command).\n\
  Example:\n\
    ems 'alert(\"hello world!\")'\n\
");
    return s_help;
  }
  INLIB_INSH_CLASS_CMD(main,ems,m_holder._emscripten_run_script(a_args),_emscripten_run_script_help())
#endif

  INLIB_INSH_CLASS_CMD(main,style_load_file,m_holder._style_load_file(a_args),_style_load_file_help())
  INLIB_INSH_CLASS_CMD(main,gui_push_list,gui_push_list_insh(m_holder,a_args),"gui_push_list: gui_push_list [label script]\n  Show a list menu.\n  A list of pairs (label,script) must be provided.\n  gui_push_list 'item 1' 'echo item 1' 'item 2' 'echo item 2'\n  gui_show_main_menu\n")

  INLIB_INSH_CLASS_CMD(main,web_get_file,exlib::insh_web_get_file(m_holder.insh(),m_holder.doc_dir(),a_args),exlib::insh_web_get_file_help())

  void insh_add_cmds() {
    INLIB_INSH_ADD_CMD(m_insh,*this,style_load_file)
    INLIB_INSH_ADD_CMD(m_insh,*this,gui_push_list)
#ifdef EMSCRIPTEN
    INLIB_INSH_ADD_CMD(m_insh,*this,ems)
#endif
    INLIB_INSH_ADD_CMD(m_insh,*this,web_get_file)
  }
protected:
  inlib::ftp::ftps m_ftps;
  inlib::xml::srvs m_srvs;
  //inlib::web::cache m_web_cache;
  inlib::cbk::help::help_t m_help;
  std::vector<std::string> m_tmp_dirs;
};

}}

//exlib_build_use inlib inlib_glutess freetype expat png zlib jpeg kernel

#endif
